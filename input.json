{"language":"Solidity","sources":{"hedge/lib/forge-std/lib/ds-test/demo/demo.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.0;\n\nimport \"../src/test.sol\";\n\ncontract DemoTest is DSTest {\n    function test_this() public pure {\n        require(true);\n    }\n    function test_logs() public {\n        emit log(\"-- log(string)\");\n        emit log(\"a string\");\n\n        emit log(\"-- log_named_uint(string, uint)\");\n        emit log_named_uint(\"uint\", 512);\n\n        emit log(\"-- log_named_int(string, int)\");\n        emit log_named_int(\"int\", -512);\n\n        emit log(\"-- log_named_address(string, address)\");\n        emit log_named_address(\"address\", address(this));\n\n        emit log(\"-- log_named_bytes32(string, bytes32)\");\n        emit log_named_bytes32(\"bytes32\", \"a string\");\n\n        emit log(\"-- log_named_bytes(string, bytes)\");\n        emit log_named_bytes(\"bytes\", hex\"cafefe\");\n\n        emit log(\"-- log_named_string(string, string)\");\n        emit log_named_string(\"string\", \"a string\");\n\n        emit log(\"-- log_named_decimal_uint(string, uint, uint)\");\n        emit log_named_decimal_uint(\"decimal uint\", 1.0e18, 18);\n\n        emit log(\"-- log_named_decimal_int(string, int, uint)\");\n        emit log_named_decimal_int(\"decimal int\", -1.0e18, 18);\n    }\n    event log_old_named_uint(bytes32,uint);\n    function test_old_logs() public {\n        emit log_old_named_uint(\"key\", 500);\n        emit log_named_bytes32(\"bkey\", \"val\");\n    }\n    function test_trace() public view {\n        this.echo(\"string 1\", \"string 2\");\n    }\n    function test_multiline() public {\n        emit log(\"a multiline\\\\nstring\");\n        emit log(\"a multiline string\");\n        emit log_bytes(\"a string\");\n        emit log_bytes(\"a multiline\\nstring\");\n        emit log_bytes(\"a multiline\\\\nstring\");\n        emit logs(hex\"0000\");\n        emit log_named_bytes(\"0x0000\", hex\"0000\");\n        emit logs(hex\"ff\");\n    }\n    function echo(string memory s1, string memory s2) public pure\n        returns (string memory, string memory)\n    {\n        return (s1, s2);\n    }\n\n    function prove_this(uint x) public {\n        emit log_named_uint(\"sym x\", x);\n        assertGt(x + 1, 0);\n    }\n\n    function test_logn() public {\n        assembly {\n            log0(0x01, 0x02)\n            log1(0x01, 0x02, 0x03)\n            log2(0x01, 0x02, 0x03, 0x04)\n            log3(0x01, 0x02, 0x03, 0x04, 0x05)\n        }\n    }\n\n    event MyEvent(uint, uint indexed, uint, uint indexed);\n    function test_events() public {\n        emit MyEvent(1, 2, 3, 4);\n    }\n\n    function test_asserts() public {\n        string memory err = \"this test has failed!\";\n        emit log(\"## assertTrue(bool)\\n\");\n        assertTrue(false);\n        emit log(\"\\n\");\n        assertTrue(false, err);\n\n        emit log(\"\\n## assertEq(address,address)\\n\");\n        assertEq(address(this), msg.sender);\n        emit log(\"\\n\");\n        assertEq(address(this), msg.sender, err);\n\n        emit log(\"\\n## assertEq32(bytes32,bytes32)\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\");\n        emit log(\"\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\", err);\n\n        emit log(\"\\n## assertEq(bytes32,bytes32)\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\");\n        emit log(\"\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\", err);\n\n        emit log(\"\\n## assertEq(uint,uint)\\n\");\n        assertEq(uint(0), 1);\n        emit log(\"\\n\");\n        assertEq(uint(0), 1, err);\n\n        emit log(\"\\n## assertEq(int,int)\\n\");\n        assertEq(-1, -2);\n        emit log(\"\\n\");\n        assertEq(-1, -2, err);\n\n        emit log(\"\\n## assertEqDecimal(int,int,uint)\\n\");\n        assertEqDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertEqDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertEqDecimal(uint,uint,uint)\\n\");\n        assertEqDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertEqDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertGt(uint,uint)\\n\");\n        assertGt(uint(0), 0);\n        emit log(\"\\n\");\n        assertGt(uint(0), 0, err);\n\n        emit log(\"\\n## assertGt(int,int)\\n\");\n        assertGt(-1, -1);\n        emit log(\"\\n\");\n        assertGt(-1, -1, err);\n\n        emit log(\"\\n## assertGtDecimal(int,int,uint)\\n\");\n        assertGtDecimal(-2.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertGtDecimal(-2.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertGtDecimal(uint,uint,uint)\\n\");\n        assertGtDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertGtDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertGe(uint,uint)\\n\");\n        assertGe(uint(0), 1);\n        emit log(\"\\n\");\n        assertGe(uint(0), 1, err);\n\n        emit log(\"\\n## assertGe(int,int)\\n\");\n        assertGe(-1, 0);\n        emit log(\"\\n\");\n        assertGe(-1, 0, err);\n\n        emit log(\"\\n## assertGeDecimal(int,int,uint)\\n\");\n        assertGeDecimal(-2.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertGeDecimal(-2.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertGeDecimal(uint,uint,uint)\\n\");\n        assertGeDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertGeDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertLt(uint,uint)\\n\");\n        assertLt(uint(0), 0);\n        emit log(\"\\n\");\n        assertLt(uint(0), 0, err);\n\n        emit log(\"\\n## assertLt(int,int)\\n\");\n        assertLt(-1, -1);\n        emit log(\"\\n\");\n        assertLt(-1, -1, err);\n\n        emit log(\"\\n## assertLtDecimal(int,int,uint)\\n\");\n        assertLtDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertLtDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertLtDecimal(uint,uint,uint)\\n\");\n        assertLtDecimal(uint(2.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertLtDecimal(uint(2.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertLe(uint,uint)\\n\");\n        assertLe(uint(1), 0);\n        emit log(\"\\n\");\n        assertLe(uint(1), 0, err);\n\n        emit log(\"\\n## assertLe(int,int)\\n\");\n        assertLe(0, -1);\n        emit log(\"\\n\");\n        assertLe(0, -1, err);\n\n        emit log(\"\\n## assertLeDecimal(int,int,uint)\\n\");\n        assertLeDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertLeDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertLeDecimal(uint,uint,uint)\\n\");\n        assertLeDecimal(uint(2.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertLeDecimal(uint(2.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertEq(string,string)\\n\");\n        string memory s1 = \"string 1\";\n        string memory s2 = \"string 2\";\n        assertEq(s1, s2);\n        emit log(\"\\n\");\n        assertEq(s1, s2, err);\n\n        emit log(\"\\n## assertEq0(bytes,bytes)\\n\");\n        assertEq0(hex\"abcdef01\", hex\"abcdef02\");\n        emit log(\"\\n\");\n        assertEq0(hex\"abcdef01\", hex\"abcdef02\", err);\n    }\n}\n\ncontract DemoTestWithSetUp {\n    function setUp() public {\n    }\n    function test_pass() public pure {\n    }\n}\n"},"hedge/lib/forge-std/lib/ds-test/src/test.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.0;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool private _failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function failed() public returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            bool globalFailed = false;\n            if (hasHEVMContext()) {\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\n                    abi.encodePacked(\n                        bytes4(keccak256(\"load(address,bytes32)\")),\n                        abi.encode(HEVM_ADDRESS, bytes32(\"failed\"))\n                    )\n                );\n                globalFailed = abi.decode(retdata, (bool));\n            }\n            return globalFailed;\n        }\n    }\n\n    function fail() internal virtual {\n        if (hasHEVMContext()) {\n            (bool status, ) = HEVM_ADDRESS.call(\n                abi.encodePacked(\n                    bytes4(keccak256(\"store(address,bytes32,bytes32)\")),\n                    abi.encode(HEVM_ADDRESS, bytes32(\"failed\"), bytes32(uint256(0x01)))\n                )\n            );\n            status; // Silence compiler warnings\n        }\n        _failed = true;\n    }\n\n    function hasHEVMContext() internal view returns (bool) {\n        uint256 hevmCodeSize = 0;\n        assembly {\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\n        }\n        return hevmCodeSize > 0;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"      Left\", a);\n            emit log_named_address(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"      Left\", a);\n            emit log_named_bytes32(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"      Left\", a);\n            emit log_named_int(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"      Left\", a);\n            emit log_named_uint(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"      Left\", a, decimals);\n            emit log_named_decimal_int(\"     Right\", b, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"      Left\", a, decimals);\n            emit log_named_decimal_uint(\"     Right\", b, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertNotEq(address a, address b) internal {\n        if (a == b) {\n            emit log(\"Error: a != b not satisfied [address]\");\n            emit log_named_address(\"      Left\", a);\n            emit log_named_address(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertNotEq(address a, address b, string memory err) internal {\n        if (a == b) {\n            emit log_named_string (\"Error\", err);\n            assertNotEq(a, b);\n        }\n    }\n\n    function assertNotEq(bytes32 a, bytes32 b) internal {\n        if (a == b) {\n            emit log(\"Error: a != b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"      Left\", a);\n            emit log_named_bytes32(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertNotEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a == b) {\n            emit log_named_string (\"Error\", err);\n            assertNotEq(a, b);\n        }\n    }\n    function assertNotEq32(bytes32 a, bytes32 b) internal {\n        assertNotEq(a, b);\n    }\n    function assertNotEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertNotEq(a, b, err);\n    }\n\n    function assertNotEq(int a, int b) internal {\n        if (a == b) {\n            emit log(\"Error: a != b not satisfied [int]\");\n            emit log_named_int(\"      Left\", a);\n            emit log_named_int(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertNotEq(int a, int b, string memory err) internal {\n        if (a == b) {\n            emit log_named_string(\"Error\", err);\n            assertNotEq(a, b);\n        }\n    }\n    function assertNotEq(uint a, uint b) internal {\n        if (a == b) {\n            emit log(\"Error: a != b not satisfied [uint]\");\n            emit log_named_uint(\"      Left\", a);\n            emit log_named_uint(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertNotEq(uint a, uint b, string memory err) internal {\n        if (a == b) {\n            emit log_named_string(\"Error\", err);\n            assertNotEq(a, b);\n        }\n    }\n    function assertNotEqDecimal(int a, int b, uint decimals) internal {\n        if (a == b) {\n            emit log(\"Error: a != b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"      Left\", a, decimals);\n            emit log_named_decimal_int(\"     Right\", b, decimals);\n            fail();\n        }\n    }\n    function assertNotEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a == b) {\n            emit log_named_string(\"Error\", err);\n            assertNotEqDecimal(a, b, decimals);\n        }\n    }\n    function assertNotEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a == b) {\n            emit log(\"Error: a != b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"      Left\", a, decimals);\n            emit log_named_decimal_uint(\"     Right\", b, decimals);\n            fail();\n        }\n    }\n    function assertNotEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a == b) {\n            emit log_named_string(\"Error\", err);\n            assertNotEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"      Left\", a);\n            emit log_named_string(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertNotEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a != b not satisfied [string]\");\n            emit log_named_string(\"      Left\", a);\n            emit log_named_string(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertNotEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertNotEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"      Left\", a);\n            emit log_named_bytes(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n\n    function assertNotEq0(bytes memory a, bytes memory b) internal {\n        if (checkEq0(a, b)) {\n            emit log(\"Error: a != b not satisfied [bytes]\");\n            emit log_named_bytes(\"      Left\", a);\n            emit log_named_bytes(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertNotEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertNotEq0(a, b);\n        }\n    }\n}\n"},"hedge/lib/forge-std/lib/ds-test/src/test.t.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.0;\n\nimport {DSTest} from \"./test.sol\";\n\ncontract DemoTest is DSTest {\n\n    // --- assertTrue ---\n\n    function testAssertTrue() public {\n        assertTrue(true, \"msg\");\n        assertTrue(true);\n    }\n    function testFailAssertTrue() public {\n        assertTrue(false);\n    }\n    function testFailAssertTrueWithMsg() public {\n        assertTrue(false, \"msg\");\n    }\n\n    // --- assertEq (Addr) ---\n\n    function testAssertEqAddr() public {\n        assertEq(address(0x0), address(0x0), \"msg\");\n        assertEq(address(0x0), address(0x0));\n    }\n    function testFailAssertEqAddr() public {\n        assertEq(address(0x0), address(0x1));\n    }\n    function testFailAssertEqAddrWithMsg() public {\n        assertEq(address(0x0), address(0x1), \"msg\");\n    }\n\n    // --- assertEq (Bytes32) ---\n\n    function testAssertEqBytes32() public {\n        assertEq(bytes32(\"hi\"), bytes32(\"hi\"), \"msg\");\n        assertEq(bytes32(\"hi\"), bytes32(\"hi\"));\n    }\n    function testFailAssertEqBytes32() public {\n        assertEq(bytes32(\"hi\"), bytes32(\"ho\"));\n    }\n    function testFailAssertEqBytes32WithMsg() public {\n        assertEq(bytes32(\"hi\"), bytes32(\"ho\"), \"msg\");\n    }\n\n    // --- assertEq (Int) ---\n\n    function testAssertEqInt() public {\n        assertEq(-1, -1, \"msg\");\n        assertEq(-1, -1);\n    }\n    function testFailAssertEqInt() public {\n        assertEq(-1, -2);\n    }\n    function testFailAssertEqIntWithMsg() public {\n        assertEq(-1, -2, \"msg\");\n    }\n\n    // --- assertEq (UInt) ---\n\n    function testAssertEqUInt() public {\n        assertEq(uint(1), uint(1), \"msg\");\n        assertEq(uint(1), uint(1));\n    }\n    function testFailAssertEqUInt() public {\n        assertEq(uint(1), uint(2));\n    }\n    function testFailAssertEqUIntWithMsg() public {\n        assertEq(uint(1), uint(2), \"msg\");\n    }\n\n    // --- assertEqDecimal (Int) ---\n\n    function testAssertEqDecimalInt() public {\n        assertEqDecimal(-1, -1, 18, \"msg\");\n        assertEqDecimal(-1, -1, 18);\n    }\n    function testFailAssertEqDecimalInt() public {\n        assertEqDecimal(-1, -2, 18);\n    }\n    function testFailAssertEqDecimalIntWithMsg() public {\n        assertEqDecimal(-1, -2, 18, \"msg\");\n    }\n\n    // --- assertEqDecimal (UInt) ---\n\n    function testAssertEqDecimalUInt() public {\n        assertEqDecimal(uint(1), uint(1), 18, \"msg\");\n        assertEqDecimal(uint(1), uint(1), 18);\n    }\n    function testFailAssertEqDecimalUInt() public {\n        assertEqDecimal(uint(1), uint(2), 18);\n    }\n    function testFailAssertEqDecimalUIntWithMsg() public {\n        assertEqDecimal(uint(1), uint(2), 18, \"msg\");\n    }\n\n    // --- assertNotEq (Addr) ---\n\n    function testAssertNotEqAddr() public {\n        assertNotEq(address(0x0), address(0x1), \"msg\");\n        assertNotEq(address(0x0), address(0x1));\n    }\n    function testFailAssertNotEqAddr() public {\n        assertNotEq(address(0x0), address(0x0));\n    }\n    function testFailAssertNotEqAddrWithMsg() public {\n        assertNotEq(address(0x0), address(0x0), \"msg\");\n    }\n\n    // --- assertNotEq (Bytes32) ---\n\n    function testAssertNotEqBytes32() public {\n        assertNotEq(bytes32(\"hi\"), bytes32(\"ho\"), \"msg\");\n        assertNotEq(bytes32(\"hi\"), bytes32(\"ho\"));\n    }\n    function testFailAssertNotEqBytes32() public {\n        assertNotEq(bytes32(\"hi\"), bytes32(\"hi\"));\n    }\n    function testFailAssertNotEqBytes32WithMsg() public {\n        assertNotEq(bytes32(\"hi\"), bytes32(\"hi\"), \"msg\");\n    }\n\n    // --- assertNotEq (Int) ---\n\n    function testAssertNotEqInt() public {\n        assertNotEq(-1, -2, \"msg\");\n        assertNotEq(-1, -2);\n    }\n    function testFailAssertNotEqInt() public {\n        assertNotEq(-1, -1);\n    }\n    function testFailAssertNotEqIntWithMsg() public {\n        assertNotEq(-1, -1, \"msg\");\n    }\n\n    // --- assertNotEq (UInt) ---\n\n    function testAssertNotEqUInt() public {\n        assertNotEq(uint(1), uint(2), \"msg\");\n        assertNotEq(uint(1), uint(2));\n    }\n    function testFailAssertNotEqUInt() public {\n        assertNotEq(uint(1), uint(1));\n    }\n    function testFailAssertNotEqUIntWithMsg() public {\n        assertNotEq(uint(1), uint(1), \"msg\");\n    }\n\n    // --- assertNotEqDecimal (Int) ---\n\n    function testAssertNotEqDecimalInt() public {\n        assertNotEqDecimal(-1, -2, 18, \"msg\");\n        assertNotEqDecimal(-1, -2, 18);\n    }\n    function testFailAssertNotEqDecimalInt() public {\n        assertNotEqDecimal(-1, -1, 18);\n    }\n    function testFailAssertNotEqDecimalIntWithMsg() public {\n        assertNotEqDecimal(-1, -1, 18, \"msg\");\n    }\n\n    // --- assertNotEqDecimal (UInt) ---\n\n    function testAssertNotEqDecimalUInt() public {\n        assertNotEqDecimal(uint(1), uint(2), 18, \"msg\");\n        assertNotEqDecimal(uint(1), uint(2), 18);\n    }\n    function testFailAssertNotEqDecimalUInt() public {\n        assertNotEqDecimal(uint(1), uint(1), 18);\n    }\n    function testFailAssertNotEqDecimalUIntWithMsg() public {\n        assertNotEqDecimal(uint(1), uint(1), 18, \"msg\");\n    }\n\n    // --- assertGt (UInt) ---\n\n    function testAssertGtUInt() public {\n        assertGt(uint(2), uint(1), \"msg\");\n        assertGt(uint(3), uint(2));\n    }\n    function testFailAssertGtUInt() public {\n        assertGt(uint(1), uint(2));\n    }\n    function testFailAssertGtUIntWithMsg() public {\n        assertGt(uint(1), uint(2), \"msg\");\n    }\n\n    // --- assertGt (Int) ---\n\n    function testAssertGtInt() public {\n        assertGt(-1, -2, \"msg\");\n        assertGt(-1, -3);\n    }\n    function testFailAssertGtInt() public {\n        assertGt(-2, -1);\n    }\n    function testFailAssertGtIntWithMsg() public {\n        assertGt(-2, -1, \"msg\");\n    }\n\n    // --- assertGtDecimal (UInt) ---\n\n    function testAssertGtDecimalUInt() public {\n        assertGtDecimal(uint(2), uint(1), 18, \"msg\");\n        assertGtDecimal(uint(3), uint(2), 18);\n    }\n    function testFailAssertGtDecimalUInt() public {\n        assertGtDecimal(uint(1), uint(2), 18);\n    }\n    function testFailAssertGtDecimalUIntWithMsg() public {\n        assertGtDecimal(uint(1), uint(2), 18, \"msg\");\n    }\n\n    // --- assertGtDecimal (Int) ---\n\n    function testAssertGtDecimalInt() public {\n        assertGtDecimal(-1, -2, 18, \"msg\");\n        assertGtDecimal(-1, -3, 18);\n    }\n    function testFailAssertGtDecimalInt() public {\n        assertGtDecimal(-2, -1, 18);\n    }\n    function testFailAssertGtDecimalIntWithMsg() public {\n        assertGtDecimal(-2, -1, 18, \"msg\");\n    }\n\n    // --- assertGe (UInt) ---\n\n    function testAssertGeUInt() public {\n        assertGe(uint(2), uint(1), \"msg\");\n        assertGe(uint(2), uint(2));\n    }\n    function testFailAssertGeUInt() public {\n        assertGe(uint(1), uint(2));\n    }\n    function testFailAssertGeUIntWithMsg() public {\n        assertGe(uint(1), uint(2), \"msg\");\n    }\n\n    // --- assertGe (Int) ---\n\n    function testAssertGeInt() public {\n        assertGe(-1, -2, \"msg\");\n        assertGe(-1, -1);\n    }\n    function testFailAssertGeInt() public {\n        assertGe(-2, -1);\n    }\n    function testFailAssertGeIntWithMsg() public {\n        assertGe(-2, -1, \"msg\");\n    }\n\n    // --- assertGeDecimal (UInt) ---\n\n    function testAssertGeDecimalUInt() public {\n        assertGeDecimal(uint(2), uint(1), 18, \"msg\");\n        assertGeDecimal(uint(2), uint(2), 18);\n    }\n    function testFailAssertGeDecimalUInt() public {\n        assertGeDecimal(uint(1), uint(2), 18);\n    }\n    function testFailAssertGeDecimalUIntWithMsg() public {\n        assertGeDecimal(uint(1), uint(2), 18, \"msg\");\n    }\n\n    // --- assertGeDecimal (Int) ---\n\n    function testAssertGeDecimalInt() public {\n        assertGeDecimal(-1, -2, 18, \"msg\");\n        assertGeDecimal(-1, -2, 18);\n    }\n    function testFailAssertGeDecimalInt() public {\n        assertGeDecimal(-2, -1, 18);\n    }\n    function testFailAssertGeDecimalIntWithMsg() public {\n        assertGeDecimal(-2, -1, 18, \"msg\");\n    }\n\n    // --- assertLt (UInt) ---\n\n    function testAssertLtUInt() public {\n        assertLt(uint(1), uint(2), \"msg\");\n        assertLt(uint(1), uint(3));\n    }\n    function testFailAssertLtUInt() public {\n        assertLt(uint(2), uint(2));\n    }\n    function testFailAssertLtUIntWithMsg() public {\n        assertLt(uint(3), uint(2), \"msg\");\n    }\n\n    // --- assertLt (Int) ---\n\n    function testAssertLtInt() public {\n        assertLt(-2, -1, \"msg\");\n        assertLt(-1, 0);\n    }\n    function testFailAssertLtInt() public {\n        assertLt(-1, -2);\n    }\n    function testFailAssertLtIntWithMsg() public {\n        assertLt(-1, -1, \"msg\");\n    }\n\n    // --- assertLtDecimal (UInt) ---\n\n    function testAssertLtDecimalUInt() public {\n        assertLtDecimal(uint(1), uint(2), 18, \"msg\");\n        assertLtDecimal(uint(2), uint(3), 18);\n    }\n    function testFailAssertLtDecimalUInt() public {\n        assertLtDecimal(uint(1), uint(1), 18);\n    }\n    function testFailAssertLtDecimalUIntWithMsg() public {\n        assertLtDecimal(uint(2), uint(1), 18, \"msg\");\n    }\n\n    // --- assertLtDecimal (Int) ---\n\n    function testAssertLtDecimalInt() public {\n        assertLtDecimal(-2, -1, 18, \"msg\");\n        assertLtDecimal(-2, -1, 18);\n    }\n    function testFailAssertLtDecimalInt() public {\n        assertLtDecimal(-2, -2, 18);\n    }\n    function testFailAssertLtDecimalIntWithMsg() public {\n        assertLtDecimal(-1, -2, 18, \"msg\");\n    }\n\n    // --- assertLe (UInt) ---\n\n    function testAssertLeUInt() public {\n        assertLe(uint(1), uint(2), \"msg\");\n        assertLe(uint(1), uint(1));\n    }\n    function testFailAssertLeUInt() public {\n        assertLe(uint(4), uint(2));\n    }\n    function testFailAssertLeUIntWithMsg() public {\n        assertLe(uint(3), uint(2), \"msg\");\n    }\n\n    // --- assertLe (Int) ---\n\n    function testAssertLeInt() public {\n        assertLe(-2, -1, \"msg\");\n        assertLe(-1, -1);\n    }\n    function testFailAssertLeInt() public {\n        assertLe(-1, -2);\n    }\n    function testFailAssertLeIntWithMsg() public {\n        assertLe(-1, -3, \"msg\");\n    }\n\n    // --- assertLeDecimal (UInt) ---\n\n    function testAssertLeDecimalUInt() public {\n        assertLeDecimal(uint(1), uint(2), 18, \"msg\");\n        assertLeDecimal(uint(2), uint(2), 18);\n    }\n    function testFailAssertLeDecimalUInt() public {\n        assertLeDecimal(uint(1), uint(0), 18);\n    }\n    function testFailAssertLeDecimalUIntWithMsg() public {\n        assertLeDecimal(uint(1), uint(0), 18, \"msg\");\n    }\n\n    // --- assertLeDecimal (Int) ---\n\n    function testAssertLeDecimalInt() public {\n        assertLeDecimal(-2, -1, 18, \"msg\");\n        assertLeDecimal(-2, -2, 18);\n    }\n    function testFailAssertLeDecimalInt() public {\n        assertLeDecimal(-2, -3, 18);\n    }\n    function testFailAssertLeDecimalIntWithMsg() public {\n        assertLeDecimal(-1, -2, 18, \"msg\");\n    }\n\n    // --- assertNotEq (String) ---\n\n    function testAssertNotEqString() public {\n        assertNotEq(new string(1), new string(2), \"msg\");\n        assertNotEq(new string(1), new string(2));\n    }\n    function testFailAssertNotEqString() public {\n        assertNotEq(new string(1), new string(1));\n    }\n    function testFailAssertNotEqStringWithMsg() public {\n        assertNotEq(new string(1), new string(1), \"msg\");\n    }\n\n    // --- assertNotEq0 (Bytes) ---\n\n    function testAssertNotEq0Bytes() public {\n        assertNotEq0(bytes(\"hi\"), bytes(\"ho\"), \"msg\");\n        assertNotEq0(bytes(\"hi\"), bytes(\"ho\"));\n    }\n    function testFailAssertNotEq0Bytes() public {\n        assertNotEq0(bytes(\"hi\"), bytes(\"hi\"));\n    }\n    function testFailAssertNotEq0BytesWithMsg() public {\n        assertNotEq0(bytes(\"hi\"), bytes(\"hi\"), \"msg\");\n    }\n\n    // --- fail override ---\n\n    // ensure that fail can be overridden\n    function fail() internal override {\n        super.fail();\n    }\n}\n"},"hedge/lib/forge-std/src/Base.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {StdStorage} from \"./StdStorage.sol\";\nimport {Vm, VmSafe} from \"./Vm.sol\";\n\nabstract contract CommonBase {\n    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.\n    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(\"hevm cheat code\"))));\n    // console.sol and console2.sol work by executing a staticcall to this address.\n    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;\n    // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n    // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.\n    address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256(\"foundry default caller\"))));\n    // Address of the test contract, deployed by the DEFAULT_SENDER.\n    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;\n    // Deterministic deployment address of the Multicall3 contract.\n    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;\n    // The order of the secp256k1 curve.\n    uint256 internal constant SECP256K1_ORDER =\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    Vm internal constant vm = Vm(VM_ADDRESS);\n    StdStorage internal stdstore;\n}\n\nabstract contract TestBase is CommonBase {}\n\nabstract contract ScriptBase is CommonBase {\n    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);\n}\n"},"hedge/lib/forge-std/src/Script.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\n// 💬 ABOUT\n// Standard Library's default Script.\n\n// 🧩 MODULES\nimport {ScriptBase} from \"./Base.sol\";\nimport {console} from \"./console.sol\";\nimport {console2} from \"./console2.sol\";\nimport {StdChains} from \"./StdChains.sol\";\nimport {StdCheatsSafe} from \"./StdCheats.sol\";\nimport {stdJson} from \"./StdJson.sol\";\nimport {stdMath} from \"./StdMath.sol\";\nimport {StdStorage, stdStorageSafe} from \"./StdStorage.sol\";\nimport {StdUtils} from \"./StdUtils.sol\";\nimport {VmSafe} from \"./Vm.sol\";\n\n// 📦 BOILERPLATE\nimport {ScriptBase} from \"./Base.sol\";\n\n// ⭐️ SCRIPT\nabstract contract Script is StdChains, StdCheatsSafe, StdUtils, ScriptBase {\n    // Note: IS_SCRIPT() must return true.\n    bool public IS_SCRIPT = true;\n}\n"},"hedge/lib/forge-std/src/StdAssertions.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {DSTest} from \"ds-test/test.sol\";\nimport {stdMath} from \"./StdMath.sol\";\n\nabstract contract StdAssertions is DSTest {\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertFalse(bool data, string memory err) internal virtual {\n        assertTrue(!data, err);\n    }\n\n    function assertEq(bool a, bool b) internal virtual {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bool]\");\n            emit log_named_string(\"      Left\", a ? \"true\" : \"false\");\n            emit log_named_string(\"     Right\", b ? \"true\" : \"false\");\n            fail();\n        }\n    }\n\n    function assertEq(bool a, bool b, string memory err) internal virtual {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes memory a, bytes memory b) internal virtual {\n        assertEq0(a, b);\n    }\n\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal virtual {\n        assertEq0(a, b, err);\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [uint[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [int[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [address[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    // Legacy helper\n    function assertEqUint(uint256 a, uint256 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"      Left\", a);\n            emit log_named_uint(\"     Right\", b);\n            emit log_named_uint(\" Max Delta\", maxDelta);\n            emit log_named_uint(\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, string memory err) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_decimal_uint(\"      Left\", a, decimals);\n            emit log_named_decimal_uint(\"     Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max Delta\", maxDelta, decimals);\n            emit log_named_decimal_uint(\"     Delta\", delta, decimals);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\n        }\n    }\n\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int(\"       Left\", a);\n            emit log_named_int(\"      Right\", b);\n            emit log_named_uint(\" Max Delta\", maxDelta);\n            emit log_named_uint(\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta, string memory err) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_decimal_int(\"      Left\", a, decimals);\n            emit log_named_decimal_int(\"     Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max Delta\", maxDelta, decimals);\n            emit log_named_decimal_uint(\"     Delta\", delta, decimals);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"        Left\", a);\n            emit log_named_uint(\"       Right\", b);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta * 100, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta * 100, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_decimal_uint(\"        Left\", a, decimals);\n            emit log_named_decimal_uint(\"       Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta * 100, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta * 100, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals,\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\n        }\n    }\n\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int(\"        Left\", a);\n            emit log_named_int(\"       Right\", b);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta * 100, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta * 100, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta, string memory err) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_decimal_int(\"        Left\", a, decimals);\n            emit log_named_decimal_int(\"       Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta * 100, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta * 100, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\n        }\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {\n        assertEqCall(target, callDataA, target, callDataB, true);\n    }\n\n    function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)\n        internal\n        virtual\n    {\n        assertEqCall(targetA, callDataA, targetB, callDataB, true);\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)\n        internal\n        virtual\n    {\n        assertEqCall(target, callDataA, target, callDataB, strictRevertData);\n    }\n\n    function assertEqCall(\n        address targetA,\n        bytes memory callDataA,\n        address targetB,\n        bytes memory callDataB,\n        bool strictRevertData\n    ) internal virtual {\n        (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);\n        (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);\n\n        if (successA && successB) {\n            assertEq(returnDataA, returnDataB, \"Call return data does not match\");\n        }\n\n        if (!successA && !successB && strictRevertData) {\n            assertEq(returnDataA, returnDataB, \"Call revert data does not match\");\n        }\n\n        if (!successA && successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call revert data\", returnDataA);\n            emit log_named_bytes(\" Right call return data\", returnDataB);\n            fail();\n        }\n\n        if (successA && !successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call return data\", returnDataA);\n            emit log_named_bytes(\" Right call revert data\", returnDataB);\n            fail();\n        }\n    }\n}\n"},"hedge/lib/forge-std/src/StdChains.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n/**\n * StdChains provides information about EVM compatible chains that can be used in scripts/tests.\n * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are\n * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of\n * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the\n * alias used in this contract, which can be found as the first argument to the\n * `setChainWithDefaultRpcUrl` call in the `initializeStdChains` function.\n *\n * There are two main ways to use this contract:\n *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or\n *      `setChain(string memory chainAlias, Chain memory chain)`\n *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.\n *\n * The first time either of those are used, chains are initialized with the default set of RPC URLs.\n * This is done in `initializeStdChains`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in\n * `defaultRpcUrls`.\n *\n * The `setChain` function is straightforward, and it simply saves off the given chain data.\n *\n * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say\n * we want to retrieve the RPC URL for `mainnet`:\n *   - If you have specified data with `setChain`, it will return that.\n *   - If you have configured a mainnet RPC URL in `foundry.toml`, it will return the URL, provided it\n *     is valid (e.g. a URL is specified, or an environment variable is given and exists).\n *   - If neither of the above conditions is met, the default data is returned.\n *\n * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.\n */\nabstract contract StdChains {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    bool private stdChainsInitialized;\n\n    struct ChainData {\n        string name;\n        uint256 chainId;\n        string rpcUrl;\n    }\n\n    struct Chain {\n        // The chain name.\n        string name;\n        // The chain's Chain ID.\n        uint256 chainId;\n        // The chain's alias. (i.e. what gets specified in `foundry.toml`).\n        string chainAlias;\n        // A default RPC endpoint for this chain.\n        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and\n        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy\n        // usage as you will be throttled and this is a disservice to others who need this endpoint.\n        string rpcUrl;\n    }\n\n    // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.\n    mapping(string => Chain) private chains;\n    // Maps from the chain's alias to it's default RPC URL.\n    mapping(string => string) private defaultRpcUrls;\n    // Maps from a chain ID to it's alias.\n    mapping(uint256 => string) private idToAlias;\n\n    bool private fallbackToDefaultRpcUrls = true;\n\n    // The RPC URL will be fetched from config or defaultRpcUrls if possible.\n    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {\n        require(bytes(chainAlias).length != 0, \"StdChains getChain(string): Chain alias cannot be the empty string.\");\n\n        initializeStdChains();\n        chain = chains[chainAlias];\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(string): Chain with alias \\\"\", chainAlias, \"\\\" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {\n        require(chainId != 0, \"StdChains getChain(uint256): Chain ID cannot be 0.\");\n        initializeStdChains();\n        string memory chainAlias = idToAlias[chainId];\n\n        chain = chains[chainAlias];\n\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(uint256): Chain with ID \", vm.toString(chainId), \" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, ChainData memory chain) internal virtual {\n        require(\n            bytes(chainAlias).length != 0,\n            \"StdChains setChain(string,ChainData): Chain alias cannot be the empty string.\"\n        );\n\n        require(chain.chainId != 0, \"StdChains setChain(string,ChainData): Chain ID cannot be 0.\");\n\n        initializeStdChains();\n        string memory foundAlias = idToAlias[chain.chainId];\n\n        require(\n            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),\n            string(\n                abi.encodePacked(\n                    \"StdChains setChain(string,ChainData): Chain ID \",\n                    vm.toString(chain.chainId),\n                    \" already used by \\\"\",\n                    foundAlias,\n                    \"\\\".\"\n                )\n            )\n        );\n\n        uint256 oldChainId = chains[chainAlias].chainId;\n        delete idToAlias[oldChainId];\n\n        chains[chainAlias] =\n            Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});\n        idToAlias[chain.chainId] = chainAlias;\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, Chain memory chain) internal virtual {\n        setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));\n    }\n\n    function _toUpper(string memory str) private pure returns (string memory) {\n        bytes memory strb = bytes(str);\n        bytes memory copy = new bytes(strb.length);\n        for (uint256 i = 0; i < strb.length; i++) {\n            bytes1 b = strb[i];\n            if (b >= 0x61 && b <= 0x7A) {\n                copy[i] = bytes1(uint8(b) - 32);\n            } else {\n                copy[i] = b;\n            }\n        }\n        return string(copy);\n    }\n\n    // lookup rpcUrl, in descending order of priority:\n    // current -> config (foundry.toml) -> environment variable -> default\n    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain) private returns (Chain memory) {\n        if (bytes(chain.rpcUrl).length == 0) {\n            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {\n                chain.rpcUrl = configRpcUrl;\n            } catch (bytes memory err) {\n                string memory envName = string(abi.encodePacked(_toUpper(chainAlias), \"_RPC_URL\"));\n                if (fallbackToDefaultRpcUrls) {\n                    chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);\n                } else {\n                    chain.rpcUrl = vm.envString(envName);\n                }\n                // distinguish 'not found' from 'cannot read'\n                bytes memory notFoundError =\n                    abi.encodeWithSignature(\"CheatCodeError\", string(abi.encodePacked(\"invalid rpc url \", chainAlias)));\n                if (keccak256(notFoundError) != keccak256(err) || bytes(chain.rpcUrl).length == 0) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, err), mload(err))\n                    }\n                }\n            }\n        }\n        return chain;\n    }\n\n    function setFallbackToDefaultRpcUrls(bool useDefault) internal {\n        fallbackToDefaultRpcUrls = useDefault;\n    }\n\n    function initializeStdChains() private {\n        if (stdChainsInitialized) return;\n\n        stdChainsInitialized = true;\n\n        // If adding an RPC here, make sure to test the default RPC URL in `testRpcs`\n        setChainWithDefaultRpcUrl(\"anvil\", ChainData(\"Anvil\", 31337, \"http://127.0.0.1:8545\"));\n        setChainWithDefaultRpcUrl(\n            \"mainnet\", ChainData(\"Mainnet\", 1, \"https://mainnet.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"goerli\", ChainData(\"Goerli\", 5, \"https://goerli.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"sepolia\", ChainData(\"Sepolia\", 11155111, \"https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\")\n        );\n        setChainWithDefaultRpcUrl(\"optimism\", ChainData(\"Optimism\", 10, \"https://mainnet.optimism.io\"));\n        setChainWithDefaultRpcUrl(\"optimism_goerli\", ChainData(\"Optimism Goerli\", 420, \"https://goerli.optimism.io\"));\n        setChainWithDefaultRpcUrl(\"arbitrum_one\", ChainData(\"Arbitrum One\", 42161, \"https://arb1.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"arbitrum_one_goerli\", ChainData(\"Arbitrum One Goerli\", 421613, \"https://goerli-rollup.arbitrum.io/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\"arbitrum_nova\", ChainData(\"Arbitrum Nova\", 42170, \"https://nova.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\"polygon\", ChainData(\"Polygon\", 137, \"https://polygon-rpc.com\"));\n        setChainWithDefaultRpcUrl(\n            \"polygon_mumbai\", ChainData(\"Polygon Mumbai\", 80001, \"https://rpc-mumbai.maticvigil.com\")\n        );\n        setChainWithDefaultRpcUrl(\"avalanche\", ChainData(\"Avalanche\", 43114, \"https://api.avax.network/ext/bc/C/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"avalanche_fuji\", ChainData(\"Avalanche Fuji\", 43113, \"https://api.avax-test.network/ext/bc/C/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain\", ChainData(\"BNB Smart Chain\", 56, \"https://bsc-dataseed1.binance.org\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain_testnet\",\n            ChainData(\"BNB Smart Chain Testnet\", 97, \"https://rpc.ankr.com/bsc_testnet_chapel\")\n        );\n        setChainWithDefaultRpcUrl(\"gnosis_chain\", ChainData(\"Gnosis Chain\", 100, \"https://rpc.gnosischain.com\"));\n    }\n\n    // set chain info, with priority to chainAlias' rpc url in foundry.toml\n    function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {\n        string memory rpcUrl = chain.rpcUrl;\n        defaultRpcUrls[chainAlias] = rpcUrl;\n        chain.rpcUrl = \"\";\n        setChain(chainAlias, chain);\n        chain.rpcUrl = rpcUrl; // restore argument\n    }\n}\n"},"hedge/lib/forge-std/src/StdCheats.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {Vm} from \"./Vm.sol\";\nimport {console2} from \"./console2.sol\";\n\nabstract contract StdCheatsSafe {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    bool private gasMeteringOff;\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawTx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        // json value name = function\n        string functionSig;\n        bytes32 hash;\n        // json value name = tx\n        RawTx1559Detail txDetail;\n        // json value name = type\n        string opcode;\n    }\n\n    struct RawTx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        bytes gas;\n        bytes nonce;\n        address to;\n        bytes txType;\n        bytes value;\n    }\n\n    struct Tx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        bytes32 hash;\n        Tx1559Detail txDetail;\n        string opcode;\n    }\n\n    struct Tx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 nonce;\n        address to;\n        uint256 txType;\n        uint256 value;\n    }\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct TxLegacy {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        string hash;\n        string opcode;\n        TxDetailLegacy transaction;\n    }\n\n    struct TxDetailLegacy {\n        AccessList[] accessList;\n        uint256 chainId;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 gasPrice;\n        bytes32 hash;\n        uint256 nonce;\n        bytes1 opcode;\n        bytes32 r;\n        bytes32 s;\n        uint256 txType;\n        address to;\n        uint8 v;\n        uint256 value;\n    }\n\n    struct AccessList {\n        address accessAddress;\n        bytes32[] storageKeys;\n    }\n\n    // Data structures to parse Receipt objects from the broadcast artifact.\n    // The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawReceipt {\n        bytes32 blockHash;\n        bytes blockNumber;\n        address contractAddress;\n        bytes cumulativeGasUsed;\n        bytes effectiveGasPrice;\n        address from;\n        bytes gasUsed;\n        RawReceiptLog[] logs;\n        bytes logsBloom;\n        bytes status;\n        address to;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n    }\n\n    struct Receipt {\n        bytes32 blockHash;\n        uint256 blockNumber;\n        address contractAddress;\n        uint256 cumulativeGasUsed;\n        uint256 effectiveGasPrice;\n        address from;\n        uint256 gasUsed;\n        ReceiptLog[] logs;\n        bytes logsBloom;\n        uint256 status;\n        address to;\n        bytes32 transactionHash;\n        uint256 transactionIndex;\n    }\n\n    // Data structures to parse the entire broadcast artifact, assuming the\n    // transactions conform to EIP1559.\n\n    struct EIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        Receipt[] receipts;\n        uint256 timestamp;\n        Tx1559[] transactions;\n        TxReturn[] txReturns;\n    }\n\n    struct RawEIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        RawReceipt[] receipts;\n        TxReturn[] txReturns;\n        uint256 timestamp;\n        RawTx1559[] transactions;\n    }\n\n    struct RawReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        bytes blockNumber;\n        bytes data;\n        bytes logIndex;\n        bool removed;\n        bytes32[] topics;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n        bytes transactionLogIndex;\n    }\n\n    struct ReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        uint256 blockNumber;\n        bytes data;\n        uint256 logIndex;\n        bytes32[] topics;\n        uint256 transactionIndex;\n        uint256 transactionLogIndex;\n        bool removed;\n    }\n\n    struct TxReturn {\n        string internalType;\n        string value;\n    }\n\n    struct Account {\n        address addr;\n        uint256 key;\n    }\n\n    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.\n    function assumeNoBlacklisted(address token, address addr) internal virtual {\n        // Nothing to check if `token` is not a contract.\n        uint256 tokenCodeSize;\n        assembly {\n            tokenCodeSize := extcodesize(token)\n        }\n        require(tokenCodeSize > 0, \"StdCheats assumeNoBlacklisted(address,address): Token address is not a contract.\");\n\n        bool success;\n        bytes memory returnData;\n\n        // 4-byte selector for `isBlacklisted(address)`, used by USDC.\n        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xfe575a87, addr));\n        vm.assume(!success || abi.decode(returnData, (bool)) == false);\n\n        // 4-byte selector for `isBlackListed(address)`, used by USDT.\n        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xe47d6060, addr));\n        vm.assume(!success || abi.decode(returnData, (bool)) == false);\n    }\n\n    function assumeNoPrecompiles(address addr) internal virtual {\n        // Assembly required since `block.chainid` was introduced in 0.8.0.\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        assumeNoPrecompiles(addr, chainId);\n    }\n\n    function assumeNoPrecompiles(address addr, uint256 chainId) internal pure virtual {\n        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific\n        // address), but the same rationale for excluding them applies so we include those too.\n\n        // These should be present on all EVM-compatible chains.\n        vm.assume(addr < address(0x1) || addr > address(0x9));\n\n        // forgefmt: disable-start\n        if (chainId == 10 || chainId == 420) {\n            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21\n            vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));\n        } else if (chainId == 42161 || chainId == 421613) {\n            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains\n            vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));\n        } else if (chainId == 43114 || chainId == 43113) {\n            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59\n            vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));\n            vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));\n            vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));\n        }\n        // forgefmt: disable-end\n    }\n\n    function readEIP1559ScriptArtifact(string memory path)\n        internal\n        view\n        virtual\n        returns (EIP1559ScriptArtifact memory)\n    {\n        string memory data = vm.readFile(path);\n        bytes memory parsedData = vm.parseJson(data);\n        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));\n        EIP1559ScriptArtifact memory artifact;\n        artifact.libraries = rawArtifact.libraries;\n        artifact.path = rawArtifact.path;\n        artifact.timestamp = rawArtifact.timestamp;\n        artifact.pending = rawArtifact.pending;\n        artifact.txReturns = rawArtifact.txReturns;\n        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);\n        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);\n        return artifact;\n    }\n\n    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {\n        Tx1559[] memory txs = new Tx1559[](rawTxs.length);\n        for (uint256 i; i < rawTxs.length; i++) {\n            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);\n        }\n        return txs;\n    }\n\n    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {\n        Tx1559 memory transaction;\n        transaction.arguments = rawTx.arguments;\n        transaction.contractName = rawTx.contractName;\n        transaction.functionSig = rawTx.functionSig;\n        transaction.hash = rawTx.hash;\n        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);\n        transaction.opcode = rawTx.opcode;\n        return transaction;\n    }\n\n    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)\n        internal\n        pure\n        virtual\n        returns (Tx1559Detail memory)\n    {\n        Tx1559Detail memory txDetail;\n        txDetail.data = rawDetail.data;\n        txDetail.from = rawDetail.from;\n        txDetail.to = rawDetail.to;\n        txDetail.nonce = _bytesToUint(rawDetail.nonce);\n        txDetail.txType = _bytesToUint(rawDetail.txType);\n        txDetail.value = _bytesToUint(rawDetail.value);\n        txDetail.gas = _bytesToUint(rawDetail.gas);\n        txDetail.accessList = rawDetail.accessList;\n        return txDetail;\n    }\n\n    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".transactions\");\n        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));\n        return rawToConvertedEIPTx1559s(rawTxs);\n    }\n\n    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".transactions[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));\n        return rawToConvertedEIPTx1559(rawTx);\n    }\n\n    // Analogous to readTransactions, but for receipts.\n    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".receipts\");\n        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));\n        return rawToConvertedReceipts(rawReceipts);\n    }\n\n    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".receipts[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));\n        return rawToConvertedReceipt(rawReceipt);\n    }\n\n    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {\n        Receipt[] memory receipts = new Receipt[](rawReceipts.length);\n        for (uint256 i; i < rawReceipts.length; i++) {\n            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);\n        }\n        return receipts;\n    }\n\n    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {\n        Receipt memory receipt;\n        receipt.blockHash = rawReceipt.blockHash;\n        receipt.to = rawReceipt.to;\n        receipt.from = rawReceipt.from;\n        receipt.contractAddress = rawReceipt.contractAddress;\n        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);\n        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);\n        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);\n        receipt.status = _bytesToUint(rawReceipt.status);\n        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);\n        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);\n        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);\n        receipt.logsBloom = rawReceipt.logsBloom;\n        receipt.transactionHash = rawReceipt.transactionHash;\n        return receipt;\n    }\n\n    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)\n        internal\n        pure\n        virtual\n        returns (ReceiptLog[] memory)\n    {\n        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);\n        for (uint256 i; i < rawLogs.length; i++) {\n            logs[i].logAddress = rawLogs[i].logAddress;\n            logs[i].blockHash = rawLogs[i].blockHash;\n            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);\n            logs[i].data = rawLogs[i].data;\n            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);\n            logs[i].topics = rawLogs[i].topics;\n            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);\n            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);\n            logs[i].removed = rawLogs[i].removed;\n        }\n        return logs;\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes): Deployment failed.\");\n    }\n\n    function deployCode(string memory what) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string): Deployment failed.\");\n    }\n\n    /// @dev deploy contract with value on construction\n    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes,uint256): Deployment failed.\");\n    }\n\n    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,uint256): Deployment failed.\");\n    }\n\n    // creates a labeled address and the corresponding private key\n    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\n        addr = vm.addr(privateKey);\n        vm.label(addr, name);\n    }\n\n    // creates a labeled address\n    function makeAddr(string memory name) internal virtual returns (address addr) {\n        (addr,) = makeAddrAndKey(name);\n    }\n\n    // Destroys an account immediately, sending the balance to beneficiary.\n    // Destroying means: balance will be zero, code will be empty, and nonce will be 0\n    // This is similar to selfdestruct but not identical: selfdestruct destroys code and nonce\n    // only after tx ends, this will run immediately.\n    function destroyAccount(address who, address beneficiary) internal virtual {\n        uint256 currBalance = who.balance;\n        vm.etch(who, abi.encode());\n        vm.deal(who, 0);\n        vm.resetNonce(who);\n\n        uint256 beneficiaryBalance = beneficiary.balance;\n        vm.deal(beneficiary, currBalance + beneficiaryBalance);\n    }\n\n    // creates a struct containing both a labeled address and the corresponding private key\n    function makeAccount(string memory name) internal virtual returns (Account memory account) {\n        (account.addr, account.key) = makeAddrAndKey(name);\n    }\n\n    function deriveRememberKey(string memory mnemonic, uint32 index)\n        internal\n        virtual\n        returns (address who, uint256 privateKey)\n    {\n        privateKey = vm.deriveKey(mnemonic, index);\n        who = vm.rememberKey(privateKey);\n    }\n\n    function _bytesToUint(bytes memory b) private pure returns (uint256) {\n        require(b.length <= 32, \"StdCheats _bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    function isFork() internal view virtual returns (bool status) {\n        try vm.activeFork() {\n            status = true;\n        } catch (bytes memory) {}\n    }\n\n    modifier skipWhenForking() {\n        if (!isFork()) {\n            _;\n        }\n    }\n\n    modifier skipWhenNotForking() {\n        if (isFork()) {\n            _;\n        }\n    }\n\n    modifier noGasMetering() {\n        vm.pauseGasMetering();\n        // To prevent turning gas monitoring back on with nested functions that use this modifier,\n        // we check if gasMetering started in the off position. If it did, we don't want to turn\n        // it back on until we exit the top level function that used the modifier\n        //\n        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.\n        // funcA will have `gasStartedOff` as false, funcB will have it as true,\n        // so we only turn metering back on at the end of the funcA\n        bool gasStartedOff = gasMeteringOff;\n        gasMeteringOff = true;\n\n        _;\n\n        // if gas metering was on when this modifier was called, turn it back on at the end\n        if (!gasStartedOff) {\n            gasMeteringOff = false;\n            vm.resumeGasMetering();\n        }\n    }\n\n    // a cheat for fuzzing addresses that are payable only\n    // see https://github.com/foundry-rs/foundry/issues/3631\n    function assumePayable(address addr) internal virtual {\n        (bool success,) = payable(addr).call{value: 0}(\"\");\n        vm.assume(success);\n    }\n}\n\n// Wrappers around cheatcodes to avoid footguns\nabstract contract StdCheats is StdCheatsSafe {\n    using stdStorage for StdStorage;\n\n    StdStorage private stdstore;\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) internal virtual {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) internal virtual {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender, origin);\n    }\n\n    function hoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender);\n    }\n\n    function startHoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function startHoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function changePrank(address msgSender) internal virtual {\n        vm.stopPrank();\n        vm.startPrank(msgSender);\n    }\n\n    function changePrank(address msgSender, address txOrigin) internal virtual {\n        vm.stopPrank();\n        vm.startPrank(msgSender, txOrigin);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) internal virtual {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) internal virtual {\n        deal(token, to, give, false);\n    }\n\n    // Set the balance of an account for any ERC1155 token\n    // Use the alternative signature to update `totalSupply`\n    function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {\n        dealERC1155(token, to, id, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);\n        }\n    }\n\n    function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x00fdd58e, to, id));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0xbd85b039, id));\n            require(\n                totSupData.length != 0,\n                \"StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply.\"\n            );\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);\n        }\n    }\n\n    function dealERC721(address token, address to, uint256 id) internal virtual {\n        // check if token id is already minted and the actual owner.\n        (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));\n        require(successMinted, \"StdCheats deal(address,address,uint,bool): id not minted.\");\n\n        // get owner current balance\n        (, bytes memory fromBalData) =\n            token.staticcall(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));\n        uint256 fromPrevBal = abi.decode(fromBalData, (uint256));\n\n        // get new user current balance\n        (, bytes memory toBalData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));\n        uint256 toPrevBal = abi.decode(toBalData, (uint256));\n\n        // update balances\n        stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);\n\n        // update owner\n        stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);\n    }\n}\n"},"hedge/lib/forge-std/src/StdError.sol":{"content":"// SPDX-License-Identifier: MIT\n// Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n}\n"},"hedge/lib/forge-std/src/StdInvariant.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\ncontract StdInvariant {\n    struct FuzzSelector {\n        address addr;\n        bytes4[] selectors;\n    }\n\n    address[] private _excludedContracts;\n    address[] private _excludedSenders;\n    address[] private _targetedContracts;\n    address[] private _targetedSenders;\n\n    string[] private _excludedArtifacts;\n    string[] private _targetedArtifacts;\n\n    FuzzSelector[] private _targetedArtifactSelectors;\n    FuzzSelector[] private _targetedSelectors;\n\n    // Functions for users:\n    // These are intended to be called in tests.\n\n    function excludeContract(address newExcludedContract_) internal {\n        _excludedContracts.push(newExcludedContract_);\n    }\n\n    function excludeSender(address newExcludedSender_) internal {\n        _excludedSenders.push(newExcludedSender_);\n    }\n\n    function excludeArtifact(string memory newExcludedArtifact_) internal {\n        _excludedArtifacts.push(newExcludedArtifact_);\n    }\n\n    function targetArtifact(string memory newTargetedArtifact_) internal {\n        _targetedArtifacts.push(newTargetedArtifact_);\n    }\n\n    function targetArtifactSelector(FuzzSelector memory newTargetedArtifactSelector_) internal {\n        _targetedArtifactSelectors.push(newTargetedArtifactSelector_);\n    }\n\n    function targetContract(address newTargetedContract_) internal {\n        _targetedContracts.push(newTargetedContract_);\n    }\n\n    function targetSelector(FuzzSelector memory newTargetedSelector_) internal {\n        _targetedSelectors.push(newTargetedSelector_);\n    }\n\n    function targetSender(address newTargetedSender_) internal {\n        _targetedSenders.push(newTargetedSender_);\n    }\n\n    // Functions for forge:\n    // These are called by forge to run invariant tests and don't need to be called in tests.\n\n    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {\n        excludedArtifacts_ = _excludedArtifacts;\n    }\n\n    function excludeContracts() public view returns (address[] memory excludedContracts_) {\n        excludedContracts_ = _excludedContracts;\n    }\n\n    function excludeSenders() public view returns (address[] memory excludedSenders_) {\n        excludedSenders_ = _excludedSenders;\n    }\n\n    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {\n        targetedArtifacts_ = _targetedArtifacts;\n    }\n\n    function targetArtifactSelectors() public view returns (FuzzSelector[] memory targetedArtifactSelectors_) {\n        targetedArtifactSelectors_ = _targetedArtifactSelectors;\n    }\n\n    function targetContracts() public view returns (address[] memory targetedContracts_) {\n        targetedContracts_ = _targetedContracts;\n    }\n\n    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {\n        targetedSelectors_ = _targetedSelectors;\n    }\n\n    function targetSenders() public view returns (address[] memory targetedSenders_) {\n        targetedSenders_ = _targetedSenders;\n    }\n}\n"},"hedge/lib/forge-std/src/StdJson.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n// Helpers for parsing and writing JSON files\n// To parse:\n// ```\n// using stdJson for string;\n// string memory json = vm.readFile(\"some_peth\");\n// json.parseUint(\"<json_path>\");\n// ```\n// To write:\n// ```\n// using stdJson for string;\n// string memory json = \"deploymentArtifact\";\n// Contract contract = new Contract();\n// json.serialize(\"contractAddress\", address(contract));\n// json = json.serialize(\"deploymentTimes\", uint(1));\n// // store the stringified JSON to the 'json' variable we have been using as a key\n// // as we won't need it any longer\n// string memory json2 = \"finalArtifact\";\n// string memory final = json2.serialize(\"depArtifact\", json);\n// final.write(\"<some_path>\");\n// ```\n\nlibrary stdJson {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {\n        return vm.parseJson(json, key);\n    }\n\n    function readUint(string memory json, string memory key) internal returns (uint256) {\n        return vm.parseJsonUint(json, key);\n    }\n\n    function readUintArray(string memory json, string memory key) internal returns (uint256[] memory) {\n        return vm.parseJsonUintArray(json, key);\n    }\n\n    function readInt(string memory json, string memory key) internal returns (int256) {\n        return vm.parseJsonInt(json, key);\n    }\n\n    function readIntArray(string memory json, string memory key) internal returns (int256[] memory) {\n        return vm.parseJsonIntArray(json, key);\n    }\n\n    function readBytes32(string memory json, string memory key) internal returns (bytes32) {\n        return vm.parseJsonBytes32(json, key);\n    }\n\n    function readBytes32Array(string memory json, string memory key) internal returns (bytes32[] memory) {\n        return vm.parseJsonBytes32Array(json, key);\n    }\n\n    function readString(string memory json, string memory key) internal returns (string memory) {\n        return vm.parseJsonString(json, key);\n    }\n\n    function readStringArray(string memory json, string memory key) internal returns (string[] memory) {\n        return vm.parseJsonStringArray(json, key);\n    }\n\n    function readAddress(string memory json, string memory key) internal returns (address) {\n        return vm.parseJsonAddress(json, key);\n    }\n\n    function readAddressArray(string memory json, string memory key) internal returns (address[] memory) {\n        return vm.parseJsonAddressArray(json, key);\n    }\n\n    function readBool(string memory json, string memory key) internal returns (bool) {\n        return vm.parseJsonBool(json, key);\n    }\n\n    function readBoolArray(string memory json, string memory key) internal returns (bool[] memory) {\n        return vm.parseJsonBoolArray(json, key);\n    }\n\n    function readBytes(string memory json, string memory key) internal returns (bytes memory) {\n        return vm.parseJsonBytes(json, key);\n    }\n\n    function readBytesArray(string memory json, string memory key) internal returns (bytes[] memory) {\n        return vm.parseJsonBytesArray(json, key);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function write(string memory jsonKey, string memory path) internal {\n        vm.writeJson(jsonKey, path);\n    }\n\n    function write(string memory jsonKey, string memory path, string memory valueKey) internal {\n        vm.writeJson(jsonKey, path, valueKey);\n    }\n}\n"},"hedge/lib/forge-std/src/StdMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN) {\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n        }\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n"},"hedge/lib/forge-std/src/StdStorage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nstruct StdStorage {\n    mapping(address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\n    mapping(address => mapping(bytes4 => mapping(bytes32 => bool))) finds;\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n}\n\nlibrary stdStorageSafe {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);\n    event WARNING_UninitedSlot(address who, uint256 slot);\n\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(StdStorage storage self) internal returns (uint256) {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n        }\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        vm.record();\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\n        }\n\n        (bytes32[] memory reads,) = vm.accesses(address(who));\n        if (reads.length == 1) {\n            bytes32 curr = vm.load(who, reads[0]);\n            if (curr == bytes32(0)) {\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\n            }\n            if (fdat != curr) {\n                require(\n                    false,\n                    \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\"\n                );\n            }\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n        } else if (reads.length > 1) {\n            for (uint256 i = 0; i < reads.length; i++) {\n                bytes32 prev = vm.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n                // store\n                vm.store(who, reads[i], bytes32(hex\"1337\"));\n                bool success;\n                bytes memory rdat;\n                {\n                    (success, rdat) = who.staticcall(cald);\n                    fdat = bytesToBytes32(rdat, 32 * field_depth);\n                }\n\n                if (success && fdat == bytes32(hex\"1337\")) {\n                    // we found which of the slots is the actual one\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n                    vm.store(who, reads[i], prev);\n                    break;\n                }\n                vm.store(who, reads[i], prev);\n            }\n        } else {\n            revert(\"stdStorage find(StdStorage): No storage use detected for target.\");\n        }\n\n        require(\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))],\n            \"stdStorage find(StdStorage): Slot(s) not found.\"\n        );\n\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        address t = self._target;\n        uint256 s = find(self);\n        return abi.encode(vm.load(t, bytes32(s)));\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n\nlibrary stdStorage {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return stdStorageSafe.sigs(sigStr);\n    }\n\n    function find(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.find(self);\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        return stdStorageSafe.target(self, _target);\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, who);\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, amt);\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, key);\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        return stdStorageSafe.depth(self, _depth);\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(StdStorage storage self, bytes32 set) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            find(self);\n        }\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\n\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\n        }\n        bytes32 curr = vm.load(who, slot);\n\n        if (fdat != curr) {\n            require(\n                false,\n                \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\"\n            );\n        }\n        vm.store(who, slot, set);\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return stdStorageSafe.read_bytes32(self);\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        return stdStorageSafe.read_bool(self);\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return stdStorageSafe.read_address(self);\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.read_uint(self);\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return stdStorageSafe.read_int(self);\n    }\n\n    // Private function so needs to be copied over\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    // Private function so needs to be copied over\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n"},"hedge/lib/forge-std/src/StdStyle.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nlibrary StdStyle {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    string constant RED = \"\\u001b[91m\";\n    string constant GREEN = \"\\u001b[92m\";\n    string constant YELLOW = \"\\u001b[93m\";\n    string constant BLUE = \"\\u001b[94m\";\n    string constant MAGENTA = \"\\u001b[95m\";\n    string constant CYAN = \"\\u001b[96m\";\n    string constant BOLD = \"\\u001b[1m\";\n    string constant DIM = \"\\u001b[2m\";\n    string constant ITALIC = \"\\u001b[3m\";\n    string constant UNDERLINE = \"\\u001b[4m\";\n    string constant INVERSE = \"\\u001b[7m\";\n    string constant RESET = \"\\u001b[0m\";\n\n    function styleConcat(string memory style, string memory self) private pure returns (string memory) {\n        return string(abi.encodePacked(style, self, RESET));\n    }\n\n    function red(string memory self) internal pure returns (string memory) {\n        return styleConcat(RED, self);\n    }\n\n    function red(uint256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(int256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(address self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(bool self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes(bytes memory self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes32(bytes32 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function green(string memory self) internal pure returns (string memory) {\n        return styleConcat(GREEN, self);\n    }\n\n    function green(uint256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(int256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(address self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(bool self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes(bytes memory self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes32(bytes32 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function yellow(string memory self) internal pure returns (string memory) {\n        return styleConcat(YELLOW, self);\n    }\n\n    function yellow(uint256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(int256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(address self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(bool self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes(bytes memory self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes32(bytes32 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function blue(string memory self) internal pure returns (string memory) {\n        return styleConcat(BLUE, self);\n    }\n\n    function blue(uint256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(int256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(address self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(bool self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes(bytes memory self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes32(bytes32 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function magenta(string memory self) internal pure returns (string memory) {\n        return styleConcat(MAGENTA, self);\n    }\n\n    function magenta(uint256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(int256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(address self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(bool self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes(bytes memory self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes32(bytes32 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function cyan(string memory self) internal pure returns (string memory) {\n        return styleConcat(CYAN, self);\n    }\n\n    function cyan(uint256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(int256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(address self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(bool self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes(bytes memory self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes32(bytes32 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function bold(string memory self) internal pure returns (string memory) {\n        return styleConcat(BOLD, self);\n    }\n\n    function bold(uint256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(int256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(address self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(bool self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes(bytes memory self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes32(bytes32 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function dim(string memory self) internal pure returns (string memory) {\n        return styleConcat(DIM, self);\n    }\n\n    function dim(uint256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(int256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(address self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(bool self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes(bytes memory self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes32(bytes32 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function italic(string memory self) internal pure returns (string memory) {\n        return styleConcat(ITALIC, self);\n    }\n\n    function italic(uint256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(int256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(address self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(bool self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes(bytes memory self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes32(bytes32 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function underline(string memory self) internal pure returns (string memory) {\n        return styleConcat(UNDERLINE, self);\n    }\n\n    function underline(uint256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(int256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(address self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(bool self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes(bytes memory self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes32(bytes32 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function inverse(string memory self) internal pure returns (string memory) {\n        return styleConcat(INVERSE, self);\n    }\n\n    function inverse(uint256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(int256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(address self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(bool self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes(bytes memory self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes32(bytes32 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n}\n"},"hedge/lib/forge-std/src/StdUtils.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {IMulticall3} from \"./interfaces/IMulticall3.sol\";\nimport {VmSafe} from \"./Vm.sol\";\n\nabstract contract StdUtils {\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTANTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n    uint256 private constant INT256_MIN_ABS =\n        57896044618658097711785492504343953926634992332820282019728792003956564819968;\n    uint256 private constant SECP256K1_ORDER =\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\n        require(min <= max, \"StdUtils bound(uint256,uint256,uint256): Max is less than min.\");\n        // If x is between min and max, return x directly. This is to ensure that dictionary values\n        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188\n        if (x >= min && x <= max) return x;\n\n        uint256 size = max - min + 1;\n\n        // If the value is 0, 1, 2, 3, wrap that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.\n        // This helps ensure coverage of the min/max values.\n        if (x <= 3 && size > x) return min + x;\n        if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);\n\n        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.\n        if (x > max) {\n            uint256 diff = x - max;\n            uint256 rem = diff % size;\n            if (rem == 0) return max;\n            result = min + rem - 1;\n        } else if (x < min) {\n            uint256 diff = min - x;\n            uint256 rem = diff % size;\n            if (rem == 0) return min;\n            result = max - rem + 1;\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal view virtual returns (uint256 result) {\n        result = _bound(x, min, max);\n        console2_log(\"Bound Result\", result);\n    }\n\n    function _bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {\n        require(min <= max, \"StdUtils bound(int256,int256,int256): Max is less than min.\");\n\n        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:\n        // int256 : -(2**255) ~ (2**255 - 1)\n        // uint256:     0     ~ (2**256 - 1)\n        // So, add 2**255, INT256_MIN_ABS to the integer values.\n        //\n        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.\n        // So, use `~uint256(x) + 1` instead.\n        uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);\n        uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);\n        uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);\n\n        uint256 y = _bound(_x, _min, _max);\n\n        // To move it back to int256 value, subtract INT256_MIN_ABS at here.\n        result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);\n    }\n\n    function bound(int256 x, int256 min, int256 max) internal view virtual returns (int256 result) {\n        result = _bound(x, min, max);\n        console2_log(\"Bound result\", vm.toString(result));\n    }\n\n    function boundPrivateKey(uint256 privateKey) internal view virtual returns (uint256 result) {\n        result = _bound(privateKey, 1, SECP256K1_ORDER - 1);\n    }\n\n    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {\n        require(b.length <= 32, \"StdUtils bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\n    /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {\n        // forgefmt: disable-start\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\n        // A one byte integer uses its own value as its length prefix, there is no additional \"0x80 + length\" prefix that comes before it.\n        if (nonce == 0x00)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));\n        if (nonce <= 0x7f)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));\n\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\n        if (nonce <= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));\n        if (nonce <= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));\n        if (nonce <= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));\n        // forgefmt: disable-end\n\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\n        return addressFromLast20Bytes(\n            keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce)))\n        );\n    }\n\n    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)\n        internal\n        pure\n        virtual\n        returns (address)\n    {\n        return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, initcodeHash)));\n    }\n\n    /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {\n        return computeCreate2Address(salt, initCodeHash, CREATE2_FACTORY);\n    }\n\n    /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {\n        return hashInitCode(creationCode, \"\");\n    }\n\n    /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    /// @param args the ABI-encoded arguments to the constructor of C\n    function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(creationCode, args));\n    }\n\n    // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.\n    function getTokenBalances(address token, address[] memory addresses)\n        internal\n        virtual\n        returns (uint256[] memory balances)\n    {\n        uint256 tokenCodeSize;\n        assembly {\n            tokenCodeSize := extcodesize(token)\n        }\n        require(tokenCodeSize > 0, \"StdUtils getTokenBalances(address,address[]): Token address is not a contract.\");\n\n        // ABI encode the aggregate call to Multicall3.\n        uint256 length = addresses.length;\n        IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            // 0x70a08231 = bytes4(\"balanceOf(address)\"))\n            calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});\n        }\n\n        // Make the aggregate call.\n        (, bytes[] memory returnData) = multicall.aggregate(calls);\n\n        // ABI decode the return data and return the balances.\n        balances = new uint256[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            balances[i] = abi.decode(returnData[i], (uint256));\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 PRIVATE FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.\n\n    function console2_log(string memory p0, uint256 p1) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n        status;\n    }\n\n    function console2_log(string memory p0, string memory p1) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n        status;\n    }\n}\n"},"hedge/lib/forge-std/src/Test.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\n// 💬 ABOUT\n// Standard Library's default Test\n\n// 🧩 MODULES\nimport {console} from \"./console.sol\";\nimport {console2} from \"./console2.sol\";\nimport {StdAssertions} from \"./StdAssertions.sol\";\nimport {StdChains} from \"./StdChains.sol\";\nimport {StdCheats} from \"./StdCheats.sol\";\nimport {stdError} from \"./StdError.sol\";\nimport {StdInvariant} from \"./StdInvariant.sol\";\nimport {stdJson} from \"./StdJson.sol\";\nimport {stdMath} from \"./StdMath.sol\";\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {StdUtils} from \"./StdUtils.sol\";\nimport {Vm} from \"./Vm.sol\";\nimport {StdStyle} from \"./StdStyle.sol\";\n\n// 📦 BOILERPLATE\nimport {TestBase} from \"./Base.sol\";\nimport {DSTest} from \"ds-test/test.sol\";\n\n// ⭐️ TEST\nabstract contract Test is DSTest, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils, TestBase {\n// Note: IS_TEST() must return true.\n// Note: Must have failure system, https://github.com/dapphub/ds-test/blob/cd98eff28324bfac652e63a239a60632a761790b/src/test.sol#L39-L76.\n}\n"},"hedge/lib/forge-std/src/Vm.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\n// Cheatcodes are marked as view/pure/none using the following rules:\n// 0. A call's observable behaviour includes its return value, logs, reverts and state writes,\n// 1. If you can influence a later call's observable behaviour, you're neither `view` nor `pure (you are modifying some state be it the EVM, interpreter, filesystem, etc),\n// 2. Otherwise if you can be influenced by an earlier call, or if reading some state, you're `view`,\n// 3. Otherwise you're `pure`.\n\ninterface VmSafe {\n    struct Log {\n        bytes32[] topics;\n        bytes data;\n        address emitter;\n    }\n\n    struct Rpc {\n        string key;\n        string url;\n    }\n\n    struct DirEntry {\n        string errorMessage;\n        string path;\n        uint64 depth;\n        bool isDir;\n        bool isSymlink;\n    }\n\n    struct FsMetadata {\n        bool isDir;\n        bool isSymlink;\n        uint256 length;\n        bool readOnly;\n        uint256 modified;\n        uint256 accessed;\n        uint256 created;\n    }\n\n    // Loads a storage slot from an address\n    function load(address target, bytes32 slot) external view returns (bytes32 data);\n    // Signs data\n    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n    // Gets the address for a given private key\n    function addr(uint256 privateKey) external pure returns (address keyAddr);\n    // Gets the nonce of an account\n    function getNonce(address account) external view returns (uint64 nonce);\n    // Performs a foreign function call via the terminal\n    function ffi(string[] calldata commandInput) external returns (bytes memory result);\n    // Sets environment variables\n    function setEnv(string calldata name, string calldata value) external;\n    // Reads environment variables, (name) => (value)\n    function envBool(string calldata name) external view returns (bool value);\n    function envUint(string calldata name) external view returns (uint256 value);\n    function envInt(string calldata name) external view returns (int256 value);\n    function envAddress(string calldata name) external view returns (address value);\n    function envBytes32(string calldata name) external view returns (bytes32 value);\n    function envString(string calldata name) external view returns (string memory value);\n    function envBytes(string calldata name) external view returns (bytes memory value);\n    // Reads environment variables as arrays\n    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);\n    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);\n    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);\n    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);\n    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);\n    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);\n    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);\n    // Read environment variables with default value\n    function envOr(string calldata name, bool defaultValue) external returns (bool value);\n    function envOr(string calldata name, uint256 defaultValue) external returns (uint256 value);\n    function envOr(string calldata name, int256 defaultValue) external returns (int256 value);\n    function envOr(string calldata name, address defaultValue) external returns (address value);\n    function envOr(string calldata name, bytes32 defaultValue) external returns (bytes32 value);\n    function envOr(string calldata name, string calldata defaultValue) external returns (string memory value);\n    function envOr(string calldata name, bytes calldata defaultValue) external returns (bytes memory value);\n    // Read environment variables as arrays with default value\n    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)\n        external\n        returns (bool[] memory value);\n    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)\n        external\n        returns (uint256[] memory value);\n    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)\n        external\n        returns (int256[] memory value);\n    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)\n        external\n        returns (address[] memory value);\n    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)\n        external\n        returns (bytes32[] memory value);\n    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)\n        external\n        returns (string[] memory value);\n    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)\n        external\n        returns (bytes[] memory value);\n    // Records all storage reads and writes\n    function record() external;\n    // Gets all accessed reads and write slot from a recording session, for a given address\n    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);\n    // Gets the _creation_ bytecode from an artifact file. Takes in the relative path to the json file\n    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);\n    // Gets the _deployed_ bytecode from an artifact file. Takes in the relative path to the json file\n    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);\n    // Labels an address in call traces\n    function label(address account, string calldata newLabel) external;\n    // Gets the label for the specified address\n    function getLabel(address account) external returns (string memory label);\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n    function broadcast() external;\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n    function broadcast(address signer) external;\n    // Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain\n    function broadcast(uint256 privateKey) external;\n    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast() external;\n    // Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain\n    function startBroadcast(address signer) external;\n    // Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain\n    function startBroadcast(uint256 privateKey) external;\n    // Stops collecting onchain transactions\n    function stopBroadcast() external;\n\n    // Get the path of the current project root.\n    function projectRoot() external view returns (string memory path);\n    // Reads the entire content of file to string. `path` is relative to the project root.\n    function readFile(string calldata path) external view returns (string memory data);\n    // Reads the entire content of file as binary. `path` is relative to the project root.\n    function readFileBinary(string calldata path) external view returns (bytes memory data);\n    // Reads next line of file to string.\n    function readLine(string calldata path) external view returns (string memory line);\n    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // `path` is relative to the project root.\n    function writeFile(string calldata path, string calldata data) external;\n    // Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // `path` is relative to the project root.\n    function writeFileBinary(string calldata path, bytes calldata data) external;\n    // Writes line to file, creating a file if it does not exist.\n    // `path` is relative to the project root.\n    function writeLine(string calldata path, string calldata data) external;\n    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    // `path` is relative to the project root.\n    function closeFile(string calldata path) external;\n    // Removes a file from the filesystem.\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - `path` points to a directory.\n    // - The file doesn't exist.\n    // - The user lacks permissions to remove the file.\n    // `path` is relative to the project root.\n    function removeFile(string calldata path) external;\n    // Creates a new, empty directory at the provided path.\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - User lacks permissions to modify `path`.\n    // - A parent of the given path doesn't exist and `recursive` is false.\n    // - `path` already exists and `recursive` is false.\n    // `path` is relative to the project root.\n    function createDir(string calldata path, bool recursive) external;\n    // Removes a directory at the provided path.\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - `path` doesn't exist.\n    // - `path` isn't a directory.\n    // - User lacks permissions to modify `path`.\n    // - The directory is not empty and `recursive` is false.\n    // `path` is relative to the project root.\n    function removeDir(string calldata path, bool recursive) external;\n    // Reads the directory at the given path recursively, up to `max_depth`.\n    // `max_depth` defaults to 1, meaning only the direct children of the given directory will be returned.\n    // Follows symbolic links if `follow_links` is true.\n    function readDir(string calldata path) external view returns (DirEntry[] memory entries);\n    function readDir(string calldata path, uint64 maxDepth) external view returns (DirEntry[] memory entries);\n    function readDir(string calldata path, uint64 maxDepth, bool followLinks)\n        external\n        view\n        returns (DirEntry[] memory entries);\n    // Reads a symbolic link, returning the path that the link points to.\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - `path` is not a symbolic link.\n    // - `path` does not exist.\n    function readLink(string calldata linkPath) external view returns (string memory targetPath);\n    // Given a path, query the file system to get information about a file, directory, etc.\n    function fsMetadata(string calldata path) external view returns (FsMetadata memory metadata);\n\n    // Convert values to a string\n    function toString(address value) external pure returns (string memory stringifiedValue);\n    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);\n    function toString(bytes32 value) external pure returns (string memory stringifiedValue);\n    function toString(bool value) external pure returns (string memory stringifiedValue);\n    function toString(uint256 value) external pure returns (string memory stringifiedValue);\n    function toString(int256 value) external pure returns (string memory stringifiedValue);\n    // Convert values from a string\n    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);\n    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);\n    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);\n    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);\n    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);\n    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);\n    // Record all the transaction logs\n    function recordLogs() external;\n    // Gets all the recorded logs\n    function getRecordedLogs() external returns (Log[] memory logs);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at {derivationPath}{index}\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)\n        external\n        pure\n        returns (uint256 privateKey);\n    // Adds a private key to the local forge wallet and returns the address\n    function rememberKey(uint256 privateKey) external returns (address keyAddr);\n    //\n    // parseJson\n    //\n    // ----\n    // In case the returned value is a JSON object, it's encoded as a ABI-encoded tuple. As JSON objects\n    // don't have the notion of ordered, but tuples do, they JSON object is encoded with it's fields ordered in\n    // ALPHABETICAL order. That means that in order to successfully decode the tuple, we need to define a tuple that\n    // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded\n    // as tuples, with the attributes in the order in which they are defined.\n    // For example: json = { 'a': 1, 'b': 0xa4tb......3xs}\n    // a: uint256\n    // b: address\n    // To decode that json, we need to define a struct or a tuple as follows:\n    // struct json = { uint256 a; address b; }\n    // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to\n    // decode the tuple in that order, and thus fail.\n    // ----\n    // Given a string of JSON, return it as ABI-encoded\n    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);\n    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);\n\n    // The following parseJson cheatcodes will do type coercion, for the type that they indicate.\n    // For example, parseJsonUint will coerce all values to a uint256. That includes stringified numbers '12'\n    // and hex numbers '0xEF'.\n    // Type coercion works ONLY for discrete values or arrays. That means that the key must return a value or array, not\n    // a JSON object.\n    function parseJsonUint(string calldata, string calldata) external returns (uint256);\n    function parseJsonUintArray(string calldata, string calldata) external returns (uint256[] memory);\n    function parseJsonInt(string calldata, string calldata) external returns (int256);\n    function parseJsonIntArray(string calldata, string calldata) external returns (int256[] memory);\n    function parseJsonBool(string calldata, string calldata) external returns (bool);\n    function parseJsonBoolArray(string calldata, string calldata) external returns (bool[] memory);\n    function parseJsonAddress(string calldata, string calldata) external returns (address);\n    function parseJsonAddressArray(string calldata, string calldata) external returns (address[] memory);\n    function parseJsonString(string calldata, string calldata) external returns (string memory);\n    function parseJsonStringArray(string calldata, string calldata) external returns (string[] memory);\n    function parseJsonBytes(string calldata, string calldata) external returns (bytes memory);\n    function parseJsonBytesArray(string calldata, string calldata) external returns (bytes[] memory);\n    function parseJsonBytes32(string calldata, string calldata) external returns (bytes32);\n    function parseJsonBytes32Array(string calldata, string calldata) external returns (bytes32[] memory);\n\n    // Serialize a key and value to a JSON object stored in-memory that can be later written to a file\n    // It returns the stringified version of the specific JSON file up to that moment.\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)\n        external\n        returns (string memory json);\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)\n        external\n        returns (string memory json);\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)\n        external\n        returns (string memory json);\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)\n        external\n        returns (string memory json);\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)\n        external\n        returns (string memory json);\n    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)\n        external\n        returns (string memory json);\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)\n        external\n        returns (string memory json);\n\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)\n        external\n        returns (string memory json);\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)\n        external\n        returns (string memory json);\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)\n        external\n        returns (string memory json);\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)\n        external\n        returns (string memory json);\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)\n        external\n        returns (string memory json);\n    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)\n        external\n        returns (string memory json);\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)\n        external\n        returns (string memory json);\n\n    //\n    // writeJson\n    //\n    // ----\n    // Write a serialized JSON object to a file. If the file exists, it will be overwritten.\n    // Let's assume we want to write the following JSON to a file:\n    //\n    // { \"boolean\": true, \"number\": 342, \"object\": { \"title\": \"finally json serialization\" } }\n    //\n    // ```\n    //  string memory json1 = \"some key\";\n    //  vm.serializeBool(json1, \"boolean\", true);\n    //  vm.serializeBool(json1, \"number\", uint256(342));\n    //  json2 = \"some other key\";\n    //  string memory output = vm.serializeString(json2, \"title\", \"finally json serialization\");\n    //  string memory finalJson = vm.serialize(json1, \"object\", output);\n    //  vm.writeJson(finalJson, \"./output/example.json\");\n    // ```\n    // The critical insight is that every invocation of serialization will return the stringified version of the JSON\n    // up to that point. That means we can construct arbitrary JSON objects and then use the return stringified version\n    // to serialize them as values to another JSON object.\n    //\n    // json1 and json2 are simply keys used by the backend to keep track of the objects. So vm.serializeJson(json1,..)\n    // will find the object in-memory that is keyed by \"some key\".\n    function writeJson(string calldata json, string calldata path) external;\n    // Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key>\n    // This is useful to replace a specific value of a JSON file, without having to parse the entire thing\n    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;\n    // Returns the RPC url for the given alias\n    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);\n    // Returns all rpc urls and their aliases `[alias, url][]`\n    function rpcUrls() external view returns (string[2][] memory urls);\n    // Returns all rpc urls and their aliases as structs.\n    function rpcUrlStructs() external view returns (Rpc[] memory urls);\n    // If the condition is false, discard this run's fuzz inputs and generate new ones.\n    function assume(bool condition) external pure;\n    // Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.\n    function pauseGasMetering() external;\n    // Resumes gas metering (i.e. gas usage is counted again). Noop if already on.\n    function resumeGasMetering() external;\n    // Writes a breakpoint to jump to in the debugger\n    function breakpoint(string calldata char) external;\n    // Writes a conditional breakpoint to jump to in the debugger\n    function breakpoint(string calldata char, bool value) external;\n}\n\ninterface Vm is VmSafe {\n    // Sets block.timestamp\n    function warp(uint256 newTimestamp) external;\n    // Sets block.height\n    function roll(uint256 newHeight) external;\n    // Sets block.basefee\n    function fee(uint256 newBasefee) external;\n    // Sets block.difficulty\n    // Not available on EVM versions from Paris onwards. Use `prevrandao` instead.\n    // If used on unsupported EVM versions it will revert.\n    function difficulty(uint256 newDifficulty) external;\n    // Sets block.prevrandao\n    // Not available on EVM versions before Paris. Use `difficulty` instead.\n    // If used on unsupported EVM versions it will revert.\n    function prevrandao(bytes32 newPrevrandao) external;\n    // Sets block.chainid\n    function chainId(uint256 newChainId) external;\n    // Sets tx.gasprice\n    function txGasPrice(uint256 newGasPrice) external;\n    // Stores a value to an address' storage slot.\n    function store(address target, bytes32 slot, bytes32 value) external;\n    // Sets the nonce of an account; must be higher than the current nonce of the account\n    function setNonce(address account, uint64 newNonce) external;\n    // Sets the nonce of an account to an arbitrary value\n    function setNonceUnsafe(address account, uint64 newNonce) external;\n    // Resets the nonce of an account to 0 for EOAs and 1 for contract accounts\n    function resetNonce(address account) external;\n    // Sets the *next* call's msg.sender to be the input address\n    function prank(address msgSender) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n    function startPrank(address msgSender) external;\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n    function prank(address msgSender, address txOrigin) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n    function startPrank(address msgSender, address txOrigin) external;\n    // Resets subsequent calls' msg.sender to be `address(this)`\n    function stopPrank() external;\n    // Sets an address' balance\n    function deal(address account, uint256 newBalance) external;\n    // Sets an address' code\n    function etch(address target, bytes calldata newRuntimeBytecode) external;\n    // Expects an error on next call\n    function expectRevert(bytes calldata revertData) external;\n    function expectRevert(bytes4 revertData) external;\n    function expectRevert() external;\n\n    // Prepare an expected log with all four checks enabled.\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data.\n    // Second form also checks supplied address against emitting contract.\n    function expectEmit() external;\n    function expectEmit(address emitter) external;\n\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n    // Second form also checks supplied address against emitting contract.\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)\n        external;\n\n    // Mocks a call to an address, returning specified data.\n    // Calldata can either be strict or a partial match, e.g. if you only\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\n    // function will be mocked.\n    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;\n    // Mocks a call to an address with a specific msg.value, returning specified data.\n    // Calldata match takes precedence over msg.value in case of ambiguity.\n    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;\n    // Reverts a call to an address with specified revert data.\n    function mockCallRevert(address callee, bytes calldata data, bytes calldata revertData) external;\n    // Reverts a call to an address with a specific msg.value, with specified revert data.\n    function mockCallRevert(address callee, uint256 msgValue, bytes calldata data, bytes calldata revertData)\n        external;\n    // Clears all mocked calls\n    function clearMockedCalls() external;\n    // Expects a call to an address with the specified calldata.\n    // Calldata can either be a strict or a partial match\n    function expectCall(address callee, bytes calldata data) external;\n    // Expects given number of calls to an address with the specified calldata.\n    function expectCall(address callee, bytes calldata data, uint64 count) external;\n    // Expects a call to an address with the specified msg.value and calldata\n    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;\n    // Expects given number of calls to an address with the specified msg.value and calldata\n    function expectCall(address callee, uint256 msgValue, bytes calldata data, uint64 count) external;\n    // Expect a call to an address with the specified msg.value, gas, and calldata.\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;\n    // Expects given number of calls to an address with the specified msg.value, gas, and calldata.\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data, uint64 count) external;\n    // Expect a call to an address with the specified msg.value and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;\n    // Expect given number of calls to an address with the specified msg.value and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data, uint64 count)\n        external;\n    // Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the current subcontext. If any other\n    // memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.\n    function expectSafeMemory(uint64 min, uint64 max) external;\n    // Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the next created subcontext.\n    // If any other memory is written to, the test will fail. Can be called multiple times to add more ranges\n    // to the set.\n    function expectSafeMemoryCall(uint64 min, uint64 max) external;\n    // Sets block.coinbase\n    function coinbase(address newCoinbase) external;\n    // Snapshot the current state of the evm.\n    // Returns the id of the snapshot that was created.\n    // To revert a snapshot use `revertTo`\n    function snapshot() external returns (uint256 snapshotId);\n    // Revert the state of the EVM to a previous snapshot\n    // Takes the snapshot id to revert to.\n    // This deletes the snapshot and all snapshots taken after the given snapshot id.\n    function revertTo(uint256 snapshotId) external returns (bool success);\n    // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);\n    // Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction,\n    // and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n    // Creates _and_ also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before\n    // the transaction, returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);\n    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n    function selectFork(uint256 forkId) external;\n    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.\n    function activeFork() external view returns (uint256 forkId);\n    // Updates the currently active fork to given block number\n    // This is similar to `roll` but for the currently active fork\n    function rollFork(uint256 blockNumber) external;\n    // Updates the currently active fork to given transaction\n    // this will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block\n    function rollFork(bytes32 txHash) external;\n    // Updates the given fork to given block number\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\n    // Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block\n    function rollFork(uint256 forkId, bytes32 txHash) external;\n    // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\n    // Meaning, changes made to the state of this account will be kept when switching forks\n    function makePersistent(address account) external;\n    function makePersistent(address account0, address account1) external;\n    function makePersistent(address account0, address account1, address account2) external;\n    function makePersistent(address[] calldata accounts) external;\n    // Revokes persistent status from the address, previously added via `makePersistent`\n    function revokePersistent(address account) external;\n    function revokePersistent(address[] calldata accounts) external;\n    // Returns true if the account is marked as persistent\n    function isPersistent(address account) external view returns (bool persistent);\n    // In forking mode, explicitly grant the given address cheatcode access\n    function allowCheatcodes(address account) external;\n    // Fetches the given transaction from the active fork and executes it on the current state\n    function transact(bytes32 txHash) external;\n    // Fetches the given transaction from the given fork and executes it on the current state\n    function transact(uint256 forkId, bytes32 txHash) external;\n}\n"},"hedge/lib/forge-std/src/console.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"},"hedge/lib/forge-std/src/console2.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n/// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should\n/// use `int256` and `uint256`. This modified version fixes that. This version is recommended\n/// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\n/// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\n/// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\nlibrary console2 {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _castLogPayloadViewToPure(\n        function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) internal pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);\n    }\n\n    function _sendLogPayloadView(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, int256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,int256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"},"hedge/lib/forge-std/src/interfaces/IERC1155.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\nimport \"./IERC165.sol\";\n\n/// @title ERC-1155 Multi Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-1155\n/// Note: The ERC-165 identifier for this interface is 0xd9b67a26.\ninterface IERC1155 is IERC165 {\n    /// @dev\n    /// - Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\n    /// - The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).\n    /// - The `_from` argument MUST be the address of the holder whose balance is decreased.\n    /// - The `_to` argument MUST be the address of the recipient whose balance is increased.\n    /// - The `_id` argument MUST be the token type being transferred.\n    /// - The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.\n    /// - When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\n    /// - When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\n    event TransferSingle(\n        address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value\n    );\n\n    /// @dev\n    /// - Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\n    /// - The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).\n    /// - The `_from` argument MUST be the address of the holder whose balance is decreased.\n    /// - The `_to` argument MUST be the address of the recipient whose balance is increased.\n    /// - The `_ids` argument MUST be the list of tokens being transferred.\n    /// - The `_values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids) the holder balance is decreased by and match what the recipient balance is increased by.\n    /// - When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\n    /// - When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\n    event TransferBatch(\n        address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values\n    );\n\n    /// @dev MUST emit when approval for a second party/operator address to manage all tokens for an owner address is enabled or disabled (absence of an event assumes disabled).\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /// @dev MUST emit when the URI is updated for a token ID. URIs are defined in RFC 3986.\n    /// The URI MUST point to a JSON file that conforms to the \"ERC-1155 Metadata URI JSON Schema\".\n    event URI(string _value, uint256 indexed _id);\n\n    /// @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).\n    /// @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\n    /// - MUST revert if `_to` is the zero address.\n    /// - MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\n    /// - MUST revert on any other error.\n    /// - MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard).\n    /// - After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _id ID of the token type\n    /// @param _value Transfer amount\n    /// @param _data Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external;\n\n    /// @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\n    /// @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\n    /// - MUST revert if `_to` is the zero address.\n    /// - MUST revert if length of `_ids` is not the same as length of `_values`.\n    /// - MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\n    /// - MUST revert on any other error.\n    /// - MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\n    /// - Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\n    /// - After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _ids IDs of each token type (order and length must match _values array)\n    /// @param _values Transfer amounts per token type (order and length must match _ids array)\n    /// @param _data Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`\n    function safeBatchTransferFrom(\n        address _from,\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes calldata _data\n    ) external;\n\n    /// @notice Get the balance of an account's tokens.\n    /// @param _owner The address of the token holder\n    /// @param _id ID of the token\n    /// @return The _owner's balance of the token type requested\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\n\n    /// @notice Get the balance of multiple account/token pairs\n    /// @param _owners The addresses of the token holders\n    /// @param _ids ID of the tokens\n    /// @return The _owner's balance of the token types requested (i.e. balance for each (owner, id) pair)\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\n    /// @dev MUST emit the ApprovalForAll event on success.\n    /// @param _operator Address to add to the set of authorized operators\n    /// @param _approved True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /// @notice Queries the approval status of an operator for a given owner.\n    /// @param _owner The owner of the tokens\n    /// @param _operator Address of authorized operator\n    /// @return True if the operator is approved, false if not\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n"},"hedge/lib/forge-std/src/interfaces/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    /// uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    /// `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"},"hedge/lib/forge-std/src/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\n/// @dev Interface of the ERC20 standard as defined in the EIP.\n/// @dev This includes the optional name, symbol, and decimals metadata.\ninterface IERC20 {\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\n    /// is the new allowance.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice Returns the amount of tokens in existence.\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Returns the amount of tokens owned by `account`.\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\n    /// to spend on behalf of `owner`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\n    /// `amount` is then deducted from the caller's allowance.\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the name of the token.\n    function name() external view returns (string memory);\n\n    /// @notice Returns the symbol of the token.\n    function symbol() external view returns (string memory);\n\n    /// @notice Returns the decimals places of the token.\n    function decimals() external view returns (uint8);\n}\n"},"hedge/lib/forge-std/src/interfaces/IERC4626.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\nimport \"./IERC20.sol\";\n\n/// @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n/// https://eips.ethereum.org/EIPS/eip-4626\ninterface IERC4626 is IERC20 {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\n    );\n\n    /// @notice Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n    /// @dev\n    /// - MUST be an ERC-20 token contract.\n    /// - MUST NOT revert.\n    function asset() external view returns (address assetTokenAddress);\n\n    /// @notice Returns the total amount of the underlying asset that is “managed” by Vault.\n    /// @dev\n    /// - SHOULD include any compounding that occurs from yield.\n    /// - MUST be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT revert.\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /// @notice Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n    /// scenario where all the conditions are met.\n    /// @dev\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT show any variations depending on the caller.\n    /// - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n    /// “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n    /// from.\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n    /// scenario where all the conditions are met.\n    /// @dev\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT show any variations depending on the caller.\n    /// - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n    /// “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n    /// from.\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /// @notice Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n    /// through a deposit call.\n    /// @dev\n    /// - MUST return a limited value if receiver is subject to some deposit limit.\n    /// - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n    /// - MUST NOT revert.\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n    /// current on-chain conditions.\n    /// @dev\n    /// - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n    ///   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n    ///   in the same transaction.\n    /// - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n    ///   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n    /// - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n    /// share price or some other type of condition, meaning the depositor will lose assets by depositing.\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n    /// @dev\n    /// - MUST emit the Deposit event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n    ///   deposit execution, and are accounted for during deposit.\n    /// - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n    ///   approving enough underlying tokens to the Vault contract, etc).\n    ///\n    /// NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /// @notice Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n    /// @dev\n    /// - MUST return a limited value if receiver is subject to some mint limit.\n    /// - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n    /// - MUST NOT revert.\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n    /// current on-chain conditions.\n    /// @dev\n    /// - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n    ///   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n    ///   same transaction.\n    /// - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n    ///   would be accepted, regardless if the user has enough tokens approved, etc.\n    /// - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n    /// share price or some other type of condition, meaning the depositor will lose assets by minting.\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /// @notice Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n    /// @dev\n    /// - MUST emit the Deposit event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n    ///   execution, and are accounted for during mint.\n    /// - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n    ///   approving enough underlying tokens to the Vault contract, etc).\n    ///\n    /// NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /// @notice Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n    /// Vault, through a withdraw call.\n    /// @dev\n    /// - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n    /// - MUST NOT revert.\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n    /// given current on-chain conditions.\n    /// @dev\n    /// - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n    ///   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n    ///   called\n    ///   in the same transaction.\n    /// - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n    ///   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n    /// - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n    /// share price or some other type of condition, meaning the depositor will lose assets by depositing.\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /// @notice Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n    /// @dev\n    /// - MUST emit the Withdraw event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n    ///   withdraw execution, and are accounted for during withdraw.\n    /// - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n    ///   not having enough shares, etc).\n    ///\n    /// Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n    /// Those methods should be performed separately.\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /// @notice Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n    /// through a redeem call.\n    /// @dev\n    /// - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n    /// - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n    /// - MUST NOT revert.\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n    /// given current on-chain conditions.\n    /// @dev\n    /// - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n    ///   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n    ///   same transaction.\n    /// - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n    ///   redemption would be accepted, regardless if the user has enough shares, etc.\n    /// - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n    /// - MUST NOT revert.\n    ///\n    /// NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n    /// share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /// @notice Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n    /// @dev\n    /// - MUST emit the Withdraw event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n    ///   redeem execution, and are accounted for during redeem.\n    /// - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n    ///   not having enough shares, etc).\n    ///\n    /// NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n    /// Those methods should be performed separately.\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"},"hedge/lib/forge-std/src/interfaces/IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\nimport \"./IERC165.sol\";\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n/// Note: the ERC-165 identifier for this interface is 0x80ac58cd.\ninterface IERC721 is IERC165 {\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n    /// This event emits when NFTs are created (`from` == 0) and destroyed\n    /// (`to` == 0). Exception: during contract creation, any number of NFTs\n    /// may be created and assigned without emitting Transfer. At the time of\n    /// any transfer, the approved address for that NFT (if any) is reset to none.\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n    /// @dev This emits when the approved address for an NFT is changed or\n    /// reaffirmed. The zero address indicates there is no approved address.\n    /// When a Transfer event emits, this also indicates that the approved\n    /// address for that NFT (if any) is reset to none.\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n    /// The operator can manage all NFTs of the owner.\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /// @notice Count all NFTs assigned to an owner\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n    /// function throws for queries about the zero address.\n    /// @param _owner An address for whom to query the balance\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Find the owner of an NFT\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n    /// about them do throw.\n    /// @param _tokenId The identifier for an NFT\n    /// @return The address of the owner of the NFT\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    /// operator, or the approved address for this NFT. Throws if `_from` is\n    /// not the current owner. Throws if `_to` is the zero address. Throws if\n    /// `_tokenId` is not a valid NFT. When transfer is complete, this function\n    /// checks if `_to` is a smart contract (code size > 0). If so, it calls\n    /// `onERC721Received` on `_to` and throws if the return value is not\n    /// `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    /// @param data Additional data with no specified format, sent in call to `_to`\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev This works identically to the other function with an extra data parameter,\n    /// except this function just sets data to \"\".\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n    /// TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n    /// THEY MAY BE PERMANENTLY LOST\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    /// operator, or the approved address for this NFT. Throws if `_from` is\n    /// not the current owner. Throws if `_to` is the zero address. Throws if\n    /// `_tokenId` is not a valid NFT.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    /// @notice Change or reaffirm the approved address for an NFT\n    /// @dev The zero address indicates there is no approved address.\n    /// Throws unless `msg.sender` is the current NFT owner, or an authorized\n    /// operator of the current owner.\n    /// @param _approved The new approved NFT controller\n    /// @param _tokenId The NFT to approve\n    function approve(address _approved, uint256 _tokenId) external payable;\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n    /// all of `msg.sender`'s assets\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n    /// multiple operators per owner.\n    /// @param _operator Address to add to the set of authorized operators\n    /// @param _approved True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /// @notice Get the approved address for a single NFT\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n    /// @param _tokenId The NFT to find the approved address for\n    /// @return The approved address for this NFT, or the zero address if there is none\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n    /// @notice Query if an address is an authorized operator for another address\n    /// @param _owner The address that owns the NFTs\n    /// @param _operator The address that acts on behalf of the owner\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface IERC721TokenReceiver {\n    /// @notice Handle the receipt of an NFT\n    /// @dev The ERC721 smart contract calls this function on the recipient\n    /// after a `transfer`. This function MAY throw to revert and reject the\n    /// transfer. Return of other than the magic value MUST result in the\n    /// transaction being reverted.\n    /// Note: the contract address is always the message sender.\n    /// @param _operator The address which called `safeTransferFrom` function\n    /// @param _from The address which previously owned the token\n    /// @param _tokenId The NFT identifier which is being transferred\n    /// @param _data Additional data with no specified format\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    ///  unless throwing\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data)\n        external\n        returns (bytes4);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n/// Note: the ERC-165 identifier for this interface is 0x5b5e139f.\ninterface IERC721Metadata is IERC721 {\n    /// @notice A descriptive name for a collection of NFTs in this contract\n    function name() external view returns (string memory _name);\n\n    /// @notice An abbreviated name for NFTs in this contract\n    function symbol() external view returns (string memory _symbol);\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n    /// 3986. The URI may point to a JSON file that conforms to the \"ERC721\n    /// Metadata JSON Schema\".\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n/// Note: the ERC-165 identifier for this interface is 0x780e9d63.\ninterface IERC721Enumerable is IERC721 {\n    /// @notice Count NFTs tracked by this contract\n    /// @return A count of valid NFTs tracked by this contract, where each one of\n    /// them has an assigned and queryable owner not equal to the zero address\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Enumerate valid NFTs\n    /// @dev Throws if `_index` >= `totalSupply()`.\n    /// @param _index A counter less than `totalSupply()`\n    /// @return The token identifier for the `_index`th NFT,\n    /// (sort order not specified)\n    function tokenByIndex(uint256 _index) external view returns (uint256);\n\n    /// @notice Enumerate NFTs assigned to an owner\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n    /// `_owner` is the zero address, representing invalid NFTs.\n    /// @param _owner An address where we are interested in NFTs owned by them\n    /// @param _index A counter less than `balanceOf(_owner)`\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n    /// (sort order not specified)\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n}\n"},"hedge/lib/forge-std/src/interfaces/IMulticall3.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\ninterface IMulticall3 {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    struct Call3 {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct Call3Value {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    function aggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes[] memory returnData);\n\n    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function blockAndAggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n\n    function getBasefee() external view returns (uint256 basefee);\n\n    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);\n\n    function getBlockNumber() external view returns (uint256 blockNumber);\n\n    function getChainId() external view returns (uint256 chainid);\n\n    function getCurrentBlockCoinbase() external view returns (address coinbase);\n\n    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);\n\n    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);\n\n    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);\n\n    function getEthBalance(address addr) external view returns (uint256 balance);\n\n    function getLastBlockHash() external view returns (bytes32 blockHash);\n\n    function tryAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (Result[] memory returnData);\n\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n}\n"},"hedge/lib/forge-std/src/safeconsole.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\n/// @author philogy <https://github.com/philogy>\n/// @dev Code generated automatically by script.\nlibrary safeconsole {\n    uint256 constant CONSOLE_ADDR = 0x000000000000000000000000000000000000000000636F6e736F6c652e6c6f67;\n\n    // Credit to [0age](https://twitter.com/z0age/status/1654922202930888704) and [0xdapper](https://github.com/foundry-rs/forge-std/pull/374)\n    // for the view-to-pure log trick.\n    function _sendLogPayload(uint256 offset, uint256 size) private pure {\n        function(uint256, uint256) internal view fnIn = _sendLogPayloadView;\n        function(uint256, uint256) internal pure pureSendLogPayload;\n        assembly {\n            pureSendLogPayload := fnIn\n        }\n        pureSendLogPayload(offset, size);\n    }\n\n    function _sendLogPayloadView(uint256 offset, uint256 size) private view {\n        assembly {\n            pop(staticcall(gas(), CONSOLE_ADDR, offset, size, 0x0, 0x0))\n        }\n    }\n\n    function _memcopy(uint256 fromOffset, uint256 toOffset, uint256 length) private pure {\n        function(uint256, uint256, uint256) internal view fnIn = _memcopyView;\n        function(uint256, uint256, uint256) internal pure pureMemcopy;\n        assembly {\n            pureMemcopy := fnIn\n        }\n        pureMemcopy(fromOffset, toOffset, length);\n    }\n\n    function _memcopyView(uint256 fromOffset, uint256 toOffset, uint256 length) private view {\n        assembly {\n            pop(staticcall(gas(), 0x4, fromOffset, length, toOffset, length))\n        }\n    }\n\n    function logMemory(uint256 offset, uint256 length) internal pure {\n        if (offset >= 0x60) {\n            // Sufficient memory before slice to prepare call header.\n            bytes32 m0;\n            bytes32 m1;\n            bytes32 m2;\n            assembly {\n                m0 := mload(sub(offset, 0x60))\n                m1 := mload(sub(offset, 0x40))\n                m2 := mload(sub(offset, 0x20))\n                // Selector of `logBytes(bytes)`.\n                mstore(sub(offset, 0x60), 0xe17bf956)\n                mstore(sub(offset, 0x40), 0x20)\n                mstore(sub(offset, 0x20), length)\n            }\n            _sendLogPayload(offset - 0x44, length + 0x44);\n            assembly {\n                mstore(sub(offset, 0x60), m0)\n                mstore(sub(offset, 0x40), m1)\n                mstore(sub(offset, 0x20), m2)\n            }\n        } else {\n            // Insufficient space, so copy slice forward, add header and reverse.\n            bytes32 m0;\n            bytes32 m1;\n            bytes32 m2;\n            uint256 endOffset = offset + length;\n            assembly {\n                m0 := mload(add(endOffset, 0x00))\n                m1 := mload(add(endOffset, 0x20))\n                m2 := mload(add(endOffset, 0x40))\n            }\n            _memcopy(offset, offset + 0x60, length);\n            assembly {\n                // Selector of `logBytes(bytes)`.\n                mstore(add(offset, 0x00), 0xe17bf956)\n                mstore(add(offset, 0x20), 0x20)\n                mstore(add(offset, 0x40), length)\n            }\n            _sendLogPayload(offset + 0x1c, length + 0x44);\n            _memcopy(offset + 0x60, offset, length);\n            assembly {\n                mstore(add(endOffset, 0x00), m0)\n                mstore(add(endOffset, 0x20), m1)\n                mstore(add(endOffset, 0x40), m2)\n            }\n        }\n    }\n\n    function log(address p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            // Selector of `log(address)`.\n            mstore(0x00, 0x2c2ecbc2)\n            mstore(0x20, p0)\n        }\n        _sendLogPayload(0x1c, 0x24);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n        }\n    }\n\n    function log(bool p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            // Selector of `log(bool)`.\n            mstore(0x00, 0x32458eed)\n            mstore(0x20, p0)\n        }\n        _sendLogPayload(0x1c, 0x24);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n        }\n    }\n\n    function log(uint256 p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            // Selector of `log(uint256)`.\n            mstore(0x00, 0xf82c50f1)\n            mstore(0x20, p0)\n        }\n        _sendLogPayload(0x1c, 0x24);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n        }\n    }\n\n    function log(bytes32 p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(string)`.\n            mstore(0x00, 0x41304fac)\n            mstore(0x20, 0x20)\n            writeString(0x40, p0)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(address,address)`.\n            mstore(0x00, 0xdaf0d4aa)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(address p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(address,bool)`.\n            mstore(0x00, 0x75b605d3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(address,uint256)`.\n            mstore(0x00, 0x8309e8a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(address p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,string)`.\n            mstore(0x00, 0x759f86bb)\n            mstore(0x20, p0)\n            mstore(0x40, 0x40)\n            writeString(0x60, p1)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(bool,address)`.\n            mstore(0x00, 0x853c4849)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(bool,bool)`.\n            mstore(0x00, 0x2a110e83)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(bool,uint256)`.\n            mstore(0x00, 0x399174d3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(bool p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,string)`.\n            mstore(0x00, 0x8feac525)\n            mstore(0x20, p0)\n            mstore(0x40, 0x40)\n            writeString(0x60, p1)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(uint256,address)`.\n            mstore(0x00, 0x69276c86)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(uint256,bool)`.\n            mstore(0x00, 0x1c9d7eb3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(uint256,uint256)`.\n            mstore(0x00, 0xf666715a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,string)`.\n            mstore(0x00, 0x643fd0df)\n            mstore(0x20, p0)\n            mstore(0x40, 0x40)\n            writeString(0x60, p1)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(string,address)`.\n            mstore(0x00, 0x319af333)\n            mstore(0x20, 0x40)\n            mstore(0x40, p1)\n            writeString(0x60, p0)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(string,bool)`.\n            mstore(0x00, 0xc3b55635)\n            mstore(0x20, 0x40)\n            mstore(0x40, p1)\n            writeString(0x60, p0)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(string,uint256)`.\n            mstore(0x00, 0xb60e72cc)\n            mstore(0x20, 0x40)\n            mstore(0x40, p1)\n            writeString(0x60, p0)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,string)`.\n            mstore(0x00, 0x4b5c4277)\n            mstore(0x20, 0x40)\n            mstore(0x40, 0x80)\n            writeString(0x60, p0)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,address,address)`.\n            mstore(0x00, 0x018c84c2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,address,bool)`.\n            mstore(0x00, 0xf2a66286)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,address,uint256)`.\n            mstore(0x00, 0x17fe6185)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,address,string)`.\n            mstore(0x00, 0x007150be)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,bool,address)`.\n            mstore(0x00, 0xf11699ed)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,bool,bool)`.\n            mstore(0x00, 0xeb830c92)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,bool,uint256)`.\n            mstore(0x00, 0x9c4f99fb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,bool,string)`.\n            mstore(0x00, 0x212255cc)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,uint256,address)`.\n            mstore(0x00, 0x7bc0d848)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,uint256,bool)`.\n            mstore(0x00, 0x678209a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,uint256,uint256)`.\n            mstore(0x00, 0xb69bcaf6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,uint256,string)`.\n            mstore(0x00, 0xa1f2e8aa)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,string,address)`.\n            mstore(0x00, 0xf08744e8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,string,bool)`.\n            mstore(0x00, 0xcf020fb1)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,string,uint256)`.\n            mstore(0x00, 0x67dd6ff1)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(address,string,string)`.\n            mstore(0x00, 0xfb772265)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p1)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,address,address)`.\n            mstore(0x00, 0xd2763667)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,address,bool)`.\n            mstore(0x00, 0x18c9c746)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,address,uint256)`.\n            mstore(0x00, 0x5f7b9afb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,address,string)`.\n            mstore(0x00, 0xde9a9270)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,bool,address)`.\n            mstore(0x00, 0x1078f68d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,bool,bool)`.\n            mstore(0x00, 0x50709698)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,bool,uint256)`.\n            mstore(0x00, 0x12f21602)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,bool,string)`.\n            mstore(0x00, 0x2555fa46)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,uint256,address)`.\n            mstore(0x00, 0x088ef9d2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,uint256,bool)`.\n            mstore(0x00, 0xe8defba9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,uint256,uint256)`.\n            mstore(0x00, 0x37103367)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,uint256,string)`.\n            mstore(0x00, 0xc3fc3970)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,string,address)`.\n            mstore(0x00, 0x9591b953)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,string,bool)`.\n            mstore(0x00, 0xdbb4c247)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,string,uint256)`.\n            mstore(0x00, 0x1093ee11)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(bool,string,string)`.\n            mstore(0x00, 0xb076847f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p1)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,address,address)`.\n            mstore(0x00, 0xbcfd9be0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,address,bool)`.\n            mstore(0x00, 0x9b6ec042)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,address,uint256)`.\n            mstore(0x00, 0x5a9b5ed5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,address,string)`.\n            mstore(0x00, 0x63cb41f9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,bool,address)`.\n            mstore(0x00, 0x35085f7b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,bool,bool)`.\n            mstore(0x00, 0x20718650)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,bool,uint256)`.\n            mstore(0x00, 0x20098014)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,bool,string)`.\n            mstore(0x00, 0x85775021)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,uint256,address)`.\n            mstore(0x00, 0x5c96b331)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,uint256,bool)`.\n            mstore(0x00, 0x4766da72)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,uint256,uint256)`.\n            mstore(0x00, 0xd1ed7a3c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,uint256,string)`.\n            mstore(0x00, 0x71d04af2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,string,address)`.\n            mstore(0x00, 0x7afac959)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,string,bool)`.\n            mstore(0x00, 0x4ceda75a)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,string,uint256)`.\n            mstore(0x00, 0x37aa7d4c)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(uint256,string,string)`.\n            mstore(0x00, 0xb115611f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p1)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,address,address)`.\n            mstore(0x00, 0xfcec75e0)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,address,bool)`.\n            mstore(0x00, 0xc91d5ed4)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,address,uint256)`.\n            mstore(0x00, 0x0d26b925)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,address,string)`.\n            mstore(0x00, 0xe0e9ad4f)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p0)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,bool,address)`.\n            mstore(0x00, 0x932bbb38)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,bool,bool)`.\n            mstore(0x00, 0x850b7ad6)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,bool,uint256)`.\n            mstore(0x00, 0xc95958d6)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,bool,string)`.\n            mstore(0x00, 0xe298f47d)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p0)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,uint256,address)`.\n            mstore(0x00, 0x1c7ec448)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,uint256,bool)`.\n            mstore(0x00, 0xca7733b1)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,uint256,uint256)`.\n            mstore(0x00, 0xca47c4eb)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,uint256,string)`.\n            mstore(0x00, 0x5970e089)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p0)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,string,address)`.\n            mstore(0x00, 0x95ed0195)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,string,bool)`.\n            mstore(0x00, 0xb0e0f9b5)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,string,uint256)`.\n            mstore(0x00, 0x5821efa1)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            // Selector of `log(string,string,string)`.\n            mstore(0x00, 0x2ced7cef)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, 0xe0)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n            writeString(0x100, p2)\n        }\n        _sendLogPayload(0x1c, 0x124);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n        }\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,address,address)`.\n            mstore(0x00, 0x665bf134)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,address,bool)`.\n            mstore(0x00, 0x0e378994)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,address,uint256)`.\n            mstore(0x00, 0x94250d77)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,address,string)`.\n            mstore(0x00, 0xf808da20)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,bool,address)`.\n            mstore(0x00, 0x9f1bc36e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,bool,bool)`.\n            mstore(0x00, 0x2cd4134a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,bool,uint256)`.\n            mstore(0x00, 0x3971e78c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,bool,string)`.\n            mstore(0x00, 0xaa6540c8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,uint256,address)`.\n            mstore(0x00, 0x8da6def5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,uint256,bool)`.\n            mstore(0x00, 0x9b4254e2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,uint256,uint256)`.\n            mstore(0x00, 0xbe553481)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,uint256,string)`.\n            mstore(0x00, 0xfdb4f990)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,string,address)`.\n            mstore(0x00, 0x8f736d16)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,string,bool)`.\n            mstore(0x00, 0x6f1a594e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,string,uint256)`.\n            mstore(0x00, 0xef1cefe7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,address,string,string)`.\n            mstore(0x00, 0x21bdaf25)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,address,address)`.\n            mstore(0x00, 0x660375dd)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,address,bool)`.\n            mstore(0x00, 0xa6f50b0f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,address,uint256)`.\n            mstore(0x00, 0xa75c59de)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,address,string)`.\n            mstore(0x00, 0x2dd778e6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,bool,address)`.\n            mstore(0x00, 0xcf394485)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,bool,bool)`.\n            mstore(0x00, 0xcac43479)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,bool,uint256)`.\n            mstore(0x00, 0x8c4e5de6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,bool,string)`.\n            mstore(0x00, 0xdfc4a2e8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,uint256,address)`.\n            mstore(0x00, 0xccf790a1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,uint256,bool)`.\n            mstore(0x00, 0xc4643e20)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,uint256,uint256)`.\n            mstore(0x00, 0x386ff5f4)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,uint256,string)`.\n            mstore(0x00, 0x0aa6cfad)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,string,address)`.\n            mstore(0x00, 0x19fd4956)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,string,bool)`.\n            mstore(0x00, 0x50ad461d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,string,uint256)`.\n            mstore(0x00, 0x80e6a20b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,bool,string,string)`.\n            mstore(0x00, 0x475c5c33)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,address,address)`.\n            mstore(0x00, 0x478d1c62)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,address,bool)`.\n            mstore(0x00, 0xa1bcc9b3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,address,uint256)`.\n            mstore(0x00, 0x100f650e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,address,string)`.\n            mstore(0x00, 0x1da986ea)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,bool,address)`.\n            mstore(0x00, 0xa31bfdcc)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,bool,bool)`.\n            mstore(0x00, 0x3bf5e537)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,bool,uint256)`.\n            mstore(0x00, 0x22f6b999)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,bool,string)`.\n            mstore(0x00, 0xc5ad85f9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,uint256,address)`.\n            mstore(0x00, 0x20e3984d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,uint256,bool)`.\n            mstore(0x00, 0x66f1bc67)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,uint256,uint256)`.\n            mstore(0x00, 0x34f0e636)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,uint256,string)`.\n            mstore(0x00, 0x4a28c017)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,string,address)`.\n            mstore(0x00, 0x5c430d47)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,string,bool)`.\n            mstore(0x00, 0xcf18105c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,string,uint256)`.\n            mstore(0x00, 0xbf01f891)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,uint256,string,string)`.\n            mstore(0x00, 0x88a8c406)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,address,address)`.\n            mstore(0x00, 0x0d36fa20)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,address,bool)`.\n            mstore(0x00, 0x0df12b76)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,address,uint256)`.\n            mstore(0x00, 0x457fe3cf)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,address,string)`.\n            mstore(0x00, 0xf7e36245)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,bool,address)`.\n            mstore(0x00, 0x205871c2)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,bool,bool)`.\n            mstore(0x00, 0x5f1d5c9f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,bool,uint256)`.\n            mstore(0x00, 0x515e38b6)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,bool,string)`.\n            mstore(0x00, 0xbc0b61fe)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,uint256,address)`.\n            mstore(0x00, 0x63183678)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,uint256,bool)`.\n            mstore(0x00, 0x0ef7e050)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,uint256,uint256)`.\n            mstore(0x00, 0x1dc8e1b8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,uint256,string)`.\n            mstore(0x00, 0x448830a8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,string,address)`.\n            mstore(0x00, 0xa04e2f87)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,string,bool)`.\n            mstore(0x00, 0x35a5071f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,string,uint256)`.\n            mstore(0x00, 0x159f8927)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(address,string,string,string)`.\n            mstore(0x00, 0x5d02c50b)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,address,address)`.\n            mstore(0x00, 0x1d14d001)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,address,bool)`.\n            mstore(0x00, 0x46600be0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,address,uint256)`.\n            mstore(0x00, 0x0c66d1be)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,address,string)`.\n            mstore(0x00, 0xd812a167)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,bool,address)`.\n            mstore(0x00, 0x1c41a336)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,bool,bool)`.\n            mstore(0x00, 0x6a9c478b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,bool,uint256)`.\n            mstore(0x00, 0x07831502)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,bool,string)`.\n            mstore(0x00, 0x4a66cb34)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,uint256,address)`.\n            mstore(0x00, 0x136b05dd)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,uint256,bool)`.\n            mstore(0x00, 0xd6019f1c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,uint256,uint256)`.\n            mstore(0x00, 0x7bf181a1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,uint256,string)`.\n            mstore(0x00, 0x51f09ff8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,string,address)`.\n            mstore(0x00, 0x6f7c603e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,string,bool)`.\n            mstore(0x00, 0xe2bfd60b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,string,uint256)`.\n            mstore(0x00, 0xc21f64c7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,address,string,string)`.\n            mstore(0x00, 0xa73c1db6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,address,address)`.\n            mstore(0x00, 0xf4880ea4)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,address,bool)`.\n            mstore(0x00, 0xc0a302d8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,address,uint256)`.\n            mstore(0x00, 0x4c123d57)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,address,string)`.\n            mstore(0x00, 0xa0a47963)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,bool,address)`.\n            mstore(0x00, 0x8c329b1a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,bool,bool)`.\n            mstore(0x00, 0x3b2a5ce0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,bool,uint256)`.\n            mstore(0x00, 0x6d7045c1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,bool,string)`.\n            mstore(0x00, 0x2ae408d4)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,uint256,address)`.\n            mstore(0x00, 0x54a7a9a0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,uint256,bool)`.\n            mstore(0x00, 0x619e4d0e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,uint256,uint256)`.\n            mstore(0x00, 0x0bb00eab)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,uint256,string)`.\n            mstore(0x00, 0x7dd4d0e0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,string,address)`.\n            mstore(0x00, 0xf9ad2b89)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,string,bool)`.\n            mstore(0x00, 0xb857163a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,string,uint256)`.\n            mstore(0x00, 0xe3a9ca2f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,bool,string,string)`.\n            mstore(0x00, 0x6d1e8751)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,address,address)`.\n            mstore(0x00, 0x26f560a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,address,bool)`.\n            mstore(0x00, 0xb4c314ff)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,address,uint256)`.\n            mstore(0x00, 0x1537dc87)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,address,string)`.\n            mstore(0x00, 0x1bb3b09a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,bool,address)`.\n            mstore(0x00, 0x9acd3616)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,bool,bool)`.\n            mstore(0x00, 0xceb5f4d7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,bool,uint256)`.\n            mstore(0x00, 0x7f9bbca2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,bool,string)`.\n            mstore(0x00, 0x9143dbb1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,uint256,address)`.\n            mstore(0x00, 0x00dd87b9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,uint256,bool)`.\n            mstore(0x00, 0xbe984353)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,uint256,uint256)`.\n            mstore(0x00, 0x374bb4b2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,uint256,string)`.\n            mstore(0x00, 0x8e69fb5d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,string,address)`.\n            mstore(0x00, 0xfedd1fff)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,string,bool)`.\n            mstore(0x00, 0xe5e70b2b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,string,uint256)`.\n            mstore(0x00, 0x6a1199e2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,uint256,string,string)`.\n            mstore(0x00, 0xf5bc2249)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,address,address)`.\n            mstore(0x00, 0x2b2b18dc)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,address,bool)`.\n            mstore(0x00, 0x6dd434ca)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,address,uint256)`.\n            mstore(0x00, 0xa5cada94)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,address,string)`.\n            mstore(0x00, 0x12d6c788)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,bool,address)`.\n            mstore(0x00, 0x538e06ab)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,bool,bool)`.\n            mstore(0x00, 0xdc5e935b)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,bool,uint256)`.\n            mstore(0x00, 0x1606a393)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,bool,string)`.\n            mstore(0x00, 0x483d0416)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,uint256,address)`.\n            mstore(0x00, 0x1596a1ce)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,uint256,bool)`.\n            mstore(0x00, 0x6b0e5d53)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,uint256,uint256)`.\n            mstore(0x00, 0x28863fcb)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,uint256,string)`.\n            mstore(0x00, 0x1ad96de6)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,string,address)`.\n            mstore(0x00, 0x97d394d8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,string,bool)`.\n            mstore(0x00, 0x1e4b87e5)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,string,uint256)`.\n            mstore(0x00, 0x7be0c3eb)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(bool,string,string,string)`.\n            mstore(0x00, 0x1762e32a)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,address,address)`.\n            mstore(0x00, 0x2488b414)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,address,bool)`.\n            mstore(0x00, 0x091ffaf5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,address,uint256)`.\n            mstore(0x00, 0x736efbb6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,address,string)`.\n            mstore(0x00, 0x031c6f73)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,bool,address)`.\n            mstore(0x00, 0xef72c513)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,bool,bool)`.\n            mstore(0x00, 0xe351140f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,bool,uint256)`.\n            mstore(0x00, 0x5abd992a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,bool,string)`.\n            mstore(0x00, 0x90fb06aa)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,uint256,address)`.\n            mstore(0x00, 0x15c127b5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,uint256,bool)`.\n            mstore(0x00, 0x5f743a7c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,uint256,uint256)`.\n            mstore(0x00, 0x0c9cd9c1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,uint256,string)`.\n            mstore(0x00, 0xddb06521)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,string,address)`.\n            mstore(0x00, 0x9cba8fff)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,string,bool)`.\n            mstore(0x00, 0xcc32ab07)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,string,uint256)`.\n            mstore(0x00, 0x46826b5d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,address,string,string)`.\n            mstore(0x00, 0x3e128ca3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,address,address)`.\n            mstore(0x00, 0xa1ef4cbb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,address,bool)`.\n            mstore(0x00, 0x454d54a5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,address,uint256)`.\n            mstore(0x00, 0x078287f5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,address,string)`.\n            mstore(0x00, 0xade052c7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,bool,address)`.\n            mstore(0x00, 0x69640b59)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,bool,bool)`.\n            mstore(0x00, 0xb6f577a1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,bool,uint256)`.\n            mstore(0x00, 0x7464ce23)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,bool,string)`.\n            mstore(0x00, 0xdddb9561)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,uint256,address)`.\n            mstore(0x00, 0x88cb6041)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,uint256,bool)`.\n            mstore(0x00, 0x91a02e2a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,uint256,uint256)`.\n            mstore(0x00, 0xc6acc7a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,uint256,string)`.\n            mstore(0x00, 0xde03e774)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,string,address)`.\n            mstore(0x00, 0xef529018)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,string,bool)`.\n            mstore(0x00, 0xeb928d7f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,string,uint256)`.\n            mstore(0x00, 0x2c1d0746)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,bool,string,string)`.\n            mstore(0x00, 0x68c8b8bd)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,address,address)`.\n            mstore(0x00, 0x56a5d1b1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,address,bool)`.\n            mstore(0x00, 0x15cac476)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,address,uint256)`.\n            mstore(0x00, 0x88f6e4b2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,address,string)`.\n            mstore(0x00, 0x6cde40b8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,bool,address)`.\n            mstore(0x00, 0x9a816a83)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,bool,bool)`.\n            mstore(0x00, 0xab085ae6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,bool,uint256)`.\n            mstore(0x00, 0xeb7f6fd2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,bool,string)`.\n            mstore(0x00, 0xa5b4fc99)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,uint256,address)`.\n            mstore(0x00, 0xfa8185af)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,uint256,bool)`.\n            mstore(0x00, 0xc598d185)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,uint256,uint256)`.\n            mstore(0x00, 0x193fb800)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,uint256,string)`.\n            mstore(0x00, 0x59cfcbe3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,string,address)`.\n            mstore(0x00, 0x42d21db7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,string,bool)`.\n            mstore(0x00, 0x7af6ab25)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,string,uint256)`.\n            mstore(0x00, 0x5da297eb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,uint256,string,string)`.\n            mstore(0x00, 0x27d8afd2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,address,address)`.\n            mstore(0x00, 0x6168ed61)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,address,bool)`.\n            mstore(0x00, 0x90c30a56)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,address,uint256)`.\n            mstore(0x00, 0xe8d3018d)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,address,string)`.\n            mstore(0x00, 0x9c3adfa1)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,bool,address)`.\n            mstore(0x00, 0xae2ec581)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,bool,bool)`.\n            mstore(0x00, 0xba535d9c)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,bool,uint256)`.\n            mstore(0x00, 0xcf009880)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,bool,string)`.\n            mstore(0x00, 0xd2d423cd)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,uint256,address)`.\n            mstore(0x00, 0x3b2279b4)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,uint256,bool)`.\n            mstore(0x00, 0x691a8f74)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,uint256,uint256)`.\n            mstore(0x00, 0x82c25b74)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,uint256,string)`.\n            mstore(0x00, 0xb7b914ca)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,string,address)`.\n            mstore(0x00, 0xd583c602)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,string,bool)`.\n            mstore(0x00, 0xb3a6b6bd)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,string,uint256)`.\n            mstore(0x00, 0xb028c9bd)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(uint256,string,string,string)`.\n            mstore(0x00, 0x21ad0683)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,address,address)`.\n            mstore(0x00, 0xed8f28f6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,address,bool)`.\n            mstore(0x00, 0xb59dbd60)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,address,uint256)`.\n            mstore(0x00, 0x8ef3f399)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,address,string)`.\n            mstore(0x00, 0x800a1c67)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,bool,address)`.\n            mstore(0x00, 0x223603bd)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,bool,bool)`.\n            mstore(0x00, 0x79884c2b)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,bool,uint256)`.\n            mstore(0x00, 0x3e9f866a)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,bool,string)`.\n            mstore(0x00, 0x0454c079)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,uint256,address)`.\n            mstore(0x00, 0x63fb8bc5)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,uint256,bool)`.\n            mstore(0x00, 0xfc4845f0)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,uint256,uint256)`.\n            mstore(0x00, 0xf8f51b1e)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,uint256,string)`.\n            mstore(0x00, 0x5a477632)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,string,address)`.\n            mstore(0x00, 0xaabc9a31)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,string,bool)`.\n            mstore(0x00, 0x5f15d28c)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,string,uint256)`.\n            mstore(0x00, 0x91d1112e)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,address,string,string)`.\n            mstore(0x00, 0x245986f2)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,address,address)`.\n            mstore(0x00, 0x33e9dd1d)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,address,bool)`.\n            mstore(0x00, 0x958c28c6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,address,uint256)`.\n            mstore(0x00, 0x5d08bb05)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,address,string)`.\n            mstore(0x00, 0x2d8e33a4)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,bool,address)`.\n            mstore(0x00, 0x7190a529)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,bool,bool)`.\n            mstore(0x00, 0x895af8c5)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,bool,uint256)`.\n            mstore(0x00, 0x8e3f78a9)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,bool,string)`.\n            mstore(0x00, 0x9d22d5dd)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,uint256,address)`.\n            mstore(0x00, 0x935e09bf)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,uint256,bool)`.\n            mstore(0x00, 0x8af7cf8a)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,uint256,uint256)`.\n            mstore(0x00, 0x64b5bb67)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,uint256,string)`.\n            mstore(0x00, 0x742d6ee7)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,string,address)`.\n            mstore(0x00, 0xe0625b29)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,string,bool)`.\n            mstore(0x00, 0x3f8a701d)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,string,uint256)`.\n            mstore(0x00, 0x24f91465)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,bool,string,string)`.\n            mstore(0x00, 0xa826caeb)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,address,address)`.\n            mstore(0x00, 0x5ea2b7ae)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,address,bool)`.\n            mstore(0x00, 0x82112a42)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,address,uint256)`.\n            mstore(0x00, 0x4f04fdc6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,address,string)`.\n            mstore(0x00, 0x9ffb2f93)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,bool,address)`.\n            mstore(0x00, 0xe0e95b98)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,bool,bool)`.\n            mstore(0x00, 0x354c36d6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,bool,uint256)`.\n            mstore(0x00, 0xe41b6f6f)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,bool,string)`.\n            mstore(0x00, 0xabf73a98)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,uint256,address)`.\n            mstore(0x00, 0xe21de278)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,uint256,bool)`.\n            mstore(0x00, 0x7626db92)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,uint256,uint256)`.\n            mstore(0x00, 0xa7a87853)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,uint256,string)`.\n            mstore(0x00, 0x854b3496)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,string,address)`.\n            mstore(0x00, 0x7c4632a4)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,string,bool)`.\n            mstore(0x00, 0x7d24491d)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,string,uint256)`.\n            mstore(0x00, 0xc67ea9d1)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,uint256,string,string)`.\n            mstore(0x00, 0x5ab84e1f)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,address,address)`.\n            mstore(0x00, 0x439c7bef)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,address,bool)`.\n            mstore(0x00, 0x5ccd4e37)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,address,uint256)`.\n            mstore(0x00, 0x7cc3c607)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,address,string)`.\n            mstore(0x00, 0xeb1bff80)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,bool,address)`.\n            mstore(0x00, 0xc371c7db)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,bool,bool)`.\n            mstore(0x00, 0x40785869)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,bool,uint256)`.\n            mstore(0x00, 0xd6aefad2)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,bool,string)`.\n            mstore(0x00, 0x5e84b0ea)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,uint256,address)`.\n            mstore(0x00, 0x1023f7b2)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,uint256,bool)`.\n            mstore(0x00, 0xc3a8a654)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,uint256,uint256)`.\n            mstore(0x00, 0xf45d7d2c)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,uint256,string)`.\n            mstore(0x00, 0x5d1a971a)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,string,address)`.\n            mstore(0x00, 0x6d572f44)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,string,bool)`.\n            mstore(0x00, 0x2c1754ed)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,string,uint256)`.\n            mstore(0x00, 0x8eafb02b)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        bytes32 m11;\n        bytes32 m12;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            m11 := mload(0x160)\n            m12 := mload(0x180)\n            // Selector of `log(string,string,string,string)`.\n            mstore(0x00, 0xde68f20a)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, 0x140)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n            writeString(0x160, p3)\n        }\n        _sendLogPayload(0x1c, 0x184);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n            mstore(0x160, m11)\n            mstore(0x180, m12)\n        }\n    }\n}\n"},"hedge/lib/forge-std/test/StdAssertions.t.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../src/Test.sol\";\n\ncontract StdAssertionsTest is Test {\n    string constant CUSTOM_ERROR = \"guh!\";\n\n    bool constant EXPECT_PASS = false;\n    bool constant EXPECT_FAIL = true;\n\n    bool constant SHOULD_REVERT = true;\n    bool constant SHOULD_RETURN = false;\n\n    bool constant STRICT_REVERT_DATA = true;\n    bool constant NON_STRICT_REVERT_DATA = false;\n\n    TestTest t = new TestTest();\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    FAIL(STRING)\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testShouldFail() external {\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        t._fail(CUSTOM_ERROR);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    ASSERT_FALSE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testAssertFalse_Pass() external {\n        t._assertFalse(false, EXPECT_PASS);\n    }\n\n    function testAssertFalse_Fail() external {\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: Assertion Failed\");\n        t._assertFalse(true, EXPECT_FAIL);\n    }\n\n    function testAssertFalse_Err_Pass() external {\n        t._assertFalse(false, CUSTOM_ERROR, EXPECT_PASS);\n    }\n\n    function testAssertFalse_Err_Fail() external {\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        t._assertFalse(true, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    ASSERT_EQ(BOOL)\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testAssertEq_Bool_Pass(bool a) external {\n        t._assertEq(a, a, EXPECT_PASS);\n    }\n\n    function testAssertEq_Bool_Fail(bool a, bool b) external {\n        vm.assume(a != b);\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [bool]\");\n        t._assertEq(a, b, EXPECT_FAIL);\n    }\n\n    function testAssertEq_BoolErr_Pass(bool a) external {\n        t._assertEq(a, a, CUSTOM_ERROR, EXPECT_PASS);\n    }\n\n    function testAssertEq_BoolErr_Fail(bool a, bool b) external {\n        vm.assume(a != b);\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        t._assertEq(a, b, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    ASSERT_EQ(BYTES)\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testAssertEq_Bytes_Pass(bytes calldata a) external {\n        t._assertEq(a, a, EXPECT_PASS);\n    }\n\n    function testAssertEq_Bytes_Fail(bytes calldata a, bytes calldata b) external {\n        vm.assume(keccak256(a) != keccak256(b));\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [bytes]\");\n        t._assertEq(a, b, EXPECT_FAIL);\n    }\n\n    function testAssertEq_BytesErr_Pass(bytes calldata a) external {\n        t._assertEq(a, a, CUSTOM_ERROR, EXPECT_PASS);\n    }\n\n    function testAssertEq_BytesErr_Fail(bytes calldata a, bytes calldata b) external {\n        vm.assume(keccak256(a) != keccak256(b));\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        t._assertEq(a, b, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    ASSERT_EQ(ARRAY)\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testAssertEq_UintArr_Pass(uint256 e0, uint256 e1, uint256 e2) public {\n        uint256[] memory a = new uint256[](3);\n        a[0] = e0;\n        a[1] = e1;\n        a[2] = e2;\n        uint256[] memory b = new uint256[](3);\n        b[0] = e0;\n        b[1] = e1;\n        b[2] = e2;\n\n        t._assertEq(a, b, EXPECT_PASS);\n    }\n\n    function testAssertEq_IntArr_Pass(int256 e0, int256 e1, int256 e2) public {\n        int256[] memory a = new int256[](3);\n        a[0] = e0;\n        a[1] = e1;\n        a[2] = e2;\n        int256[] memory b = new int256[](3);\n        b[0] = e0;\n        b[1] = e1;\n        b[2] = e2;\n\n        t._assertEq(a, b, EXPECT_PASS);\n    }\n\n    function testAssertEq_AddressArr_Pass(address e0, address e1, address e2) public {\n        address[] memory a = new address[](3);\n        a[0] = e0;\n        a[1] = e1;\n        a[2] = e2;\n        address[] memory b = new address[](3);\n        b[0] = e0;\n        b[1] = e1;\n        b[2] = e2;\n\n        t._assertEq(a, b, EXPECT_PASS);\n    }\n\n    function testAssertEq_UintArr_FailEl(uint256 e1) public {\n        vm.assume(e1 != 0);\n        uint256[] memory a = new uint256[](3);\n        uint256[] memory b = new uint256[](3);\n        b[1] = e1;\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [uint[]]\");\n        t._assertEq(a, b, EXPECT_FAIL);\n    }\n\n    function testAssertEq_IntArr_FailEl(int256 e1) public {\n        vm.assume(e1 != 0);\n        int256[] memory a = new int256[](3);\n        int256[] memory b = new int256[](3);\n        b[1] = e1;\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [int[]]\");\n        t._assertEq(a, b, EXPECT_FAIL);\n    }\n\n    function testAssertEq_AddressArr_FailEl(address e1) public {\n        vm.assume(e1 != address(0));\n        address[] memory a = new address[](3);\n        address[] memory b = new address[](3);\n        b[1] = e1;\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [address[]]\");\n        t._assertEq(a, b, EXPECT_FAIL);\n    }\n\n    function testAssertEq_UintArrErr_FailEl(uint256 e1) public {\n        vm.assume(e1 != 0);\n        uint256[] memory a = new uint256[](3);\n        uint256[] memory b = new uint256[](3);\n        b[1] = e1;\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [uint[]]\");\n        t._assertEq(a, b, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    function testAssertEq_IntArrErr_FailEl(int256 e1) public {\n        vm.assume(e1 != 0);\n        int256[] memory a = new int256[](3);\n        int256[] memory b = new int256[](3);\n        b[1] = e1;\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [int[]]\");\n        t._assertEq(a, b, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    function testAssertEq_AddressArrErr_FailEl(address e1) public {\n        vm.assume(e1 != address(0));\n        address[] memory a = new address[](3);\n        address[] memory b = new address[](3);\n        b[1] = e1;\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [address[]]\");\n        t._assertEq(a, b, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    function testAssertEq_UintArr_FailLen(uint256 lenA, uint256 lenB) public {\n        vm.assume(lenA != lenB);\n        vm.assume(lenA <= 10000);\n        vm.assume(lenB <= 10000);\n        uint256[] memory a = new uint256[](lenA);\n        uint256[] memory b = new uint256[](lenB);\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [uint[]]\");\n        t._assertEq(a, b, EXPECT_FAIL);\n    }\n\n    function testAssertEq_IntArr_FailLen(uint256 lenA, uint256 lenB) public {\n        vm.assume(lenA != lenB);\n        vm.assume(lenA <= 10000);\n        vm.assume(lenB <= 10000);\n        int256[] memory a = new int256[](lenA);\n        int256[] memory b = new int256[](lenB);\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [int[]]\");\n        t._assertEq(a, b, EXPECT_FAIL);\n    }\n\n    function testAssertEq_AddressArr_FailLen(uint256 lenA, uint256 lenB) public {\n        vm.assume(lenA != lenB);\n        vm.assume(lenA <= 10000);\n        vm.assume(lenB <= 10000);\n        address[] memory a = new address[](lenA);\n        address[] memory b = new address[](lenB);\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [address[]]\");\n        t._assertEq(a, b, EXPECT_FAIL);\n    }\n\n    function testAssertEq_UintArrErr_FailLen(uint256 lenA, uint256 lenB) public {\n        vm.assume(lenA != lenB);\n        vm.assume(lenA <= 10000);\n        vm.assume(lenB <= 10000);\n        uint256[] memory a = new uint256[](lenA);\n        uint256[] memory b = new uint256[](lenB);\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [uint[]]\");\n        t._assertEq(a, b, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    function testAssertEq_IntArrErr_FailLen(uint256 lenA, uint256 lenB) public {\n        vm.assume(lenA != lenB);\n        vm.assume(lenA <= 10000);\n        vm.assume(lenB <= 10000);\n        int256[] memory a = new int256[](lenA);\n        int256[] memory b = new int256[](lenB);\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [int[]]\");\n        t._assertEq(a, b, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    function testAssertEq_AddressArrErr_FailLen(uint256 lenA, uint256 lenB) public {\n        vm.assume(lenA != lenB);\n        vm.assume(lenA <= 10000);\n        vm.assume(lenB <= 10000);\n        address[] memory a = new address[](lenA);\n        address[] memory b = new address[](lenB);\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [address[]]\");\n        t._assertEq(a, b, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    ASSERT_EQ(UINT)\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testAssertEqUint() public {\n        assertEqUint(uint8(1), uint128(1));\n        assertEqUint(uint64(2), uint64(2));\n    }\n\n    function testFailAssertEqUint() public {\n        assertEqUint(uint64(1), uint96(2));\n        assertEqUint(uint160(3), uint160(4));\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    APPROX_EQ_ABS(UINT)\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testAssertApproxEqAbs_Uint_Pass(uint256 a, uint256 b, uint256 maxDelta) external {\n        vm.assume(stdMath.delta(a, b) <= maxDelta);\n\n        t._assertApproxEqAbs(a, b, maxDelta, EXPECT_PASS);\n    }\n\n    function testAssertApproxEqAbs_Uint_Fail(uint256 a, uint256 b, uint256 maxDelta) external {\n        vm.assume(stdMath.delta(a, b) > maxDelta);\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a ~= b not satisfied [uint]\");\n        t._assertApproxEqAbs(a, b, maxDelta, EXPECT_FAIL);\n    }\n\n    function testAssertApproxEqAbs_UintErr_Pass(uint256 a, uint256 b, uint256 maxDelta) external {\n        vm.assume(stdMath.delta(a, b) <= maxDelta);\n\n        t._assertApproxEqAbs(a, b, maxDelta, CUSTOM_ERROR, EXPECT_PASS);\n    }\n\n    function testAssertApproxEqAbs_UintErr_Fail(uint256 a, uint256 b, uint256 maxDelta) external {\n        vm.assume(stdMath.delta(a, b) > maxDelta);\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        t._assertApproxEqAbs(a, b, maxDelta, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    APPROX_EQ_ABS_DECIMAL(UINT)\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testAssertApproxEqAbsDecimal_Uint_Pass(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals)\n        external\n    {\n        vm.assume(stdMath.delta(a, b) <= maxDelta);\n\n        t._assertApproxEqAbsDecimal(a, b, maxDelta, decimals, EXPECT_PASS);\n    }\n\n    function testAssertApproxEqAbsDecimal_Uint_Fail(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals)\n        external\n    {\n        vm.assume(stdMath.delta(a, b) > maxDelta);\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a ~= b not satisfied [uint]\");\n        t._assertApproxEqAbsDecimal(a, b, maxDelta, decimals, EXPECT_FAIL);\n    }\n\n    function testAssertApproxEqAbsDecimal_UintErr_Pass(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals)\n        external\n    {\n        vm.assume(stdMath.delta(a, b) <= maxDelta);\n\n        t._assertApproxEqAbsDecimal(a, b, maxDelta, decimals, CUSTOM_ERROR, EXPECT_PASS);\n    }\n\n    function testAssertApproxEqAbsDecimal_UintErr_Fail(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals)\n        external\n    {\n        vm.assume(stdMath.delta(a, b) > maxDelta);\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        t._assertApproxEqAbsDecimal(a, b, maxDelta, decimals, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    APPROX_EQ_ABS(INT)\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testAssertApproxEqAbs_Int_Pass(int256 a, int256 b, uint256 maxDelta) external {\n        vm.assume(stdMath.delta(a, b) <= maxDelta);\n\n        t._assertApproxEqAbs(a, b, maxDelta, EXPECT_PASS);\n    }\n\n    function testAssertApproxEqAbs_Int_Fail(int256 a, int256 b, uint256 maxDelta) external {\n        vm.assume(stdMath.delta(a, b) > maxDelta);\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a ~= b not satisfied [int]\");\n        t._assertApproxEqAbs(a, b, maxDelta, EXPECT_FAIL);\n    }\n\n    function testAssertApproxEqAbs_IntErr_Pass(int256 a, int256 b, uint256 maxDelta) external {\n        vm.assume(stdMath.delta(a, b) <= maxDelta);\n\n        t._assertApproxEqAbs(a, b, maxDelta, CUSTOM_ERROR, EXPECT_PASS);\n    }\n\n    function testAssertApproxEqAbs_IntErr_Fail(int256 a, int256 b, uint256 maxDelta) external {\n        vm.assume(stdMath.delta(a, b) > maxDelta);\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        t._assertApproxEqAbs(a, b, maxDelta, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    APPROX_EQ_ABS_DECIMAL(INT)\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testAssertApproxEqAbsDecimal_Int_Pass(int256 a, int256 b, uint256 maxDelta, uint256 decimals) external {\n        vm.assume(stdMath.delta(a, b) <= maxDelta);\n\n        t._assertApproxEqAbsDecimal(a, b, maxDelta, decimals, EXPECT_PASS);\n    }\n\n    function testAssertApproxEqAbsDecimal_Int_Fail(int256 a, int256 b, uint256 maxDelta, uint256 decimals) external {\n        vm.assume(stdMath.delta(a, b) > maxDelta);\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a ~= b not satisfied [int]\");\n        t._assertApproxEqAbsDecimal(a, b, maxDelta, decimals, EXPECT_FAIL);\n    }\n\n    function testAssertApproxEqAbsDecimal_IntErr_Pass(int256 a, int256 b, uint256 maxDelta, uint256 decimals)\n        external\n    {\n        vm.assume(stdMath.delta(a, b) <= maxDelta);\n\n        t._assertApproxEqAbsDecimal(a, b, maxDelta, decimals, CUSTOM_ERROR, EXPECT_PASS);\n    }\n\n    function testAssertApproxEqAbsDecimal_IntErr_Fail(int256 a, int256 b, uint256 maxDelta, uint256 decimals)\n        external\n    {\n        vm.assume(stdMath.delta(a, b) > maxDelta);\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        t._assertApproxEqAbsDecimal(a, b, maxDelta, decimals, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    APPROX_EQ_REL(UINT)\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testAssertApproxEqRel_Uint_Pass(uint256 a, uint256 b, uint256 maxPercentDelta) external {\n        vm.assume(a < type(uint128).max && b < type(uint128).max && b != 0);\n        vm.assume(stdMath.percentDelta(a, b) <= maxPercentDelta);\n\n        t._assertApproxEqRel(a, b, maxPercentDelta, EXPECT_PASS);\n    }\n\n    function testAssertApproxEqRel_Uint_Fail(uint256 a, uint256 b, uint256 maxPercentDelta) external {\n        vm.assume(a < type(uint128).max && b < type(uint128).max && b != 0);\n        vm.assume(stdMath.percentDelta(a, b) > maxPercentDelta);\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a ~= b not satisfied [uint]\");\n        t._assertApproxEqRel(a, b, maxPercentDelta, EXPECT_FAIL);\n    }\n\n    function testAssertApproxEqRel_UintErr_Pass(uint256 a, uint256 b, uint256 maxPercentDelta) external {\n        vm.assume(a < type(uint128).max && b < type(uint128).max && b != 0);\n        vm.assume(stdMath.percentDelta(a, b) <= maxPercentDelta);\n\n        t._assertApproxEqRel(a, b, maxPercentDelta, CUSTOM_ERROR, EXPECT_PASS);\n    }\n\n    function testAssertApproxEqRel_UintErr_Fail(uint256 a, uint256 b, uint256 maxPercentDelta) external {\n        vm.assume(a < type(uint128).max && b < type(uint128).max && b != 0);\n        vm.assume(stdMath.percentDelta(a, b) > maxPercentDelta);\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        t._assertApproxEqRel(a, b, maxPercentDelta, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    APPROX_EQ_REL_DECIMAL(UINT)\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testAssertApproxEqRelDecimal_Uint_Pass(uint256 a, uint256 b, uint256 maxPercentDelta, uint256 decimals)\n        external\n    {\n        vm.assume(a < type(uint128).max && b < type(uint128).max && b != 0);\n        vm.assume(stdMath.percentDelta(a, b) <= maxPercentDelta);\n\n        t._assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals, EXPECT_PASS);\n    }\n\n    function testAssertApproxEqRelDecimal_Uint_Fail(uint256 a, uint256 b, uint256 maxPercentDelta, uint256 decimals)\n        external\n    {\n        vm.assume(a < type(uint128).max && b < type(uint128).max && b != 0);\n        vm.assume(stdMath.percentDelta(a, b) > maxPercentDelta);\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a ~= b not satisfied [uint]\");\n        t._assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals, EXPECT_FAIL);\n    }\n\n    function testAssertApproxEqRelDecimal_UintErr_Pass(uint256 a, uint256 b, uint256 maxPercentDelta, uint256 decimals)\n        external\n    {\n        vm.assume(a < type(uint128).max && b < type(uint128).max && b != 0);\n        vm.assume(stdMath.percentDelta(a, b) <= maxPercentDelta);\n\n        t._assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals, CUSTOM_ERROR, EXPECT_PASS);\n    }\n\n    function testAssertApproxEqRelDecimal_UintErr_Fail(uint256 a, uint256 b, uint256 maxPercentDelta, uint256 decimals)\n        external\n    {\n        vm.assume(a < type(uint128).max && b < type(uint128).max && b != 0);\n        vm.assume(stdMath.percentDelta(a, b) > maxPercentDelta);\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        t._assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    APPROX_EQ_REL(INT)\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testAssertApproxEqRel_Int_Pass(int128 a, int128 b, uint128 maxPercentDelta) external {\n        vm.assume(b != 0);\n        vm.assume(stdMath.percentDelta(a, b) <= maxPercentDelta);\n\n        t._assertApproxEqRel(a, b, maxPercentDelta, EXPECT_PASS);\n    }\n\n    function testAssertApproxEqRel_Int_Fail(int128 a, int128 b, uint128 maxPercentDelta) external {\n        vm.assume(b != 0);\n        vm.assume(stdMath.percentDelta(a, b) > maxPercentDelta);\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a ~= b not satisfied [int]\");\n        t._assertApproxEqRel(a, b, maxPercentDelta, EXPECT_FAIL);\n    }\n\n    function testAssertApproxEqRel_IntErr_Pass(int128 a, int128 b, uint128 maxPercentDelta) external {\n        vm.assume(b != 0);\n        vm.assume(stdMath.percentDelta(a, b) <= maxPercentDelta);\n\n        t._assertApproxEqRel(a, b, maxPercentDelta, CUSTOM_ERROR, EXPECT_PASS);\n    }\n\n    function testAssertApproxEqRel_IntErr_Fail(int128 a, int128 b, uint128 maxPercentDelta) external {\n        vm.assume(b != 0);\n        vm.assume(stdMath.percentDelta(a, b) > maxPercentDelta);\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        t._assertApproxEqRel(a, b, maxPercentDelta, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    APPROX_EQ_REL_DECIMAL(INT)\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testAssertApproxEqRelDecimal_Int_Pass(int128 a, int128 b, uint128 maxPercentDelta, uint128 decimals)\n        external\n    {\n        vm.assume(b != 0);\n        vm.assume(stdMath.percentDelta(a, b) <= maxPercentDelta);\n\n        t._assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals, EXPECT_PASS);\n    }\n\n    function testAssertApproxEqRelDecimal_Int_Fail(int128 a, int128 b, uint128 maxPercentDelta, uint128 decimals)\n        external\n    {\n        vm.assume(b != 0);\n        vm.assume(stdMath.percentDelta(a, b) > maxPercentDelta);\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a ~= b not satisfied [int]\");\n        t._assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals, EXPECT_FAIL);\n    }\n\n    function testAssertApproxEqRelDecimal_IntErr_Pass(int128 a, int128 b, uint128 maxPercentDelta, uint128 decimals)\n        external\n    {\n        vm.assume(b != 0);\n        vm.assume(stdMath.percentDelta(a, b) <= maxPercentDelta);\n\n        t._assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals, CUSTOM_ERROR, EXPECT_PASS);\n    }\n\n    function testAssertApproxEqRelDecimal_IntErr_Fail(int128 a, int128 b, uint128 maxPercentDelta, uint128 decimals)\n        external\n    {\n        vm.assume(b != 0);\n        vm.assume(stdMath.percentDelta(a, b) > maxPercentDelta);\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        t._assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    ASSERT_EQ_CALL\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testAssertEqCall_Return_Pass(\n        bytes memory callDataA,\n        bytes memory callDataB,\n        bytes memory returnData,\n        bool strictRevertData\n    ) external {\n        address targetA = address(new TestMockCall(returnData, SHOULD_RETURN));\n        address targetB = address(new TestMockCall(returnData, SHOULD_RETURN));\n\n        t._assertEqCall(targetA, callDataA, targetB, callDataB, strictRevertData, EXPECT_PASS);\n    }\n\n    function testAssertEqCall_Return_Fail(\n        bytes memory callDataA,\n        bytes memory callDataB,\n        bytes memory returnDataA,\n        bytes memory returnDataB,\n        bool strictRevertData\n    ) external {\n        vm.assume(keccak256(returnDataA) != keccak256(returnDataB));\n\n        address targetA = address(new TestMockCall(returnDataA, SHOULD_RETURN));\n        address targetB = address(new TestMockCall(returnDataB, SHOULD_RETURN));\n\n        vm.expectEmit(true, true, true, true);\n        emit log_named_string(\"Error\", \"Call return data does not match\");\n        t._assertEqCall(targetA, callDataA, targetB, callDataB, strictRevertData, EXPECT_FAIL);\n    }\n\n    function testAssertEqCall_Revert_Pass(\n        bytes memory callDataA,\n        bytes memory callDataB,\n        bytes memory revertDataA,\n        bytes memory revertDataB\n    ) external {\n        address targetA = address(new TestMockCall(revertDataA, SHOULD_REVERT));\n        address targetB = address(new TestMockCall(revertDataB, SHOULD_REVERT));\n\n        t._assertEqCall(targetA, callDataA, targetB, callDataB, NON_STRICT_REVERT_DATA, EXPECT_PASS);\n    }\n\n    function testAssertEqCall_Revert_Fail(\n        bytes memory callDataA,\n        bytes memory callDataB,\n        bytes memory revertDataA,\n        bytes memory revertDataB\n    ) external {\n        vm.assume(keccak256(revertDataA) != keccak256(revertDataB));\n\n        address targetA = address(new TestMockCall(revertDataA, SHOULD_REVERT));\n        address targetB = address(new TestMockCall(revertDataB, SHOULD_REVERT));\n\n        vm.expectEmit(true, true, true, true);\n        emit log_named_string(\"Error\", \"Call revert data does not match\");\n        t._assertEqCall(targetA, callDataA, targetB, callDataB, STRICT_REVERT_DATA, EXPECT_FAIL);\n    }\n\n    function testAssertEqCall_Fail(\n        bytes memory callDataA,\n        bytes memory callDataB,\n        bytes memory returnDataA,\n        bytes memory returnDataB,\n        bool strictRevertData\n    ) external {\n        address targetA = address(new TestMockCall(returnDataA, SHOULD_RETURN));\n        address targetB = address(new TestMockCall(returnDataB, SHOULD_REVERT));\n\n        vm.expectEmit(true, true, true, true);\n        emit log_named_bytes(\"  Left call return data\", returnDataA);\n        vm.expectEmit(true, true, true, true);\n        emit log_named_bytes(\" Right call revert data\", returnDataB);\n        t._assertEqCall(targetA, callDataA, targetB, callDataB, strictRevertData, EXPECT_FAIL);\n\n        vm.expectEmit(true, true, true, true);\n        emit log_named_bytes(\"  Left call revert data\", returnDataB);\n        vm.expectEmit(true, true, true, true);\n        emit log_named_bytes(\" Right call return data\", returnDataA);\n        t._assertEqCall(targetB, callDataB, targetA, callDataA, strictRevertData, EXPECT_FAIL);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                ASSERT_NOT_EQ(BYTES)\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testAssertNotEq_Bytes_Pass(bytes32 a, bytes32 b) external {\n        vm.assume(a != b);\n        t._assertNotEq(a, b, EXPECT_PASS);\n    }\n\n    function testAssertNotEq_Bytes_Fail(bytes32 a) external {\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a != b not satisfied [bytes32]\");\n        t._assertNotEq(a, a, EXPECT_FAIL);\n    }\n\n    function testAssertNotEq_BytesErr_Pass(bytes32 a, bytes32 b) external {\n        vm.assume(a != b);\n        t._assertNotEq(a, b, CUSTOM_ERROR, EXPECT_PASS);\n    }\n\n    function testAsserNottEq_BytesErr_Fail(bytes32 a) external {\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        t._assertNotEq(a, a, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                ASSERT_NOT_EQ(UINT)\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testAssertNotEqUint() public {\n        assertNotEq(uint8(1), uint128(2));\n        assertNotEq(uint64(3), uint64(4));\n    }\n\n    function testFailAssertNotEqUint() public {\n        assertNotEq(uint64(1), uint96(1));\n        assertNotEq(uint160(2), uint160(2));\n    }\n}\n\ncontract TestTest is Test {\n    modifier expectFailure(bool expectFail) {\n        bool preState = vm.load(HEVM_ADDRESS, bytes32(\"failed\")) != bytes32(0x00);\n        _;\n        bool postState = vm.load(HEVM_ADDRESS, bytes32(\"failed\")) != bytes32(0x00);\n\n        if (preState == true) {\n            return;\n        }\n\n        if (expectFail) {\n            require(postState == true, \"expected failure not triggered\");\n\n            // unwind the expected failure\n            vm.store(HEVM_ADDRESS, bytes32(\"failed\"), bytes32(uint256(0x00)));\n        } else {\n            require(postState == false, \"unexpected failure was triggered\");\n        }\n    }\n\n    function _fail(string memory err) external expectFailure(true) {\n        fail(err);\n    }\n\n    function _assertFalse(bool data, bool expectFail) external expectFailure(expectFail) {\n        assertFalse(data);\n    }\n\n    function _assertFalse(bool data, string memory err, bool expectFail) external expectFailure(expectFail) {\n        assertFalse(data, err);\n    }\n\n    function _assertEq(bool a, bool b, bool expectFail) external expectFailure(expectFail) {\n        assertEq(a, b);\n    }\n\n    function _assertEq(bool a, bool b, string memory err, bool expectFail) external expectFailure(expectFail) {\n        assertEq(a, b, err);\n    }\n\n    function _assertEq(bytes memory a, bytes memory b, bool expectFail) external expectFailure(expectFail) {\n        assertEq(a, b);\n    }\n\n    function _assertEq(bytes memory a, bytes memory b, string memory err, bool expectFail)\n        external\n        expectFailure(expectFail)\n    {\n        assertEq(a, b, err);\n    }\n\n    function _assertEq(uint256[] memory a, uint256[] memory b, bool expectFail) external expectFailure(expectFail) {\n        assertEq(a, b);\n    }\n\n    function _assertEq(int256[] memory a, int256[] memory b, bool expectFail) external expectFailure(expectFail) {\n        assertEq(a, b);\n    }\n\n    function _assertEq(address[] memory a, address[] memory b, bool expectFail) external expectFailure(expectFail) {\n        assertEq(a, b);\n    }\n\n    function _assertEq(uint256[] memory a, uint256[] memory b, string memory err, bool expectFail)\n        external\n        expectFailure(expectFail)\n    {\n        assertEq(a, b, err);\n    }\n\n    function _assertEq(int256[] memory a, int256[] memory b, string memory err, bool expectFail)\n        external\n        expectFailure(expectFail)\n    {\n        assertEq(a, b, err);\n    }\n\n    function _assertEq(address[] memory a, address[] memory b, string memory err, bool expectFail)\n        external\n        expectFailure(expectFail)\n    {\n        assertEq(a, b, err);\n    }\n\n    function _assertNotEq(bytes32 a, bytes32 b, bool expectFail) external expectFailure(expectFail) {\n        assertNotEq32(a, b);\n    }\n\n    function _assertNotEq(bytes32 a, bytes32 b, string memory err, bool expectFail)\n        external\n        expectFailure(expectFail)\n    {\n        assertNotEq32(a, b, err);\n    }\n\n    function _assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, bool expectFail)\n        external\n        expectFailure(expectFail)\n    {\n        assertApproxEqAbs(a, b, maxDelta);\n    }\n\n    function _assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, string memory err, bool expectFail)\n        external\n        expectFailure(expectFail)\n    {\n        assertApproxEqAbs(a, b, maxDelta, err);\n    }\n\n    function _assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals, bool expectFail)\n        external\n        expectFailure(expectFail)\n    {\n        assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\n    }\n\n    function _assertApproxEqAbsDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta,\n        uint256 decimals,\n        string memory err,\n        bool expectFail\n    ) external expectFailure(expectFail) {\n        assertApproxEqAbsDecimal(a, b, maxDelta, decimals, err);\n    }\n\n    function _assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta, bool expectFail)\n        external\n        expectFailure(expectFail)\n    {\n        assertApproxEqAbs(a, b, maxDelta);\n    }\n\n    function _assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta, string memory err, bool expectFail)\n        external\n        expectFailure(expectFail)\n    {\n        assertApproxEqAbs(a, b, maxDelta, err);\n    }\n\n    function _assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals, bool expectFail)\n        external\n        expectFailure(expectFail)\n    {\n        assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\n    }\n\n    function _assertApproxEqAbsDecimal(\n        int256 a,\n        int256 b,\n        uint256 maxDelta,\n        uint256 decimals,\n        string memory err,\n        bool expectFail\n    ) external expectFailure(expectFail) {\n        assertApproxEqAbsDecimal(a, b, maxDelta, decimals, err);\n    }\n\n    function _assertApproxEqRel(uint256 a, uint256 b, uint256 maxPercentDelta, bool expectFail)\n        external\n        expectFailure(expectFail)\n    {\n        assertApproxEqRel(a, b, maxPercentDelta);\n    }\n\n    function _assertApproxEqRel(uint256 a, uint256 b, uint256 maxPercentDelta, string memory err, bool expectFail)\n        external\n        expectFailure(expectFail)\n    {\n        assertApproxEqRel(a, b, maxPercentDelta, err);\n    }\n\n    function _assertApproxEqRelDecimal(uint256 a, uint256 b, uint256 maxPercentDelta, uint256 decimals, bool expectFail)\n        external\n        expectFailure(expectFail)\n    {\n        assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\n    }\n\n    function _assertApproxEqRelDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta,\n        uint256 decimals,\n        string memory err,\n        bool expectFail\n    ) external expectFailure(expectFail) {\n        assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals, err);\n    }\n\n    function _assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta, bool expectFail)\n        external\n        expectFailure(expectFail)\n    {\n        assertApproxEqRel(a, b, maxPercentDelta);\n    }\n\n    function _assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta, string memory err, bool expectFail)\n        external\n        expectFailure(expectFail)\n    {\n        assertApproxEqRel(a, b, maxPercentDelta, err);\n    }\n\n    function _assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals, bool expectFail)\n        external\n        expectFailure(expectFail)\n    {\n        assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\n    }\n\n    function _assertApproxEqRelDecimal(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta,\n        uint256 decimals,\n        string memory err,\n        bool expectFail\n    ) external expectFailure(expectFail) {\n        assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals, err);\n    }\n\n    function _assertEqCall(\n        address targetA,\n        bytes memory callDataA,\n        address targetB,\n        bytes memory callDataB,\n        bool strictRevertData,\n        bool expectFail\n    ) external expectFailure(expectFail) {\n        assertEqCall(targetA, callDataA, targetB, callDataB, strictRevertData);\n    }\n}\n\ncontract TestMockCall {\n    bytes returnData;\n    bool shouldRevert;\n\n    constructor(bytes memory returnData_, bool shouldRevert_) {\n        returnData = returnData_;\n        shouldRevert = shouldRevert_;\n    }\n\n    fallback() external payable {\n        bytes memory returnData_ = returnData;\n\n        if (shouldRevert) {\n            assembly {\n                revert(add(returnData_, 0x20), mload(returnData_))\n            }\n        } else {\n            assembly {\n                return(add(returnData_, 0x20), mload(returnData_))\n            }\n        }\n    }\n}\n"},"hedge/lib/forge-std/test/StdChains.t.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../src/Test.sol\";\n\ncontract StdChainsTest is Test {\n    function testChainRpcInitialization() public {\n        // RPCs specified in `foundry.toml` should be updated.\n        assertEq(getChain(1).rpcUrl, \"https://mainnet.infura.io/v3/b1d3925804e74152b316ca7da97060d3\");\n        assertEq(getChain(\"optimism_goerli\").rpcUrl, \"https://goerli.optimism.io/\");\n        assertEq(getChain(\"arbitrum_one_goerli\").rpcUrl, \"https://goerli-rollup.arbitrum.io/rpc/\");\n\n        // Environment variables should be the next fallback\n        assertEq(getChain(\"arbitrum_nova\").rpcUrl, \"https://nova.arbitrum.io/rpc\");\n        vm.setEnv(\"ARBITRUM_NOVA_RPC_URL\", \"myoverride\");\n        assertEq(getChain(\"arbitrum_nova\").rpcUrl, \"myoverride\");\n        vm.setEnv(\"ARBITRUM_NOVA_RPC_URL\", \"https://nova.arbitrum.io/rpc\");\n\n        // Cannot override RPCs defined in `foundry.toml`\n        vm.setEnv(\"MAINNET_RPC_URL\", \"myoverride2\");\n        assertEq(getChain(\"mainnet\").rpcUrl, \"https://mainnet.infura.io/v3/b1d3925804e74152b316ca7da97060d3\");\n\n        // Other RPCs should remain unchanged.\n        assertEq(getChain(31337).rpcUrl, \"http://127.0.0.1:8545\");\n        assertEq(getChain(\"sepolia\").rpcUrl, \"https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\");\n    }\n\n    function testRpc(string memory rpcAlias) internal {\n        string memory rpcUrl = getChain(rpcAlias).rpcUrl;\n        vm.createSelectFork(rpcUrl);\n    }\n\n    // Ensure we can connect to the default RPC URL for each chain.\n    // function testRpcs() public {\n    //     testRpc(\"mainnet\");\n    //     testRpc(\"goerli\");\n    //     testRpc(\"sepolia\");\n    //     testRpc(\"optimism\");\n    //     testRpc(\"optimism_goerli\");\n    //     testRpc(\"arbitrum_one\");\n    //     testRpc(\"arbitrum_one_goerli\");\n    //     testRpc(\"arbitrum_nova\");\n    //     testRpc(\"polygon\");\n    //     testRpc(\"polygon_mumbai\");\n    //     testRpc(\"avalanche\");\n    //     testRpc(\"avalanche_fuji\");\n    //     testRpc(\"bnb_smart_chain\");\n    //     testRpc(\"bnb_smart_chain_testnet\");\n    //     testRpc(\"gnosis_chain\");\n    // }\n\n    function testChainNoDefault() public {\n        vm.expectRevert(\"StdChains getChain(string): Chain with alias \\\"does_not_exist\\\" not found.\");\n        getChain(\"does_not_exist\");\n    }\n\n    function testSetChainFirstFails() public {\n        vm.expectRevert(\"StdChains setChain(string,ChainData): Chain ID 31337 already used by \\\"anvil\\\".\");\n        setChain(\"anvil2\", ChainData(\"Anvil\", 31337, \"URL\"));\n    }\n\n    function testChainBubbleUp() public {\n        setChain(\"needs_undefined_env_var\", ChainData(\"\", 123456789, \"\"));\n        vm.expectRevert(\n            \"Failed to resolve env var `UNDEFINED_RPC_URL_PLACEHOLDER` in `${UNDEFINED_RPC_URL_PLACEHOLDER}`: environment variable not found\"\n        );\n        getChain(\"needs_undefined_env_var\");\n    }\n\n    function testCannotSetChain_ChainIdExists() public {\n        setChain(\"custom_chain\", ChainData(\"Custom Chain\", 123456789, \"https://custom.chain/\"));\n\n        vm.expectRevert('StdChains setChain(string,ChainData): Chain ID 123456789 already used by \"custom_chain\".');\n\n        setChain(\"another_custom_chain\", ChainData(\"\", 123456789, \"\"));\n    }\n\n    function testSetChain() public {\n        setChain(\"custom_chain\", ChainData(\"Custom Chain\", 123456789, \"https://custom.chain/\"));\n        Chain memory customChain = getChain(\"custom_chain\");\n        assertEq(customChain.name, \"Custom Chain\");\n        assertEq(customChain.chainId, 123456789);\n        assertEq(customChain.chainAlias, \"custom_chain\");\n        assertEq(customChain.rpcUrl, \"https://custom.chain/\");\n        Chain memory chainById = getChain(123456789);\n        assertEq(chainById.name, customChain.name);\n        assertEq(chainById.chainId, customChain.chainId);\n        assertEq(chainById.chainAlias, customChain.chainAlias);\n        assertEq(chainById.rpcUrl, customChain.rpcUrl);\n        customChain.name = \"Another Custom Chain\";\n        customChain.chainId = 987654321;\n        setChain(\"another_custom_chain\", customChain);\n        Chain memory anotherCustomChain = getChain(\"another_custom_chain\");\n        assertEq(anotherCustomChain.name, \"Another Custom Chain\");\n        assertEq(anotherCustomChain.chainId, 987654321);\n        assertEq(anotherCustomChain.chainAlias, \"another_custom_chain\");\n        assertEq(anotherCustomChain.rpcUrl, \"https://custom.chain/\");\n        // Verify the first chain data was not overwritten\n        chainById = getChain(123456789);\n        assertEq(chainById.name, \"Custom Chain\");\n        assertEq(chainById.chainId, 123456789);\n    }\n\n    function testSetNoEmptyAlias() public {\n        vm.expectRevert(\"StdChains setChain(string,ChainData): Chain alias cannot be the empty string.\");\n        setChain(\"\", ChainData(\"\", 123456789, \"\"));\n    }\n\n    function testSetNoChainId0() public {\n        vm.expectRevert(\"StdChains setChain(string,ChainData): Chain ID cannot be 0.\");\n        setChain(\"alias\", ChainData(\"\", 0, \"\"));\n    }\n\n    function testGetNoChainId0() public {\n        vm.expectRevert(\"StdChains getChain(uint256): Chain ID cannot be 0.\");\n        getChain(0);\n    }\n\n    function testGetNoEmptyAlias() public {\n        vm.expectRevert(\"StdChains getChain(string): Chain alias cannot be the empty string.\");\n        getChain(\"\");\n    }\n\n    function testChainIdNotFound() public {\n        vm.expectRevert(\"StdChains getChain(string): Chain with alias \\\"no_such_alias\\\" not found.\");\n        getChain(\"no_such_alias\");\n    }\n\n    function testChainAliasNotFound() public {\n        vm.expectRevert(\"StdChains getChain(uint256): Chain with ID 321 not found.\");\n        getChain(321);\n    }\n\n    function testSetChain_ExistingOne() public {\n        setChain(\"custom_chain\", ChainData(\"Custom Chain\", 123456789, \"https://custom.chain/\"));\n        assertEq(getChain(123456789).chainId, 123456789);\n\n        setChain(\"custom_chain\", ChainData(\"Modified Chain\", 999999999, \"https://modified.chain/\"));\n        vm.expectRevert(\"StdChains getChain(uint256): Chain with ID 123456789 not found.\");\n        getChain(123456789);\n\n        Chain memory modifiedChain = getChain(999999999);\n        assertEq(modifiedChain.name, \"Modified Chain\");\n        assertEq(modifiedChain.chainId, 999999999);\n        assertEq(modifiedChain.rpcUrl, \"https://modified.chain/\");\n    }\n\n    function testDontUseDefaultRpcUrl() public {\n        // Should error if default RPCs flag is set to false.\n        setFallbackToDefaultRpcUrls(false);\n        vm.expectRevert(\n            \"Failed to get environment variable `ANVIL_RPC_URL` as type `string`: environment variable not found\"\n        );\n        getChain(31337);\n        vm.expectRevert(\n            \"Failed to get environment variable `SEPOLIA_RPC_URL` as type `string`: environment variable not found\"\n        );\n        getChain(\"sepolia\");\n    }\n}\n"},"hedge/lib/forge-std/test/StdCheats.t.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../src/StdCheats.sol\";\nimport \"../src/Test.sol\";\nimport \"../src/StdJson.sol\";\n\ncontract StdCheatsTest is Test {\n    Bar test;\n\n    using stdJson for string;\n\n    function setUp() public {\n        test = new Bar();\n    }\n\n    function testSkip() public {\n        vm.warp(100);\n        skip(25);\n        assertEq(block.timestamp, 125);\n    }\n\n    function testRewind() public {\n        vm.warp(100);\n        rewind(25);\n        assertEq(block.timestamp, 75);\n    }\n\n    function testHoax() public {\n        hoax(address(1337));\n        test.bar{value: 100}(address(1337));\n    }\n\n    function testHoaxOrigin() public {\n        hoax(address(1337), address(1337));\n        test.origin{value: 100}(address(1337));\n    }\n\n    function testHoaxDifferentAddresses() public {\n        hoax(address(1337), address(7331));\n        test.origin{value: 100}(address(1337), address(7331));\n    }\n\n    function testStartHoax() public {\n        startHoax(address(1337));\n        test.bar{value: 100}(address(1337));\n        test.bar{value: 100}(address(1337));\n        vm.stopPrank();\n        test.bar(address(this));\n    }\n\n    function testStartHoaxOrigin() public {\n        startHoax(address(1337), address(1337));\n        test.origin{value: 100}(address(1337));\n        test.origin{value: 100}(address(1337));\n        vm.stopPrank();\n        test.bar(address(this));\n    }\n\n    function testChangePrankMsgSender() public {\n        vm.startPrank(address(1337));\n        test.bar(address(1337));\n        changePrank(address(0xdead));\n        test.bar(address(0xdead));\n        changePrank(address(1337));\n        test.bar(address(1337));\n        vm.stopPrank();\n    }\n\n    function testChangePrankMsgSenderAndTxOrigin() public {\n        vm.startPrank(address(1337), address(1338));\n        test.origin(address(1337), address(1338));\n        changePrank(address(0xdead), address(0xbeef));\n        test.origin(address(0xdead), address(0xbeef));\n        changePrank(address(1337), address(1338));\n        test.origin(address(1337), address(1338));\n        vm.stopPrank();\n    }\n\n    function testMakeAccountEquivalence() public {\n        Account memory account = makeAccount(\"1337\");\n        (address addr, uint256 key) = makeAddrAndKey(\"1337\");\n        assertEq(account.addr, addr);\n        assertEq(account.key, key);\n    }\n\n    function testMakeAddrEquivalence() public {\n        (address addr,) = makeAddrAndKey(\"1337\");\n        assertEq(makeAddr(\"1337\"), addr);\n    }\n\n    function testMakeAddrSigning() public {\n        (address addr, uint256 key) = makeAddrAndKey(\"1337\");\n        bytes32 hash = keccak256(\"some_message\");\n\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(key, hash);\n        assertEq(ecrecover(hash, v, r, s), addr);\n    }\n\n    function testDeal() public {\n        deal(address(this), 1 ether);\n        assertEq(address(this).balance, 1 ether);\n    }\n\n    function testDealToken() public {\n        Bar barToken = new Bar();\n        address bar = address(barToken);\n        deal(bar, address(this), 10000e18);\n        assertEq(barToken.balanceOf(address(this)), 10000e18);\n    }\n\n    function testDealTokenAdjustTotalSupply() public {\n        Bar barToken = new Bar();\n        address bar = address(barToken);\n        deal(bar, address(this), 10000e18, true);\n        assertEq(barToken.balanceOf(address(this)), 10000e18);\n        assertEq(barToken.totalSupply(), 20000e18);\n        deal(bar, address(this), 0, true);\n        assertEq(barToken.balanceOf(address(this)), 0);\n        assertEq(barToken.totalSupply(), 10000e18);\n    }\n\n    function testDealERC1155Token() public {\n        BarERC1155 barToken = new BarERC1155();\n        address bar = address(barToken);\n        dealERC1155(bar, address(this), 0, 10000e18, false);\n        assertEq(barToken.balanceOf(address(this), 0), 10000e18);\n    }\n\n    function testDealERC1155TokenAdjustTotalSupply() public {\n        BarERC1155 barToken = new BarERC1155();\n        address bar = address(barToken);\n        dealERC1155(bar, address(this), 0, 10000e18, true);\n        assertEq(barToken.balanceOf(address(this), 0), 10000e18);\n        assertEq(barToken.totalSupply(0), 20000e18);\n        dealERC1155(bar, address(this), 0, 0, true);\n        assertEq(barToken.balanceOf(address(this), 0), 0);\n        assertEq(barToken.totalSupply(0), 10000e18);\n    }\n\n    function testDealERC721Token() public {\n        BarERC721 barToken = new BarERC721();\n        address bar = address(barToken);\n        dealERC721(bar, address(2), 1);\n        assertEq(barToken.balanceOf(address(2)), 1);\n        assertEq(barToken.balanceOf(address(1)), 0);\n        dealERC721(bar, address(1), 2);\n        assertEq(barToken.balanceOf(address(1)), 1);\n        assertEq(barToken.balanceOf(bar), 1);\n    }\n\n    function testDeployCode() public {\n        address deployed = deployCode(\"StdCheats.t.sol:Bar\", bytes(\"\"));\n        assertEq(string(getCode(deployed)), string(getCode(address(test))));\n    }\n\n    function testDestroyAccount() public {\n        // deploy something to destroy it\n        BarERC721 barToken = new BarERC721();\n        address bar = address(barToken);\n        vm.setNonce(bar, 10);\n        deal(bar, 100);\n\n        uint256 prevThisBalance = address(this).balance;\n        uint256 size;\n        assembly {\n            size := extcodesize(bar)\n        }\n\n        assertGt(size, 0);\n        assertEq(bar.balance, 100);\n        assertEq(vm.getNonce(bar), 10);\n\n        destroyAccount(bar, address(this));\n        assembly {\n            size := extcodesize(bar)\n        }\n        assertEq(address(this).balance, prevThisBalance + 100);\n        assertEq(vm.getNonce(bar), 0);\n        assertEq(size, 0);\n        assertEq(bar.balance, 0);\n    }\n\n    function testDeployCodeNoArgs() public {\n        address deployed = deployCode(\"StdCheats.t.sol:Bar\");\n        assertEq(string(getCode(deployed)), string(getCode(address(test))));\n    }\n\n    function testDeployCodeVal() public {\n        address deployed = deployCode(\"StdCheats.t.sol:Bar\", bytes(\"\"), 1 ether);\n        assertEq(string(getCode(deployed)), string(getCode(address(test))));\n        assertEq(deployed.balance, 1 ether);\n    }\n\n    function testDeployCodeValNoArgs() public {\n        address deployed = deployCode(\"StdCheats.t.sol:Bar\", 1 ether);\n        assertEq(string(getCode(deployed)), string(getCode(address(test))));\n        assertEq(deployed.balance, 1 ether);\n    }\n\n    // We need this so we can call \"this.deployCode\" rather than \"deployCode\" directly\n    function deployCodeHelper(string memory what) external {\n        deployCode(what);\n    }\n\n    function testDeployCodeFail() public {\n        vm.expectRevert(bytes(\"StdCheats deployCode(string): Deployment failed.\"));\n        this.deployCodeHelper(\"StdCheats.t.sol:RevertingContract\");\n    }\n\n    function getCode(address who) internal view returns (bytes memory o_code) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // retrieve the size of the code, this needs assembly\n            let size := extcodesize(who)\n            // allocate output byte array - this could also be done without assembly\n            // by using o_code = new bytes(size)\n            o_code := mload(0x40)\n            // new \"memory end\" including padding\n            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            // store length in memory\n            mstore(o_code, size)\n            // actually retrieve the code, this needs assembly\n            extcodecopy(who, add(o_code, 0x20), 0, size)\n        }\n    }\n\n    function testDeriveRememberKey() public {\n        string memory mnemonic = \"test test test test test test test test test test test junk\";\n\n        (address deployer, uint256 privateKey) = deriveRememberKey(mnemonic, 0);\n        assertEq(deployer, 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266);\n        assertEq(privateKey, 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80);\n    }\n\n    function testBytesToUint() public {\n        assertEq(3, bytesToUint_test(hex\"03\"));\n        assertEq(2, bytesToUint_test(hex\"02\"));\n        assertEq(255, bytesToUint_test(hex\"ff\"));\n        assertEq(29625, bytesToUint_test(hex\"73b9\"));\n    }\n\n    function testParseJsonTxDetail() public {\n        string memory root = vm.projectRoot();\n        string memory path = string.concat(root, \"/test/fixtures/broadcast.log.json\");\n        string memory json = vm.readFile(path);\n        bytes memory transactionDetails = json.parseRaw(\".transactions[0].tx\");\n        RawTx1559Detail memory rawTxDetail = abi.decode(transactionDetails, (RawTx1559Detail));\n        Tx1559Detail memory txDetail = rawToConvertedEIP1559Detail(rawTxDetail);\n        assertEq(txDetail.from, 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266);\n        assertEq(txDetail.to, 0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512);\n        assertEq(\n            txDetail.data,\n            hex\"23e99187000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000013370000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000004\"\n        );\n        assertEq(txDetail.nonce, 3);\n        assertEq(txDetail.txType, 2);\n        assertEq(txDetail.gas, 29625);\n        assertEq(txDetail.value, 0);\n    }\n\n    function testReadEIP1559Transaction() public view {\n        string memory root = vm.projectRoot();\n        string memory path = string.concat(root, \"/test/fixtures/broadcast.log.json\");\n        uint256 index = 0;\n        Tx1559 memory transaction = readTx1559(path, index);\n        transaction;\n    }\n\n    function testReadEIP1559Transactions() public view {\n        string memory root = vm.projectRoot();\n        string memory path = string.concat(root, \"/test/fixtures/broadcast.log.json\");\n        Tx1559[] memory transactions = readTx1559s(path);\n        transactions;\n    }\n\n    function testReadReceipt() public {\n        string memory root = vm.projectRoot();\n        string memory path = string.concat(root, \"/test/fixtures/broadcast.log.json\");\n        uint256 index = 5;\n        Receipt memory receipt = readReceipt(path, index);\n        assertEq(\n            receipt.logsBloom,\n            hex\"00000000000800000000000000000010000000000000000000000000000180000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100\"\n        );\n    }\n\n    function testReadReceipts() public view {\n        string memory root = vm.projectRoot();\n        string memory path = string.concat(root, \"/test/fixtures/broadcast.log.json\");\n        Receipt[] memory receipts = readReceipts(path);\n        receipts;\n    }\n\n    function testGasMeteringModifier() public {\n        uint256 gas_start_normal = gasleft();\n        addInLoop();\n        uint256 gas_used_normal = gas_start_normal - gasleft();\n\n        uint256 gas_start_single = gasleft();\n        addInLoopNoGas();\n        uint256 gas_used_single = gas_start_single - gasleft();\n\n        uint256 gas_start_double = gasleft();\n        addInLoopNoGasNoGas();\n        uint256 gas_used_double = gas_start_double - gasleft();\n\n        emit log_named_uint(\"Normal gas\", gas_used_normal);\n        emit log_named_uint(\"Single modifier gas\", gas_used_single);\n        emit log_named_uint(\"Double modifier  gas\", gas_used_double);\n        assertTrue(gas_used_double + gas_used_single < gas_used_normal);\n    }\n\n    function addInLoop() internal pure returns (uint256) {\n        uint256 b;\n        for (uint256 i; i < 10000; i++) {\n            b += i;\n        }\n        return b;\n    }\n\n    function addInLoopNoGas() internal noGasMetering returns (uint256) {\n        return addInLoop();\n    }\n\n    function addInLoopNoGasNoGas() internal noGasMetering returns (uint256) {\n        return addInLoopNoGas();\n    }\n\n    function bytesToUint_test(bytes memory b) private pure returns (uint256) {\n        uint256 number;\n        for (uint256 i = 0; i < b.length; i++) {\n            number = number + uint256(uint8(b[i])) * (2 ** (8 * (b.length - (i + 1))));\n        }\n        return number;\n    }\n\n    function testAssumeNoPrecompiles(address addr) external {\n        assumeNoPrecompiles(addr, getChain(\"optimism_goerli\").chainId);\n        assertTrue(\n            addr < address(1) || (addr > address(9) && addr < address(0x4200000000000000000000000000000000000000))\n                || addr > address(0x4200000000000000000000000000000000000800)\n        );\n    }\n\n    function testAssumePayable() external {\n        // all should revert since these addresses are not payable\n\n        // VM address\n        vm.expectRevert();\n        assumePayable(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n        // Console address\n        vm.expectRevert();\n        assumePayable(0x000000000000000000636F6e736F6c652e6c6f67);\n\n        // Create2Deployer\n        vm.expectRevert();\n        assumePayable(0x4e59b44847b379578588920cA78FbF26c0B4956C);\n    }\n\n    function testAssumePayable(address addr) external {\n        assumePayable(addr);\n        assertTrue(\n            addr != 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D && addr != 0x000000000000000000636F6e736F6c652e6c6f67\n                && addr != 0x4e59b44847b379578588920cA78FbF26c0B4956C\n        );\n    }\n}\n\ncontract StdCheatsMock is StdCheats {\n    // We deploy a mock version so we can properly test expected reverts.\n    function assumeNoBlacklisted_(address token, address addr) external {\n        return assumeNoBlacklisted(token, addr);\n    }\n}\n\ncontract StdCheatsForkTest is Test {\n    address internal constant SHIB = 0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE;\n    address internal constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address internal constant USDC_BLACKLISTED_USER = 0x1E34A77868E19A6647b1f2F47B51ed72dEDE95DD;\n    address internal constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    address internal constant USDT_BLACKLISTED_USER = 0x8f8a8F4B54a2aAC7799d7bc81368aC27b852822A;\n\n    // We deploy a mock version so we can properly test the revert.\n    StdCheatsMock private stdCheats = new StdCheatsMock();\n\n    function setUp() public {\n        // All tests of the `assumeNoBlacklisted` method are fork tests using live contracts.\n        vm.createSelectFork({urlOrAlias: \"mainnet\", blockNumber: 16_428_900});\n    }\n\n    function testCannotAssumeNoBlacklisted_EOA() external {\n        address eoa = vm.addr({privateKey: 1});\n        vm.expectRevert(\"StdCheats assumeNoBlacklisted(address,address): Token address is not a contract.\");\n        assumeNoBlacklisted(eoa, address(0));\n    }\n\n    function testAssumeNoBlacklisted_TokenWithoutBlacklist(address addr) external {\n        assumeNoBlacklisted(SHIB, addr);\n        assertTrue(true);\n    }\n\n    function testAssumeNoBlacklisted_USDC() external {\n        vm.expectRevert();\n        stdCheats.assumeNoBlacklisted_(USDC, USDC_BLACKLISTED_USER);\n    }\n\n    function testAssumeNoBlacklisted_USDC(address addr) external {\n        assumeNoBlacklisted(USDC, addr);\n        assertFalse(USDCLike(USDC).isBlacklisted(addr));\n    }\n\n    function testAssumeNoBlacklisted_USDT() external {\n        vm.expectRevert();\n        stdCheats.assumeNoBlacklisted_(USDT, USDT_BLACKLISTED_USER);\n    }\n\n    function testAssumeNoBlacklisted_USDT(address addr) external {\n        assumeNoBlacklisted(USDT, addr);\n        assertFalse(USDTLike(USDT).isBlackListed(addr));\n    }\n}\n\ncontract Bar {\n    constructor() payable {\n        /// `DEAL` STDCHEAT\n        totalSupply = 10000e18;\n        balanceOf[address(this)] = totalSupply;\n    }\n\n    /// `HOAX` and `CHANGEPRANK` STDCHEATS\n    function bar(address expectedSender) public payable {\n        require(msg.sender == expectedSender, \"!prank\");\n    }\n\n    function origin(address expectedSender) public payable {\n        require(msg.sender == expectedSender, \"!prank\");\n        require(tx.origin == expectedSender, \"!prank\");\n    }\n\n    function origin(address expectedSender, address expectedOrigin) public payable {\n        require(msg.sender == expectedSender, \"!prank\");\n        require(tx.origin == expectedOrigin, \"!prank\");\n    }\n\n    /// `DEAL` STDCHEAT\n    mapping(address => uint256) public balanceOf;\n    uint256 public totalSupply;\n}\n\ncontract BarERC1155 {\n    constructor() payable {\n        /// `DEALERC1155` STDCHEAT\n        _totalSupply[0] = 10000e18;\n        _balances[0][address(this)] = _totalSupply[0];\n    }\n\n    function balanceOf(address account, uint256 id) public view virtual returns (uint256) {\n        return _balances[id][account];\n    }\n\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    /// `DEALERC1155` STDCHEAT\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n    mapping(uint256 => uint256) private _totalSupply;\n}\n\ncontract BarERC721 {\n    constructor() payable {\n        /// `DEALERC721` STDCHEAT\n        _owners[1] = address(1);\n        _balances[address(1)] = 1;\n        _owners[2] = address(this);\n        _owners[3] = address(this);\n        _balances[address(this)] = 2;\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        return _balances[owner];\n    }\n\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        address owner = _owners[tokenId];\n        return owner;\n    }\n\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n}\n\ninterface USDCLike {\n    function isBlacklisted(address) external view returns (bool);\n}\n\ninterface USDTLike {\n    function isBlackListed(address) external view returns (bool);\n}\n\ncontract RevertingContract {\n    constructor() {\n        revert();\n    }\n}\n"},"hedge/lib/forge-std/test/StdError.t.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../src/StdError.sol\";\nimport \"../src/Test.sol\";\n\ncontract StdErrorsTest is Test {\n    ErrorsTest test;\n\n    function setUp() public {\n        test = new ErrorsTest();\n    }\n\n    function testExpectAssertion() public {\n        vm.expectRevert(stdError.assertionError);\n        test.assertionError();\n    }\n\n    function testExpectArithmetic() public {\n        vm.expectRevert(stdError.arithmeticError);\n        test.arithmeticError(10);\n    }\n\n    function testExpectDiv() public {\n        vm.expectRevert(stdError.divisionError);\n        test.divError(0);\n    }\n\n    function testExpectMod() public {\n        vm.expectRevert(stdError.divisionError);\n        test.modError(0);\n    }\n\n    function testExpectEnum() public {\n        vm.expectRevert(stdError.enumConversionError);\n        test.enumConversion(1);\n    }\n\n    function testExpectEncodeStg() public {\n        vm.expectRevert(stdError.encodeStorageError);\n        test.encodeStgError();\n    }\n\n    function testExpectPop() public {\n        vm.expectRevert(stdError.popError);\n        test.pop();\n    }\n\n    function testExpectOOB() public {\n        vm.expectRevert(stdError.indexOOBError);\n        test.indexOOBError(1);\n    }\n\n    function testExpectMem() public {\n        vm.expectRevert(stdError.memOverflowError);\n        test.mem();\n    }\n\n    function testExpectIntern() public {\n        vm.expectRevert(stdError.zeroVarError);\n        test.intern();\n    }\n}\n\ncontract ErrorsTest {\n    enum T {T1}\n\n    uint256[] public someArr;\n    bytes someBytes;\n\n    function assertionError() public pure {\n        assert(false);\n    }\n\n    function arithmeticError(uint256 a) public pure {\n        a -= 100;\n    }\n\n    function divError(uint256 a) public pure {\n        100 / a;\n    }\n\n    function modError(uint256 a) public pure {\n        100 % a;\n    }\n\n    function enumConversion(uint256 a) public pure {\n        T(a);\n    }\n\n    function encodeStgError() public {\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(someBytes.slot, 1)\n        }\n        keccak256(someBytes);\n    }\n\n    function pop() public {\n        someArr.pop();\n    }\n\n    function indexOOBError(uint256 a) public pure {\n        uint256[] memory t = new uint256[](0);\n        t[a];\n    }\n\n    function mem() public pure {\n        uint256 l = 2 ** 256 / 32;\n        new uint256[](l);\n    }\n\n    function intern() public returns (uint256) {\n        function(uint256) internal returns (uint256) x;\n        x(2);\n        return 7;\n    }\n}\n"},"hedge/lib/forge-std/test/StdMath.t.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../src/StdMath.sol\";\nimport \"../src/Test.sol\";\n\ncontract StdMathTest is Test {\n    function testGetAbs() external {\n        assertEq(stdMath.abs(-50), 50);\n        assertEq(stdMath.abs(50), 50);\n        assertEq(stdMath.abs(-1337), 1337);\n        assertEq(stdMath.abs(0), 0);\n\n        assertEq(stdMath.abs(type(int256).min), (type(uint256).max >> 1) + 1);\n        assertEq(stdMath.abs(type(int256).max), (type(uint256).max >> 1));\n    }\n\n    function testGetAbs_Fuzz(int256 a) external {\n        uint256 manualAbs = getAbs(a);\n\n        uint256 abs = stdMath.abs(a);\n\n        assertEq(abs, manualAbs);\n    }\n\n    function testGetDelta_Uint() external {\n        assertEq(stdMath.delta(uint256(0), uint256(0)), 0);\n        assertEq(stdMath.delta(uint256(0), uint256(1337)), 1337);\n        assertEq(stdMath.delta(uint256(0), type(uint64).max), type(uint64).max);\n        assertEq(stdMath.delta(uint256(0), type(uint128).max), type(uint128).max);\n        assertEq(stdMath.delta(uint256(0), type(uint256).max), type(uint256).max);\n\n        assertEq(stdMath.delta(0, uint256(0)), 0);\n        assertEq(stdMath.delta(1337, uint256(0)), 1337);\n        assertEq(stdMath.delta(type(uint64).max, uint256(0)), type(uint64).max);\n        assertEq(stdMath.delta(type(uint128).max, uint256(0)), type(uint128).max);\n        assertEq(stdMath.delta(type(uint256).max, uint256(0)), type(uint256).max);\n\n        assertEq(stdMath.delta(1337, uint256(1337)), 0);\n        assertEq(stdMath.delta(type(uint256).max, type(uint256).max), 0);\n        assertEq(stdMath.delta(5000, uint256(1250)), 3750);\n    }\n\n    function testGetDelta_Uint_Fuzz(uint256 a, uint256 b) external {\n        uint256 manualDelta;\n        if (a > b) {\n            manualDelta = a - b;\n        } else {\n            manualDelta = b - a;\n        }\n\n        uint256 delta = stdMath.delta(a, b);\n\n        assertEq(delta, manualDelta);\n    }\n\n    function testGetDelta_Int() external {\n        assertEq(stdMath.delta(int256(0), int256(0)), 0);\n        assertEq(stdMath.delta(int256(0), int256(1337)), 1337);\n        assertEq(stdMath.delta(int256(0), type(int64).max), type(uint64).max >> 1);\n        assertEq(stdMath.delta(int256(0), type(int128).max), type(uint128).max >> 1);\n        assertEq(stdMath.delta(int256(0), type(int256).max), type(uint256).max >> 1);\n\n        assertEq(stdMath.delta(0, int256(0)), 0);\n        assertEq(stdMath.delta(1337, int256(0)), 1337);\n        assertEq(stdMath.delta(type(int64).max, int256(0)), type(uint64).max >> 1);\n        assertEq(stdMath.delta(type(int128).max, int256(0)), type(uint128).max >> 1);\n        assertEq(stdMath.delta(type(int256).max, int256(0)), type(uint256).max >> 1);\n\n        assertEq(stdMath.delta(-0, int256(0)), 0);\n        assertEq(stdMath.delta(-1337, int256(0)), 1337);\n        assertEq(stdMath.delta(type(int64).min, int256(0)), (type(uint64).max >> 1) + 1);\n        assertEq(stdMath.delta(type(int128).min, int256(0)), (type(uint128).max >> 1) + 1);\n        assertEq(stdMath.delta(type(int256).min, int256(0)), (type(uint256).max >> 1) + 1);\n\n        assertEq(stdMath.delta(int256(0), -0), 0);\n        assertEq(stdMath.delta(int256(0), -1337), 1337);\n        assertEq(stdMath.delta(int256(0), type(int64).min), (type(uint64).max >> 1) + 1);\n        assertEq(stdMath.delta(int256(0), type(int128).min), (type(uint128).max >> 1) + 1);\n        assertEq(stdMath.delta(int256(0), type(int256).min), (type(uint256).max >> 1) + 1);\n\n        assertEq(stdMath.delta(1337, int256(1337)), 0);\n        assertEq(stdMath.delta(type(int256).max, type(int256).max), 0);\n        assertEq(stdMath.delta(type(int256).min, type(int256).min), 0);\n        assertEq(stdMath.delta(type(int256).min, type(int256).max), type(uint256).max);\n        assertEq(stdMath.delta(5000, int256(1250)), 3750);\n    }\n\n    function testGetDelta_Int_Fuzz(int256 a, int256 b) external {\n        uint256 absA = getAbs(a);\n        uint256 absB = getAbs(b);\n        uint256 absDelta = absA > absB ? absA - absB : absB - absA;\n\n        uint256 manualDelta;\n        if ((a >= 0 && b >= 0) || (a < 0 && b < 0)) {\n            manualDelta = absDelta;\n        }\n        // (a < 0 && b >= 0) || (a >= 0 && b < 0)\n        else {\n            manualDelta = absA + absB;\n        }\n\n        uint256 delta = stdMath.delta(a, b);\n\n        assertEq(delta, manualDelta);\n    }\n\n    function testGetPercentDelta_Uint() external {\n        assertEq(stdMath.percentDelta(uint256(0), uint256(1337)), 1e18);\n        assertEq(stdMath.percentDelta(uint256(0), type(uint64).max), 1e18);\n        assertEq(stdMath.percentDelta(uint256(0), type(uint128).max), 1e18);\n        assertEq(stdMath.percentDelta(uint256(0), type(uint192).max), 1e18);\n\n        assertEq(stdMath.percentDelta(1337, uint256(1337)), 0);\n        assertEq(stdMath.percentDelta(type(uint192).max, type(uint192).max), 0);\n        assertEq(stdMath.percentDelta(0, uint256(2500)), 1e18);\n        assertEq(stdMath.percentDelta(2500, uint256(2500)), 0);\n        assertEq(stdMath.percentDelta(5000, uint256(2500)), 1e18);\n        assertEq(stdMath.percentDelta(7500, uint256(2500)), 2e18);\n\n        vm.expectRevert(stdError.divisionError);\n        stdMath.percentDelta(uint256(1), 0);\n    }\n\n    function testGetPercentDelta_Uint_Fuzz(uint192 a, uint192 b) external {\n        vm.assume(b != 0);\n        uint256 manualDelta;\n        if (a > b) {\n            manualDelta = a - b;\n        } else {\n            manualDelta = b - a;\n        }\n\n        uint256 manualPercentDelta = manualDelta * 1e18 / b;\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        assertEq(percentDelta, manualPercentDelta);\n    }\n\n    function testGetPercentDelta_Int() external {\n        assertEq(stdMath.percentDelta(int256(0), int256(1337)), 1e18);\n        assertEq(stdMath.percentDelta(int256(0), -1337), 1e18);\n        assertEq(stdMath.percentDelta(int256(0), type(int64).min), 1e18);\n        assertEq(stdMath.percentDelta(int256(0), type(int128).min), 1e18);\n        assertEq(stdMath.percentDelta(int256(0), type(int192).min), 1e18);\n        assertEq(stdMath.percentDelta(int256(0), type(int64).max), 1e18);\n        assertEq(stdMath.percentDelta(int256(0), type(int128).max), 1e18);\n        assertEq(stdMath.percentDelta(int256(0), type(int192).max), 1e18);\n\n        assertEq(stdMath.percentDelta(1337, int256(1337)), 0);\n        assertEq(stdMath.percentDelta(type(int192).max, type(int192).max), 0);\n        assertEq(stdMath.percentDelta(type(int192).min, type(int192).min), 0);\n\n        assertEq(stdMath.percentDelta(type(int192).min, type(int192).max), 2e18); // rounds the 1 wei diff down\n        assertEq(stdMath.percentDelta(type(int192).max, type(int192).min), 2e18 - 1); // rounds the 1 wei diff down\n        assertEq(stdMath.percentDelta(0, int256(2500)), 1e18);\n        assertEq(stdMath.percentDelta(2500, int256(2500)), 0);\n        assertEq(stdMath.percentDelta(5000, int256(2500)), 1e18);\n        assertEq(stdMath.percentDelta(7500, int256(2500)), 2e18);\n\n        vm.expectRevert(stdError.divisionError);\n        stdMath.percentDelta(int256(1), 0);\n    }\n\n    function testGetPercentDelta_Int_Fuzz(int192 a, int192 b) external {\n        vm.assume(b != 0);\n        uint256 absA = getAbs(a);\n        uint256 absB = getAbs(b);\n        uint256 absDelta = absA > absB ? absA - absB : absB - absA;\n\n        uint256 manualDelta;\n        if ((a >= 0 && b >= 0) || (a < 0 && b < 0)) {\n            manualDelta = absDelta;\n        }\n        // (a < 0 && b >= 0) || (a >= 0 && b < 0)\n        else {\n            manualDelta = absA + absB;\n        }\n\n        uint256 manualPercentDelta = manualDelta * 1e18 / absB;\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        assertEq(percentDelta, manualPercentDelta);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   HELPERS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function getAbs(int256 a) private pure returns (uint256) {\n        if (a < 0) {\n            return a == type(int256).min ? uint256(type(int256).max) + 1 : uint256(-a);\n        }\n\n        return uint256(a);\n    }\n}\n"},"hedge/lib/forge-std/test/StdStorage.t.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../src/StdStorage.sol\";\nimport \"../src/Test.sol\";\n\ncontract StdStorageTest is Test {\n    using stdStorage for StdStorage;\n\n    StorageTest internal test;\n\n    function setUp() public {\n        test = new StorageTest();\n    }\n\n    function testStorageHidden() public {\n        assertEq(uint256(keccak256(\"my.random.var\")), stdstore.target(address(test)).sig(\"hidden()\").find());\n    }\n\n    function testStorageObvious() public {\n        assertEq(uint256(0), stdstore.target(address(test)).sig(\"exists()\").find());\n    }\n\n    function testStorageCheckedWriteHidden() public {\n        stdstore.target(address(test)).sig(test.hidden.selector).checked_write(100);\n        assertEq(uint256(test.hidden()), 100);\n    }\n\n    function testStorageCheckedWriteObvious() public {\n        stdstore.target(address(test)).sig(test.exists.selector).checked_write(100);\n        assertEq(test.exists(), 100);\n    }\n\n    function testStorageMapStructA() public {\n        uint256 slot =\n            stdstore.target(address(test)).sig(test.map_struct.selector).with_key(address(this)).depth(0).find();\n        assertEq(uint256(keccak256(abi.encode(address(this), 4))), slot);\n    }\n\n    function testStorageMapStructB() public {\n        uint256 slot =\n            stdstore.target(address(test)).sig(test.map_struct.selector).with_key(address(this)).depth(1).find();\n        assertEq(uint256(keccak256(abi.encode(address(this), 4))) + 1, slot);\n    }\n\n    function testStorageDeepMap() public {\n        uint256 slot = stdstore.target(address(test)).sig(test.deep_map.selector).with_key(address(this)).with_key(\n            address(this)\n        ).find();\n        assertEq(uint256(keccak256(abi.encode(address(this), keccak256(abi.encode(address(this), uint256(5)))))), slot);\n    }\n\n    function testStorageCheckedWriteDeepMap() public {\n        stdstore.target(address(test)).sig(test.deep_map.selector).with_key(address(this)).with_key(address(this))\n            .checked_write(100);\n        assertEq(100, test.deep_map(address(this), address(this)));\n    }\n\n    function testStorageDeepMapStructA() public {\n        uint256 slot = stdstore.target(address(test)).sig(test.deep_map_struct.selector).with_key(address(this))\n            .with_key(address(this)).depth(0).find();\n        assertEq(\n            bytes32(uint256(keccak256(abi.encode(address(this), keccak256(abi.encode(address(this), uint256(6)))))) + 0),\n            bytes32(slot)\n        );\n    }\n\n    function testStorageDeepMapStructB() public {\n        uint256 slot = stdstore.target(address(test)).sig(test.deep_map_struct.selector).with_key(address(this))\n            .with_key(address(this)).depth(1).find();\n        assertEq(\n            bytes32(uint256(keccak256(abi.encode(address(this), keccak256(abi.encode(address(this), uint256(6)))))) + 1),\n            bytes32(slot)\n        );\n    }\n\n    function testStorageCheckedWriteDeepMapStructA() public {\n        stdstore.target(address(test)).sig(test.deep_map_struct.selector).with_key(address(this)).with_key(\n            address(this)\n        ).depth(0).checked_write(100);\n        (uint256 a, uint256 b) = test.deep_map_struct(address(this), address(this));\n        assertEq(100, a);\n        assertEq(0, b);\n    }\n\n    function testStorageCheckedWriteDeepMapStructB() public {\n        stdstore.target(address(test)).sig(test.deep_map_struct.selector).with_key(address(this)).with_key(\n            address(this)\n        ).depth(1).checked_write(100);\n        (uint256 a, uint256 b) = test.deep_map_struct(address(this), address(this));\n        assertEq(0, a);\n        assertEq(100, b);\n    }\n\n    function testStorageCheckedWriteMapStructA() public {\n        stdstore.target(address(test)).sig(test.map_struct.selector).with_key(address(this)).depth(0).checked_write(100);\n        (uint256 a, uint256 b) = test.map_struct(address(this));\n        assertEq(a, 100);\n        assertEq(b, 0);\n    }\n\n    function testStorageCheckedWriteMapStructB() public {\n        stdstore.target(address(test)).sig(test.map_struct.selector).with_key(address(this)).depth(1).checked_write(100);\n        (uint256 a, uint256 b) = test.map_struct(address(this));\n        assertEq(a, 0);\n        assertEq(b, 100);\n    }\n\n    function testStorageStructA() public {\n        uint256 slot = stdstore.target(address(test)).sig(test.basic.selector).depth(0).find();\n        assertEq(uint256(7), slot);\n    }\n\n    function testStorageStructB() public {\n        uint256 slot = stdstore.target(address(test)).sig(test.basic.selector).depth(1).find();\n        assertEq(uint256(7) + 1, slot);\n    }\n\n    function testStorageCheckedWriteStructA() public {\n        stdstore.target(address(test)).sig(test.basic.selector).depth(0).checked_write(100);\n        (uint256 a, uint256 b) = test.basic();\n        assertEq(a, 100);\n        assertEq(b, 1337);\n    }\n\n    function testStorageCheckedWriteStructB() public {\n        stdstore.target(address(test)).sig(test.basic.selector).depth(1).checked_write(100);\n        (uint256 a, uint256 b) = test.basic();\n        assertEq(a, 1337);\n        assertEq(b, 100);\n    }\n\n    function testStorageMapAddrFound() public {\n        uint256 slot = stdstore.target(address(test)).sig(test.map_addr.selector).with_key(address(this)).find();\n        assertEq(uint256(keccak256(abi.encode(address(this), uint256(1)))), slot);\n    }\n\n    function testStorageMapUintFound() public {\n        uint256 slot = stdstore.target(address(test)).sig(test.map_uint.selector).with_key(100).find();\n        assertEq(uint256(keccak256(abi.encode(100, uint256(2)))), slot);\n    }\n\n    function testStorageCheckedWriteMapUint() public {\n        stdstore.target(address(test)).sig(test.map_uint.selector).with_key(100).checked_write(100);\n        assertEq(100, test.map_uint(100));\n    }\n\n    function testStorageCheckedWriteMapAddr() public {\n        stdstore.target(address(test)).sig(test.map_addr.selector).with_key(address(this)).checked_write(100);\n        assertEq(100, test.map_addr(address(this)));\n    }\n\n    function testStorageCheckedWriteMapBool() public {\n        stdstore.target(address(test)).sig(test.map_bool.selector).with_key(address(this)).checked_write(true);\n        assertTrue(test.map_bool(address(this)));\n    }\n\n    function testFailStorageCheckedWriteMapPacked() public {\n        // expect PackedSlot error but not external call so cant expectRevert\n        stdstore.target(address(test)).sig(test.read_struct_lower.selector).with_key(address(uint160(1337)))\n            .checked_write(100);\n    }\n\n    function testStorageCheckedWriteMapPackedSuccess() public {\n        uint256 full = test.map_packed(address(1337));\n        // keep upper 128, set lower 128 to 1337\n        full = (full & (uint256((1 << 128) - 1) << 128)) | 1337;\n        stdstore.target(address(test)).sig(test.map_packed.selector).with_key(address(uint160(1337))).checked_write(\n            full\n        );\n        assertEq(1337, test.read_struct_lower(address(1337)));\n    }\n\n    function testFailStorageConst() public {\n        // vm.expectRevert(abi.encodeWithSignature(\"NotStorage(bytes4)\", bytes4(keccak256(\"const()\"))));\n        stdstore.target(address(test)).sig(\"const()\").find();\n    }\n\n    function testFailStorageNativePack() public {\n        stdstore.target(address(test)).sig(test.tA.selector).find();\n        stdstore.target(address(test)).sig(test.tB.selector).find();\n\n        // these both would fail\n        stdstore.target(address(test)).sig(test.tC.selector).find();\n        stdstore.target(address(test)).sig(test.tD.selector).find();\n    }\n\n    function testStorageReadBytes32() public {\n        bytes32 val = stdstore.target(address(test)).sig(test.tE.selector).read_bytes32();\n        assertEq(val, hex\"1337\");\n    }\n\n    function testStorageReadBool_False() public {\n        bool val = stdstore.target(address(test)).sig(test.tB.selector).read_bool();\n        assertEq(val, false);\n    }\n\n    function testStorageReadBool_True() public {\n        bool val = stdstore.target(address(test)).sig(test.tH.selector).read_bool();\n        assertEq(val, true);\n    }\n\n    function testStorageReadBool_Revert() public {\n        vm.expectRevert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n        this.readNonBoolValue();\n    }\n\n    function readNonBoolValue() public {\n        stdstore.target(address(test)).sig(test.tE.selector).read_bool();\n    }\n\n    function testStorageReadAddress() public {\n        address val = stdstore.target(address(test)).sig(test.tF.selector).read_address();\n        assertEq(val, address(1337));\n    }\n\n    function testStorageReadUint() public {\n        uint256 val = stdstore.target(address(test)).sig(test.exists.selector).read_uint();\n        assertEq(val, 1);\n    }\n\n    function testStorageReadInt() public {\n        int256 val = stdstore.target(address(test)).sig(test.tG.selector).read_int();\n        assertEq(val, type(int256).min);\n    }\n}\n\ncontract StorageTest {\n    uint256 public exists = 1;\n    mapping(address => uint256) public map_addr;\n    mapping(uint256 => uint256) public map_uint;\n    mapping(address => uint256) public map_packed;\n    mapping(address => UnpackedStruct) public map_struct;\n    mapping(address => mapping(address => uint256)) public deep_map;\n    mapping(address => mapping(address => UnpackedStruct)) public deep_map_struct;\n    UnpackedStruct public basic;\n\n    uint248 public tA;\n    bool public tB;\n\n    bool public tC = false;\n    uint248 public tD = 1;\n\n    struct UnpackedStruct {\n        uint256 a;\n        uint256 b;\n    }\n\n    mapping(address => bool) public map_bool;\n\n    bytes32 public tE = hex\"1337\";\n    address public tF = address(1337);\n    int256 public tG = type(int256).min;\n    bool public tH = true;\n\n    constructor() {\n        basic = UnpackedStruct({a: 1337, b: 1337});\n\n        uint256 two = (1 << 128) | 1;\n        map_packed[msg.sender] = two;\n        map_packed[address(uint160(1337))] = 1 << 128;\n    }\n\n    function read_struct_upper(address who) public view returns (uint256) {\n        return map_packed[who] >> 128;\n    }\n\n    function read_struct_lower(address who) public view returns (uint256) {\n        return map_packed[who] & ((1 << 128) - 1);\n    }\n\n    function hidden() public view returns (bytes32 t) {\n        bytes32 slot = keccak256(\"my.random.var\");\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := sload(slot)\n        }\n    }\n\n    function const() public pure returns (bytes32 t) {\n        t = bytes32(hex\"1337\");\n    }\n}\n"},"hedge/lib/forge-std/test/StdStyle.t.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../src/Test.sol\";\n\ncontract StdStyleTest is Test {\n    function testStyleColor() public pure {\n        console2.log(StdStyle.red(\"StdStyle.red String Test\"));\n        console2.log(StdStyle.red(uint256(10e18)));\n        console2.log(StdStyle.red(int256(-10e18)));\n        console2.log(StdStyle.red(true));\n        console2.log(StdStyle.red(address(0)));\n        console2.log(StdStyle.redBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.redBytes32(\"StdStyle.redBytes32\"));\n        console2.log(StdStyle.green(\"StdStyle.green String Test\"));\n        console2.log(StdStyle.green(uint256(10e18)));\n        console2.log(StdStyle.green(int256(-10e18)));\n        console2.log(StdStyle.green(true));\n        console2.log(StdStyle.green(address(0)));\n        console2.log(StdStyle.greenBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.greenBytes32(\"StdStyle.greenBytes32\"));\n        console2.log(StdStyle.yellow(\"StdStyle.yellow String Test\"));\n        console2.log(StdStyle.yellow(uint256(10e18)));\n        console2.log(StdStyle.yellow(int256(-10e18)));\n        console2.log(StdStyle.yellow(true));\n        console2.log(StdStyle.yellow(address(0)));\n        console2.log(StdStyle.yellowBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.yellowBytes32(\"StdStyle.yellowBytes32\"));\n        console2.log(StdStyle.blue(\"StdStyle.blue String Test\"));\n        console2.log(StdStyle.blue(uint256(10e18)));\n        console2.log(StdStyle.blue(int256(-10e18)));\n        console2.log(StdStyle.blue(true));\n        console2.log(StdStyle.blue(address(0)));\n        console2.log(StdStyle.blueBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.blueBytes32(\"StdStyle.blueBytes32\"));\n        console2.log(StdStyle.magenta(\"StdStyle.magenta String Test\"));\n        console2.log(StdStyle.magenta(uint256(10e18)));\n        console2.log(StdStyle.magenta(int256(-10e18)));\n        console2.log(StdStyle.magenta(true));\n        console2.log(StdStyle.magenta(address(0)));\n        console2.log(StdStyle.magentaBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.magentaBytes32(\"StdStyle.magentaBytes32\"));\n        console2.log(StdStyle.cyan(\"StdStyle.cyan String Test\"));\n        console2.log(StdStyle.cyan(uint256(10e18)));\n        console2.log(StdStyle.cyan(int256(-10e18)));\n        console2.log(StdStyle.cyan(true));\n        console2.log(StdStyle.cyan(address(0)));\n        console2.log(StdStyle.cyanBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.cyanBytes32(\"StdStyle.cyanBytes32\"));\n    }\n\n    function testStyleFontWeight() public pure {\n        console2.log(StdStyle.bold(\"StdStyle.bold String Test\"));\n        console2.log(StdStyle.bold(uint256(10e18)));\n        console2.log(StdStyle.bold(int256(-10e18)));\n        console2.log(StdStyle.bold(address(0)));\n        console2.log(StdStyle.bold(true));\n        console2.log(StdStyle.boldBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.boldBytes32(\"StdStyle.boldBytes32\"));\n        console2.log(StdStyle.dim(\"StdStyle.dim String Test\"));\n        console2.log(StdStyle.dim(uint256(10e18)));\n        console2.log(StdStyle.dim(int256(-10e18)));\n        console2.log(StdStyle.dim(address(0)));\n        console2.log(StdStyle.dim(true));\n        console2.log(StdStyle.dimBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.dimBytes32(\"StdStyle.dimBytes32\"));\n        console2.log(StdStyle.italic(\"StdStyle.italic String Test\"));\n        console2.log(StdStyle.italic(uint256(10e18)));\n        console2.log(StdStyle.italic(int256(-10e18)));\n        console2.log(StdStyle.italic(address(0)));\n        console2.log(StdStyle.italic(true));\n        console2.log(StdStyle.italicBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.italicBytes32(\"StdStyle.italicBytes32\"));\n        console2.log(StdStyle.underline(\"StdStyle.underline String Test\"));\n        console2.log(StdStyle.underline(uint256(10e18)));\n        console2.log(StdStyle.underline(int256(-10e18)));\n        console2.log(StdStyle.underline(address(0)));\n        console2.log(StdStyle.underline(true));\n        console2.log(StdStyle.underlineBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.underlineBytes32(\"StdStyle.underlineBytes32\"));\n        console2.log(StdStyle.inverse(\"StdStyle.inverse String Test\"));\n        console2.log(StdStyle.inverse(uint256(10e18)));\n        console2.log(StdStyle.inverse(int256(-10e18)));\n        console2.log(StdStyle.inverse(address(0)));\n        console2.log(StdStyle.inverse(true));\n        console2.log(StdStyle.inverseBytes(hex\"7109709ECfa91a80626fF3989D68f67F5b1DD12D\"));\n        console2.log(StdStyle.inverseBytes32(\"StdStyle.inverseBytes32\"));\n    }\n\n    function testStyleCombined() public pure {\n        console2.log(StdStyle.red(StdStyle.bold(\"Red Bold String Test\")));\n        console2.log(StdStyle.green(StdStyle.dim(uint256(10e18))));\n        console2.log(StdStyle.yellow(StdStyle.italic(int256(-10e18))));\n        console2.log(StdStyle.blue(StdStyle.underline(address(0))));\n        console2.log(StdStyle.magenta(StdStyle.inverse(true)));\n    }\n\n    function testStyleCustom() public pure {\n        console2.log(h1(\"Custom Style 1\"));\n        console2.log(h2(\"Custom Style 2\"));\n    }\n\n    function h1(string memory a) private pure returns (string memory) {\n        return StdStyle.cyan(StdStyle.inverse(StdStyle.bold(a)));\n    }\n\n    function h2(string memory a) private pure returns (string memory) {\n        return StdStyle.magenta(StdStyle.bold(StdStyle.underline(a)));\n    }\n}\n"},"hedge/lib/forge-std/test/StdUtils.t.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../src/Test.sol\";\n\ncontract StdUtilsMock is StdUtils {\n    // We deploy a mock version so we can properly test expected reverts.\n    function getTokenBalances_(address token, address[] memory addresses)\n        external\n        returns (uint256[] memory balances)\n    {\n        return getTokenBalances(token, addresses);\n    }\n}\n\ncontract StdUtilsTest is Test {\n    /*//////////////////////////////////////////////////////////////////////////\n                                     BOUND UINT\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testBound() public {\n        assertEq(bound(uint256(5), 0, 4), 0);\n        assertEq(bound(uint256(0), 69, 69), 69);\n        assertEq(bound(uint256(0), 68, 69), 68);\n        assertEq(bound(uint256(10), 150, 190), 174);\n        assertEq(bound(uint256(300), 2800, 3200), 3107);\n        assertEq(bound(uint256(9999), 1337, 6666), 4669);\n    }\n\n    function testBound_WithinRange() public {\n        assertEq(bound(uint256(51), 50, 150), 51);\n        assertEq(bound(uint256(51), 50, 150), bound(bound(uint256(51), 50, 150), 50, 150));\n        assertEq(bound(uint256(149), 50, 150), 149);\n        assertEq(bound(uint256(149), 50, 150), bound(bound(uint256(149), 50, 150), 50, 150));\n    }\n\n    function testBound_EdgeCoverage() public {\n        assertEq(bound(uint256(0), 50, 150), 50);\n        assertEq(bound(uint256(1), 50, 150), 51);\n        assertEq(bound(uint256(2), 50, 150), 52);\n        assertEq(bound(uint256(3), 50, 150), 53);\n        assertEq(bound(type(uint256).max, 50, 150), 150);\n        assertEq(bound(type(uint256).max - 1, 50, 150), 149);\n        assertEq(bound(type(uint256).max - 2, 50, 150), 148);\n        assertEq(bound(type(uint256).max - 3, 50, 150), 147);\n    }\n\n    function testBound_DistributionIsEven(uint256 min, uint256 size) public {\n        size = size % 100 + 1;\n        min = bound(min, UINT256_MAX / 2, UINT256_MAX / 2 + size);\n        uint256 max = min + size - 1;\n        uint256 result;\n\n        for (uint256 i = 1; i <= size * 4; ++i) {\n            // x > max\n            result = bound(max + i, min, max);\n            assertEq(result, min + (i - 1) % size);\n            // x < min\n            result = bound(min - i, min, max);\n            assertEq(result, max - (i - 1) % size);\n        }\n    }\n\n    function testBound(uint256 num, uint256 min, uint256 max) public {\n        if (min > max) (min, max) = (max, min);\n\n        uint256 result = bound(num, min, max);\n\n        assertGe(result, min);\n        assertLe(result, max);\n        assertEq(result, bound(result, min, max));\n        if (num >= min && num <= max) assertEq(result, num);\n    }\n\n    function testBoundUint256Max() public {\n        assertEq(bound(0, type(uint256).max - 1, type(uint256).max), type(uint256).max - 1);\n        assertEq(bound(1, type(uint256).max - 1, type(uint256).max), type(uint256).max);\n    }\n\n    function testCannotBoundMaxLessThanMin() public {\n        vm.expectRevert(bytes(\"StdUtils bound(uint256,uint256,uint256): Max is less than min.\"));\n        bound(uint256(5), 100, 10);\n    }\n\n    function testCannotBoundMaxLessThanMin(uint256 num, uint256 min, uint256 max) public {\n        vm.assume(min > max);\n        vm.expectRevert(bytes(\"StdUtils bound(uint256,uint256,uint256): Max is less than min.\"));\n        bound(num, min, max);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     BOUND INT\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testBoundInt() public {\n        assertEq(bound(-3, 0, 4), 2);\n        assertEq(bound(0, -69, -69), -69);\n        assertEq(bound(0, -69, -68), -68);\n        assertEq(bound(-10, 150, 190), 154);\n        assertEq(bound(-300, 2800, 3200), 2908);\n        assertEq(bound(9999, -1337, 6666), 1995);\n    }\n\n    function testBoundInt_WithinRange() public {\n        assertEq(bound(51, -50, 150), 51);\n        assertEq(bound(51, -50, 150), bound(bound(51, -50, 150), -50, 150));\n        assertEq(bound(149, -50, 150), 149);\n        assertEq(bound(149, -50, 150), bound(bound(149, -50, 150), -50, 150));\n    }\n\n    function testBoundInt_EdgeCoverage() public {\n        assertEq(bound(type(int256).min, -50, 150), -50);\n        assertEq(bound(type(int256).min + 1, -50, 150), -49);\n        assertEq(bound(type(int256).min + 2, -50, 150), -48);\n        assertEq(bound(type(int256).min + 3, -50, 150), -47);\n        assertEq(bound(type(int256).min, 10, 150), 10);\n        assertEq(bound(type(int256).min + 1, 10, 150), 11);\n        assertEq(bound(type(int256).min + 2, 10, 150), 12);\n        assertEq(bound(type(int256).min + 3, 10, 150), 13);\n\n        assertEq(bound(type(int256).max, -50, 150), 150);\n        assertEq(bound(type(int256).max - 1, -50, 150), 149);\n        assertEq(bound(type(int256).max - 2, -50, 150), 148);\n        assertEq(bound(type(int256).max - 3, -50, 150), 147);\n        assertEq(bound(type(int256).max, -50, -10), -10);\n        assertEq(bound(type(int256).max - 1, -50, -10), -11);\n        assertEq(bound(type(int256).max - 2, -50, -10), -12);\n        assertEq(bound(type(int256).max - 3, -50, -10), -13);\n    }\n\n    function testBoundInt_DistributionIsEven(int256 min, uint256 size) public {\n        size = size % 100 + 1;\n        min = bound(min, -int256(size / 2), int256(size - size / 2));\n        int256 max = min + int256(size) - 1;\n        int256 result;\n\n        for (uint256 i = 1; i <= size * 4; ++i) {\n            // x > max\n            result = bound(max + int256(i), min, max);\n            assertEq(result, min + int256((i - 1) % size));\n            // x < min\n            result = bound(min - int256(i), min, max);\n            assertEq(result, max - int256((i - 1) % size));\n        }\n    }\n\n    function testBoundInt(int256 num, int256 min, int256 max) public {\n        if (min > max) (min, max) = (max, min);\n\n        int256 result = bound(num, min, max);\n\n        assertGe(result, min);\n        assertLe(result, max);\n        assertEq(result, bound(result, min, max));\n        if (num >= min && num <= max) assertEq(result, num);\n    }\n\n    function testBoundIntInt256Max() public {\n        assertEq(bound(0, type(int256).max - 1, type(int256).max), type(int256).max - 1);\n        assertEq(bound(1, type(int256).max - 1, type(int256).max), type(int256).max);\n    }\n\n    function testBoundIntInt256Min() public {\n        assertEq(bound(0, type(int256).min, type(int256).min + 1), type(int256).min);\n        assertEq(bound(1, type(int256).min, type(int256).min + 1), type(int256).min + 1);\n    }\n\n    function testCannotBoundIntMaxLessThanMin() public {\n        vm.expectRevert(bytes(\"StdUtils bound(int256,int256,int256): Max is less than min.\"));\n        bound(-5, 100, 10);\n    }\n\n    function testCannotBoundIntMaxLessThanMin(int256 num, int256 min, int256 max) public {\n        vm.assume(min > max);\n        vm.expectRevert(bytes(\"StdUtils bound(int256,int256,int256): Max is less than min.\"));\n        bound(num, min, max);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                BOUND PRIVATE KEY\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testBoundPrivateKey() public {\n        assertEq(boundPrivateKey(0), 1);\n        assertEq(boundPrivateKey(1), 1);\n        assertEq(boundPrivateKey(300), 300);\n        assertEq(boundPrivateKey(9999), 9999);\n        assertEq(boundPrivateKey(SECP256K1_ORDER - 1), SECP256K1_ORDER - 1);\n        assertEq(boundPrivateKey(SECP256K1_ORDER), 1);\n        assertEq(boundPrivateKey(SECP256K1_ORDER + 1), 2);\n        assertEq(boundPrivateKey(UINT256_MAX), UINT256_MAX & SECP256K1_ORDER - 1); // x&y is equivalent to x-x%y\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   BYTES TO UINT\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testBytesToUint() external {\n        bytes memory maxUint = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n        bytes memory two = hex\"02\";\n        bytes memory millionEther = hex\"d3c21bcecceda1000000\";\n\n        assertEq(bytesToUint(maxUint), type(uint256).max);\n        assertEq(bytesToUint(two), 2);\n        assertEq(bytesToUint(millionEther), 1_000_000 ether);\n    }\n\n    function testCannotConvertGT32Bytes() external {\n        bytes memory thirty3Bytes = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n        vm.expectRevert(\"StdUtils bytesToUint(bytes): Bytes length exceeds 32.\");\n        bytesToUint(thirty3Bytes);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                               COMPUTE CREATE ADDRESS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testComputeCreateAddress() external {\n        address deployer = 0x6C9FC64A53c1b71FB3f9Af64d1ae3A4931A5f4E9;\n        uint256 nonce = 14;\n        address createAddress = computeCreateAddress(deployer, nonce);\n        assertEq(createAddress, 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                              COMPUTE CREATE2 ADDRESS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testComputeCreate2Address() external {\n        bytes32 salt = bytes32(uint256(31415));\n        bytes32 initcodeHash = keccak256(abi.encode(0x6080));\n        address deployer = 0x6C9FC64A53c1b71FB3f9Af64d1ae3A4931A5f4E9;\n        address create2Address = computeCreate2Address(salt, initcodeHash, deployer);\n        assertEq(create2Address, 0xB147a5d25748fda14b463EB04B111027C290f4d3);\n    }\n\n    function testComputeCreate2AddressWithDefaultDeployer() external {\n        bytes32 salt = 0xc290c670fde54e5ef686f9132cbc8711e76a98f0333a438a92daa442c71403c0;\n        bytes32 initcodeHash = hashInitCode(hex\"6080\", \"\");\n        assertEq(initcodeHash, 0x1a578b7a4b0b5755db6d121b4118d4bc68fe170dca840c59bc922f14175a76b0);\n        address create2Address = computeCreate2Address(salt, initcodeHash);\n        assertEq(create2Address, 0xc0ffEe2198a06235aAbFffe5Db0CacF1717f5Ac6);\n    }\n}\n\ncontract StdUtilsForkTest is Test {\n    /*//////////////////////////////////////////////////////////////////////////\n                                  GET TOKEN BALANCES\n    //////////////////////////////////////////////////////////////////////////*/\n\n    address internal SHIB = 0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE;\n    address internal SHIB_HOLDER_0 = 0x855F5981e831D83e6A4b4EBFCAdAa68D92333170;\n    address internal SHIB_HOLDER_1 = 0x8F509A90c2e47779cA408Fe00d7A72e359229AdA;\n    address internal SHIB_HOLDER_2 = 0x0e3bbc0D04fF62211F71f3e4C45d82ad76224385;\n\n    address internal USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address internal USDC_HOLDER_0 = 0xDa9CE944a37d218c3302F6B82a094844C6ECEb17;\n    address internal USDC_HOLDER_1 = 0x3e67F4721E6d1c41a015f645eFa37BEd854fcf52;\n\n    function setUp() public {\n        // All tests of the `getTokenBalances` method are fork tests using live contracts.\n        vm.createSelectFork({urlOrAlias: \"mainnet\", blockNumber: 16_428_900});\n    }\n\n    function testCannotGetTokenBalances_NonTokenContract() external {\n        // We deploy a mock version so we can properly test the revert.\n        StdUtilsMock stdUtils = new StdUtilsMock();\n\n        // The UniswapV2Factory contract has neither a `balanceOf` function nor a fallback function,\n        // so the `balanceOf` call should revert.\n        address token = address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\n        address[] memory addresses = new address[](1);\n        addresses[0] = USDC_HOLDER_0;\n\n        vm.expectRevert(\"Multicall3: call failed\");\n        stdUtils.getTokenBalances_(token, addresses);\n    }\n\n    function testCannotGetTokenBalances_EOA() external {\n        address eoa = vm.addr({privateKey: 1});\n        address[] memory addresses = new address[](1);\n        addresses[0] = USDC_HOLDER_0;\n        vm.expectRevert(\"StdUtils getTokenBalances(address,address[]): Token address is not a contract.\");\n        getTokenBalances(eoa, addresses);\n    }\n\n    function testGetTokenBalances_Empty() external {\n        address[] memory addresses = new address[](0);\n        uint256[] memory balances = getTokenBalances(USDC, addresses);\n        assertEq(balances.length, 0);\n    }\n\n    function testGetTokenBalances_USDC() external {\n        address[] memory addresses = new address[](2);\n        addresses[0] = USDC_HOLDER_0;\n        addresses[1] = USDC_HOLDER_1;\n        uint256[] memory balances = getTokenBalances(USDC, addresses);\n        assertEq(balances[0], 159_000_000_000_000);\n        assertEq(balances[1], 131_350_000_000_000);\n    }\n\n    function testGetTokenBalances_SHIB() external {\n        address[] memory addresses = new address[](3);\n        addresses[0] = SHIB_HOLDER_0;\n        addresses[1] = SHIB_HOLDER_1;\n        addresses[2] = SHIB_HOLDER_2;\n        uint256[] memory balances = getTokenBalances(SHIB, addresses);\n        assertEq(balances[0], 3_323_256_285_484.42e18);\n        assertEq(balances[1], 1_271_702_771_149.99999928e18);\n        assertEq(balances[2], 606_357_106_247e18);\n    }\n}\n"},"hedge/lib/forge-std/test/compilation/CompilationScript.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport \"../../src/Script.sol\";\n\n// The purpose of this contract is to benchmark compilation time to avoid accidentally introducing\n// a change that results in very long compilation times with via-ir. See https://github.com/foundry-rs/forge-std/issues/207\ncontract CompilationScript is Script {}\n"},"hedge/lib/forge-std/test/compilation/CompilationScriptBase.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport \"../../src/Script.sol\";\n\n// The purpose of this contract is to benchmark compilation time to avoid accidentally introducing\n// a change that results in very long compilation times with via-ir. See https://github.com/foundry-rs/forge-std/issues/207\ncontract CompilationScriptBase is ScriptBase {}\n"},"hedge/lib/forge-std/test/compilation/CompilationTest.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport \"../../src/Test.sol\";\n\n// The purpose of this contract is to benchmark compilation time to avoid accidentally introducing\n// a change that results in very long compilation times with via-ir. See https://github.com/foundry-rs/forge-std/issues/207\ncontract CompilationTest is Test {}\n"},"hedge/lib/forge-std/test/compilation/CompilationTestBase.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport \"../../src/Test.sol\";\n\n// The purpose of this contract is to benchmark compilation time to avoid accidentally introducing\n// a change that results in very long compilation times with via-ir. See https://github.com/foundry-rs/forge-std/issues/207\ncontract CompilationTestBase is TestBase {}\n"},"hedge/lib/solmate/lib/ds-test/demo/demo.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.0;\n\nimport \"../src/test.sol\";\n\ncontract DemoTest is DSTest {\n    function test_this() public pure {\n        require(true);\n    }\n    function test_logs() public {\n        emit log(\"-- log(string)\");\n        emit log(\"a string\");\n\n        emit log(\"-- log_named_uint(string, uint)\");\n        emit log_named_uint(\"uint\", 512);\n\n        emit log(\"-- log_named_int(string, int)\");\n        emit log_named_int(\"int\", -512);\n\n        emit log(\"-- log_named_address(string, address)\");\n        emit log_named_address(\"address\", address(this));\n\n        emit log(\"-- log_named_bytes32(string, bytes32)\");\n        emit log_named_bytes32(\"bytes32\", \"a string\");\n\n        emit log(\"-- log_named_bytes(string, bytes)\");\n        emit log_named_bytes(\"bytes\", hex\"cafefe\");\n\n        emit log(\"-- log_named_string(string, string)\");\n        emit log_named_string(\"string\", \"a string\");\n\n        emit log(\"-- log_named_decimal_uint(string, uint, uint)\");\n        emit log_named_decimal_uint(\"decimal uint\", 1.0e18, 18);\n\n        emit log(\"-- log_named_decimal_int(string, int, uint)\");\n        emit log_named_decimal_int(\"decimal int\", -1.0e18, 18);\n    }\n    event log_old_named_uint(bytes32,uint);\n    function test_old_logs() public {\n        emit log_old_named_uint(\"key\", 500);\n        emit log_named_bytes32(\"bkey\", \"val\");\n    }\n    function test_trace() public view {\n        this.echo(\"string 1\", \"string 2\");\n    }\n    function test_multiline() public {\n        emit log(\"a multiline\\\\nstring\");\n        emit log(\"a multiline string\");\n        emit log_bytes(\"a string\");\n        emit log_bytes(\"a multiline\\nstring\");\n        emit log_bytes(\"a multiline\\\\nstring\");\n        emit logs(hex\"0000\");\n        emit log_named_bytes(\"0x0000\", hex\"0000\");\n        emit logs(hex\"ff\");\n    }\n    function echo(string memory s1, string memory s2) public pure\n        returns (string memory, string memory)\n    {\n        return (s1, s2);\n    }\n\n    function prove_this(uint x) public {\n        emit log_named_uint(\"sym x\", x);\n        assertGt(x + 1, 0);\n    }\n\n    function test_logn() public {\n        assembly {\n            log0(0x01, 0x02)\n            log1(0x01, 0x02, 0x03)\n            log2(0x01, 0x02, 0x03, 0x04)\n            log3(0x01, 0x02, 0x03, 0x04, 0x05)\n        }\n    }\n\n    event MyEvent(uint, uint indexed, uint, uint indexed);\n    function test_events() public {\n        emit MyEvent(1, 2, 3, 4);\n    }\n\n    function test_asserts() public {\n        string memory err = \"this test has failed!\";\n        emit log(\"## assertTrue(bool)\\n\");\n        assertTrue(false);\n        emit log(\"\\n\");\n        assertTrue(false, err);\n\n        emit log(\"\\n## assertEq(address,address)\\n\");\n        assertEq(address(this), msg.sender);\n        emit log(\"\\n\");\n        assertEq(address(this), msg.sender, err);\n\n        emit log(\"\\n## assertEq32(bytes32,bytes32)\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\");\n        emit log(\"\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\", err);\n\n        emit log(\"\\n## assertEq(bytes32,bytes32)\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\");\n        emit log(\"\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\", err);\n\n        emit log(\"\\n## assertEq(uint,uint)\\n\");\n        assertEq(uint(0), 1);\n        emit log(\"\\n\");\n        assertEq(uint(0), 1, err);\n\n        emit log(\"\\n## assertEq(int,int)\\n\");\n        assertEq(-1, -2);\n        emit log(\"\\n\");\n        assertEq(-1, -2, err);\n\n        emit log(\"\\n## assertEqDecimal(int,int,uint)\\n\");\n        assertEqDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertEqDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertEqDecimal(uint,uint,uint)\\n\");\n        assertEqDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertEqDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertGt(uint,uint)\\n\");\n        assertGt(uint(0), 0);\n        emit log(\"\\n\");\n        assertGt(uint(0), 0, err);\n\n        emit log(\"\\n## assertGt(int,int)\\n\");\n        assertGt(-1, -1);\n        emit log(\"\\n\");\n        assertGt(-1, -1, err);\n\n        emit log(\"\\n## assertGtDecimal(int,int,uint)\\n\");\n        assertGtDecimal(-2.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertGtDecimal(-2.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertGtDecimal(uint,uint,uint)\\n\");\n        assertGtDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertGtDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertGe(uint,uint)\\n\");\n        assertGe(uint(0), 1);\n        emit log(\"\\n\");\n        assertGe(uint(0), 1, err);\n\n        emit log(\"\\n## assertGe(int,int)\\n\");\n        assertGe(-1, 0);\n        emit log(\"\\n\");\n        assertGe(-1, 0, err);\n\n        emit log(\"\\n## assertGeDecimal(int,int,uint)\\n\");\n        assertGeDecimal(-2.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertGeDecimal(-2.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertGeDecimal(uint,uint,uint)\\n\");\n        assertGeDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertGeDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertLt(uint,uint)\\n\");\n        assertLt(uint(0), 0);\n        emit log(\"\\n\");\n        assertLt(uint(0), 0, err);\n\n        emit log(\"\\n## assertLt(int,int)\\n\");\n        assertLt(-1, -1);\n        emit log(\"\\n\");\n        assertLt(-1, -1, err);\n\n        emit log(\"\\n## assertLtDecimal(int,int,uint)\\n\");\n        assertLtDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertLtDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertLtDecimal(uint,uint,uint)\\n\");\n        assertLtDecimal(uint(2.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertLtDecimal(uint(2.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertLe(uint,uint)\\n\");\n        assertLe(uint(1), 0);\n        emit log(\"\\n\");\n        assertLe(uint(1), 0, err);\n\n        emit log(\"\\n## assertLe(int,int)\\n\");\n        assertLe(0, -1);\n        emit log(\"\\n\");\n        assertLe(0, -1, err);\n\n        emit log(\"\\n## assertLeDecimal(int,int,uint)\\n\");\n        assertLeDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertLeDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertLeDecimal(uint,uint,uint)\\n\");\n        assertLeDecimal(uint(2.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertLeDecimal(uint(2.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertEq(string,string)\\n\");\n        string memory s1 = \"string 1\";\n        string memory s2 = \"string 2\";\n        assertEq(s1, s2);\n        emit log(\"\\n\");\n        assertEq(s1, s2, err);\n\n        emit log(\"\\n## assertEq0(bytes,bytes)\\n\");\n        assertEq0(hex\"abcdef01\", hex\"abcdef02\");\n        emit log(\"\\n\");\n        assertEq0(hex\"abcdef01\", hex\"abcdef02\", err);\n    }\n}\n\ncontract DemoTestWithSetUp {\n    function setUp() public {\n    }\n    function test_pass() public pure {\n    }\n}\n"},"hedge/lib/solmate/lib/ds-test/src/test.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.0;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool private _failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function failed() public returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            bool globalFailed = false;\n            if (hasHEVMContext()) {\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\n                    abi.encodePacked(\n                        bytes4(keccak256(\"load(address,bytes32)\")),\n                        abi.encode(HEVM_ADDRESS, bytes32(\"failed\"))\n                    )\n                );\n                globalFailed = abi.decode(retdata, (bool));\n            }\n            return globalFailed;\n        }\n    } \n\n    function fail() internal {\n        if (hasHEVMContext()) {\n            (bool status, ) = HEVM_ADDRESS.call(\n                abi.encodePacked(\n                    bytes4(keccak256(\"store(address,bytes32,bytes32)\")),\n                    abi.encode(HEVM_ADDRESS, bytes32(\"failed\"), bytes32(uint256(0x01)))\n                )\n            );\n            status; // Silence compiler warnings\n        }\n        _failed = true;\n    }\n\n    function hasHEVMContext() internal view returns (bool) {\n        uint256 hevmCodeSize = 0;\n        assembly {\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\n        }\n        return hevmCodeSize > 0;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Expected\", b);\n            emit log_named_string(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", b);\n            emit log_named_bytes(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"},"hedge/lib/solmate/src/auth/Auth.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\nabstract contract Auth {\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\n\n    address public owner;\n\n    Authority public authority;\n\n    constructor(address _owner, Authority _authority) {\n        owner = _owner;\n        authority = _authority;\n\n        emit OwnershipTransferred(msg.sender, _owner);\n        emit AuthorityUpdated(msg.sender, _authority);\n    }\n\n    modifier requiresAuth() virtual {\n        require(isAuthorized(msg.sender, msg.sig), \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\n\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\n    }\n\n    function setAuthority(Authority newAuthority) public virtual {\n        // We check if the caller is the owner first because we want to ensure they can\n        // always swap out the authority even if it's reverting or using up a lot of gas.\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\n\n        authority = newAuthority;\n\n        emit AuthorityUpdated(msg.sender, newAuthority);\n    }\n\n    function transferOwnership(address newOwner) public virtual requiresAuth {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\ninterface Authority {\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) external view returns (bool);\n}\n"},"hedge/lib/solmate/src/auth/Owned.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"},"hedge/lib/solmate/src/auth/authorities/MultiRolesAuthority.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Auth, Authority} from \"../Auth.sol\";\n\n/// @notice Flexible and target agnostic role based Authority that supports up to 256 roles.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/MultiRolesAuthority.sol)\ncontract MultiRolesAuthority is Auth, Authority {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\n\n    event PublicCapabilityUpdated(bytes4 indexed functionSig, bool enabled);\n\n    event RoleCapabilityUpdated(uint8 indexed role, bytes4 indexed functionSig, bool enabled);\n\n    event TargetCustomAuthorityUpdated(address indexed target, Authority indexed authority);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\n\n    /*//////////////////////////////////////////////////////////////\n                     CUSTOM TARGET AUTHORITY STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => Authority) public getTargetCustomAuthority;\n\n    /*//////////////////////////////////////////////////////////////\n                            ROLE/USER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => bytes32) public getUserRoles;\n\n    mapping(bytes4 => bool) public isCapabilityPublic;\n\n    mapping(bytes4 => bytes32) public getRolesWithCapability;\n\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\n    }\n\n    function doesRoleHaveCapability(uint8 role, bytes4 functionSig) public view virtual returns (bool) {\n        return (uint256(getRolesWithCapability[functionSig]) >> role) & 1 != 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           AUTHORIZATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public view virtual override returns (bool) {\n        Authority customAuthority = getTargetCustomAuthority[target];\n\n        if (address(customAuthority) != address(0)) return customAuthority.canCall(user, target, functionSig);\n\n        return\n            isCapabilityPublic[functionSig] || bytes32(0) != getUserRoles[user] & getRolesWithCapability[functionSig];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n               CUSTOM TARGET AUTHORITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setTargetCustomAuthority(address target, Authority customAuthority) public virtual requiresAuth {\n        getTargetCustomAuthority[target] = customAuthority;\n\n        emit TargetCustomAuthorityUpdated(target, customAuthority);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                  PUBLIC CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setPublicCapability(bytes4 functionSig, bool enabled) public virtual requiresAuth {\n        isCapabilityPublic[functionSig] = enabled;\n\n        emit PublicCapabilityUpdated(functionSig, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                       USER ROLE ASSIGNMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setUserRole(\n        address user,\n        uint8 role,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getUserRoles[user] |= bytes32(1 << role);\n        } else {\n            getUserRoles[user] &= ~bytes32(1 << role);\n        }\n\n        emit UserRoleUpdated(user, role, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                   ROLE CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setRoleCapability(\n        uint8 role,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getRolesWithCapability[functionSig] |= bytes32(1 << role);\n        } else {\n            getRolesWithCapability[functionSig] &= ~bytes32(1 << role);\n        }\n\n        emit RoleCapabilityUpdated(role, functionSig, enabled);\n    }\n}\n"},"hedge/lib/solmate/src/auth/authorities/RolesAuthority.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Auth, Authority} from \"../Auth.sol\";\n\n/// @notice Role based Authority that supports up to 256 roles.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/RolesAuthority.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-roles/blob/master/src/roles.sol)\ncontract RolesAuthority is Auth, Authority {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\n\n    event PublicCapabilityUpdated(address indexed target, bytes4 indexed functionSig, bool enabled);\n\n    event RoleCapabilityUpdated(uint8 indexed role, address indexed target, bytes4 indexed functionSig, bool enabled);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\n\n    /*//////////////////////////////////////////////////////////////\n                            ROLE/USER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => bytes32) public getUserRoles;\n\n    mapping(address => mapping(bytes4 => bool)) public isCapabilityPublic;\n\n    mapping(address => mapping(bytes4 => bytes32)) public getRolesWithCapability;\n\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\n    }\n\n    function doesRoleHaveCapability(\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public view virtual returns (bool) {\n        return (uint256(getRolesWithCapability[target][functionSig]) >> role) & 1 != 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           AUTHORIZATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public view virtual override returns (bool) {\n        return\n            isCapabilityPublic[target][functionSig] ||\n            bytes32(0) != getUserRoles[user] & getRolesWithCapability[target][functionSig];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                   ROLE CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setPublicCapability(\n        address target,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        isCapabilityPublic[target][functionSig] = enabled;\n\n        emit PublicCapabilityUpdated(target, functionSig, enabled);\n    }\n\n    function setRoleCapability(\n        uint8 role,\n        address target,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getRolesWithCapability[target][functionSig] |= bytes32(1 << role);\n        } else {\n            getRolesWithCapability[target][functionSig] &= ~bytes32(1 << role);\n        }\n\n        emit RoleCapabilityUpdated(role, target, functionSig, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                       USER ROLE ASSIGNMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setUserRole(\n        address user,\n        uint8 role,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getUserRoles[user] |= bytes32(1 << role);\n        } else {\n            getUserRoles[user] &= ~bytes32(1 << role);\n        }\n\n        emit UserRoleUpdated(user, role, enabled);\n    }\n}\n"},"hedge/lib/solmate/src/mixins/ERC4626.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}\n"},"hedge/lib/solmate/src/test/Auth.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {MockAuthChild} from \"./utils/mocks/MockAuthChild.sol\";\nimport {MockAuthority} from \"./utils/mocks/MockAuthority.sol\";\n\nimport {Authority} from \"../auth/Auth.sol\";\n\ncontract OutOfOrderAuthority is Authority {\n    function canCall(\n        address,\n        address,\n        bytes4\n    ) public pure override returns (bool) {\n        revert(\"OUT_OF_ORDER\");\n    }\n}\n\ncontract AuthTest is DSTestPlus {\n    MockAuthChild mockAuthChild;\n\n    function setUp() public {\n        mockAuthChild = new MockAuthChild();\n    }\n\n    function testTransferOwnershipAsOwner() public {\n        mockAuthChild.transferOwnership(address(0xBEEF));\n        assertEq(mockAuthChild.owner(), address(0xBEEF));\n    }\n\n    function testSetAuthorityAsOwner() public {\n        mockAuthChild.setAuthority(Authority(address(0xBEEF)));\n        assertEq(address(mockAuthChild.authority()), address(0xBEEF));\n    }\n\n    function testCallFunctionAsOwner() public {\n        mockAuthChild.updateFlag();\n    }\n\n    function testTransferOwnershipWithPermissiveAuthority() public {\n        mockAuthChild.setAuthority(new MockAuthority(true));\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.transferOwnership(address(this));\n    }\n\n    function testSetAuthorityWithPermissiveAuthority() public {\n        mockAuthChild.setAuthority(new MockAuthority(true));\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.setAuthority(Authority(address(0xBEEF)));\n    }\n\n    function testCallFunctionWithPermissiveAuthority() public {\n        mockAuthChild.setAuthority(new MockAuthority(true));\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.updateFlag();\n    }\n\n    function testSetAuthorityAsOwnerWithOutOfOrderAuthority() public {\n        mockAuthChild.setAuthority(new OutOfOrderAuthority());\n        mockAuthChild.setAuthority(new MockAuthority(true));\n    }\n\n    function testFailTransferOwnershipAsNonOwner() public {\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.transferOwnership(address(0xBEEF));\n    }\n\n    function testFailSetAuthorityAsNonOwner() public {\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.setAuthority(Authority(address(0xBEEF)));\n    }\n\n    function testFailCallFunctionAsNonOwner() public {\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.updateFlag();\n    }\n\n    function testFailTransferOwnershipWithRestrictiveAuthority() public {\n        mockAuthChild.setAuthority(new MockAuthority(false));\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.transferOwnership(address(this));\n    }\n\n    function testFailSetAuthorityWithRestrictiveAuthority() public {\n        mockAuthChild.setAuthority(new MockAuthority(false));\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.setAuthority(Authority(address(0xBEEF)));\n    }\n\n    function testFailCallFunctionWithRestrictiveAuthority() public {\n        mockAuthChild.setAuthority(new MockAuthority(false));\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.updateFlag();\n    }\n\n    function testFailTransferOwnershipAsOwnerWithOutOfOrderAuthority() public {\n        mockAuthChild.setAuthority(new OutOfOrderAuthority());\n        mockAuthChild.transferOwnership(address(0));\n    }\n\n    function testFailCallFunctionAsOwnerWithOutOfOrderAuthority() public {\n        mockAuthChild.setAuthority(new OutOfOrderAuthority());\n        mockAuthChild.updateFlag();\n    }\n\n    function testTransferOwnershipAsOwner(address newOwner) public {\n        mockAuthChild.transferOwnership(newOwner);\n        assertEq(mockAuthChild.owner(), newOwner);\n    }\n\n    function testSetAuthorityAsOwner(Authority newAuthority) public {\n        mockAuthChild.setAuthority(newAuthority);\n        assertEq(address(mockAuthChild.authority()), address(newAuthority));\n    }\n\n    function testTransferOwnershipWithPermissiveAuthority(address deadOwner, address newOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new MockAuthority(true));\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.transferOwnership(newOwner);\n    }\n\n    function testSetAuthorityWithPermissiveAuthority(address deadOwner, Authority newAuthority) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new MockAuthority(true));\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.setAuthority(newAuthority);\n    }\n\n    function testCallFunctionWithPermissiveAuthority(address deadOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new MockAuthority(true));\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.updateFlag();\n    }\n\n    function testFailTransferOwnershipAsNonOwner(address deadOwner, address newOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.transferOwnership(newOwner);\n    }\n\n    function testFailSetAuthorityAsNonOwner(address deadOwner, Authority newAuthority) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.setAuthority(newAuthority);\n    }\n\n    function testFailCallFunctionAsNonOwner(address deadOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.updateFlag();\n    }\n\n    function testFailTransferOwnershipWithRestrictiveAuthority(address deadOwner, address newOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new MockAuthority(false));\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.transferOwnership(newOwner);\n    }\n\n    function testFailSetAuthorityWithRestrictiveAuthority(address deadOwner, Authority newAuthority) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new MockAuthority(false));\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.setAuthority(newAuthority);\n    }\n\n    function testFailCallFunctionWithRestrictiveAuthority(address deadOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new MockAuthority(false));\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.updateFlag();\n    }\n\n    function testFailTransferOwnershipAsOwnerWithOutOfOrderAuthority(address deadOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new OutOfOrderAuthority());\n        mockAuthChild.transferOwnership(deadOwner);\n    }\n}\n"},"hedge/lib/solmate/src/test/Bytes32AddressLib.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {Bytes32AddressLib} from \"../utils/Bytes32AddressLib.sol\";\n\ncontract Bytes32AddressLibTest is DSTestPlus {\n    function testFillLast12Bytes() public {\n        assertEq(\n            Bytes32AddressLib.fillLast12Bytes(0xfEEDFaCEcaFeBEEFfEEDFACecaFEBeeFfeEdfAce),\n            0xfeedfacecafebeeffeedfacecafebeeffeedface000000000000000000000000\n        );\n    }\n\n    function testFromLast20Bytes() public {\n        assertEq(\n            Bytes32AddressLib.fromLast20Bytes(0xfeedfacecafebeeffeedfacecafebeeffeedfacecafebeeffeedfacecafebeef),\n            0xCAfeBeefFeedfAceCAFeBEEffEEDfaCecafEBeeF\n        );\n    }\n}\n"},"hedge/lib/solmate/src/test/CREATE3.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {WETH} from \"../tokens/WETH.sol\";\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {MockERC20} from \"./utils/mocks/MockERC20.sol\";\nimport {MockAuthChild} from \"./utils/mocks/MockAuthChild.sol\";\n\nimport {CREATE3} from \"../utils/CREATE3.sol\";\n\ncontract CREATE3Test is DSTestPlus {\n    function testDeployERC20() public {\n        bytes32 salt = keccak256(bytes(\"A salt!\"));\n\n        MockERC20 deployed = MockERC20(\n            CREATE3.deploy(\n                salt,\n                abi.encodePacked(type(MockERC20).creationCode, abi.encode(\"Mock Token\", \"MOCK\", 18)),\n                0\n            )\n        );\n\n        assertEq(address(deployed), CREATE3.getDeployed(salt));\n\n        assertEq(deployed.name(), \"Mock Token\");\n        assertEq(deployed.symbol(), \"MOCK\");\n        assertEq(deployed.decimals(), 18);\n    }\n\n    function testFailDoubleDeploySameBytecode() public {\n        bytes32 salt = keccak256(bytes(\"Salty...\"));\n\n        CREATE3.deploy(salt, type(MockAuthChild).creationCode, 0);\n        CREATE3.deploy(salt, type(MockAuthChild).creationCode, 0);\n    }\n\n    function testFailDoubleDeployDifferentBytecode() public {\n        bytes32 salt = keccak256(bytes(\"and sweet!\"));\n\n        CREATE3.deploy(salt, type(WETH).creationCode, 0);\n        CREATE3.deploy(salt, type(MockAuthChild).creationCode, 0);\n    }\n\n    function testDeployERC20(\n        bytes32 salt,\n        string calldata name,\n        string calldata symbol,\n        uint8 decimals\n    ) public {\n        MockERC20 deployed = MockERC20(\n            CREATE3.deploy(salt, abi.encodePacked(type(MockERC20).creationCode, abi.encode(name, symbol, decimals)), 0)\n        );\n\n        assertEq(address(deployed), CREATE3.getDeployed(salt));\n\n        assertEq(deployed.name(), name);\n        assertEq(deployed.symbol(), symbol);\n        assertEq(deployed.decimals(), decimals);\n    }\n\n    function testFailDoubleDeploySameBytecode(bytes32 salt, bytes calldata bytecode) public {\n        CREATE3.deploy(salt, bytecode, 0);\n        CREATE3.deploy(salt, bytecode, 0);\n    }\n\n    function testFailDoubleDeployDifferentBytecode(\n        bytes32 salt,\n        bytes calldata bytecode1,\n        bytes calldata bytecode2\n    ) public {\n        CREATE3.deploy(salt, bytecode1, 0);\n        CREATE3.deploy(salt, bytecode2, 0);\n    }\n}\n"},"hedge/lib/solmate/src/test/DSTestPlus.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\ncontract DSTestPlusTest is DSTestPlus {\n    function testBound() public {\n        assertEq(bound(0, 69, 69), 69);\n        assertEq(bound(0, 68, 69), 68);\n        assertEq(bound(5, 0, 4), 0);\n        assertEq(bound(9999, 1337, 6666), 6006);\n        assertEq(bound(0, type(uint256).max - 6, type(uint256).max), type(uint256).max - 6);\n        assertEq(bound(6, type(uint256).max - 6, type(uint256).max), type(uint256).max);\n    }\n\n    function testFailBoundMinBiggerThanMax() public {\n        bound(5, 100, 10);\n    }\n\n    function testRelApproxEqBothZeroesPasses() public {\n        assertRelApproxEq(0, 0, 1e18);\n        assertRelApproxEq(0, 0, 0);\n    }\n\n    function testBound(\n        uint256 num,\n        uint256 min,\n        uint256 max\n    ) public {\n        if (min > max) (min, max) = (max, min);\n\n        uint256 bounded = bound(num, min, max);\n\n        assertGe(bounded, min);\n        assertLe(bounded, max);\n    }\n\n    function testFailBoundMinBiggerThanMax(\n        uint256 num,\n        uint256 min,\n        uint256 max\n    ) public {\n        if (max == min) {\n            unchecked {\n                min++; // Overflow is handled below.\n            }\n        }\n\n        if (max > min) (min, max) = (max, min);\n\n        bound(num, min, max);\n    }\n\n    function testBrutalizeMemory() public brutalizeMemory(\"FEEDFACECAFEBEEFFEEDFACECAFEBEEF\") {\n        bytes32 scratchSpace1;\n        bytes32 scratchSpace2;\n        bytes32 freeMem1;\n        bytes32 freeMem2;\n\n        assembly {\n            scratchSpace1 := mload(0)\n            scratchSpace2 := mload(32)\n            freeMem1 := mload(mload(0x40))\n            freeMem2 := mload(add(mload(0x40), 32))\n        }\n\n        assertGt(uint256(freeMem1), 0);\n        assertGt(uint256(freeMem2), 0);\n        assertGt(uint256(scratchSpace1), 0);\n        assertGt(uint256(scratchSpace2), 0);\n    }\n}\n"},"hedge/lib/solmate/src/test/ERC1155.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {MockERC1155} from \"./utils/mocks/MockERC1155.sol\";\n\nimport {ERC1155TokenReceiver} from \"../tokens/ERC1155.sol\";\n\ncontract ERC1155Recipient is ERC1155TokenReceiver {\n    address public operator;\n    address public from;\n    uint256 public id;\n    uint256 public amount;\n    bytes public mintData;\n\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _amount,\n        bytes calldata _data\n    ) public override returns (bytes4) {\n        operator = _operator;\n        from = _from;\n        id = _id;\n        amount = _amount;\n        mintData = _data;\n\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    address public batchOperator;\n    address public batchFrom;\n    uint256[] internal _batchIds;\n    uint256[] internal _batchAmounts;\n    bytes public batchData;\n\n    function batchIds() external view returns (uint256[] memory) {\n        return _batchIds;\n    }\n\n    function batchAmounts() external view returns (uint256[] memory) {\n        return _batchAmounts;\n    }\n\n    function onERC1155BatchReceived(\n        address _operator,\n        address _from,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes calldata _data\n    ) external override returns (bytes4) {\n        batchOperator = _operator;\n        batchFrom = _from;\n        _batchIds = _ids;\n        _batchAmounts = _amounts;\n        batchData = _data;\n\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n\ncontract RevertingERC1155Recipient is ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public pure override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));\n    }\n}\n\ncontract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public pure override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n}\n\ncontract NonERC1155Recipient {}\n\ncontract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {\n    MockERC1155 token;\n\n    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;\n    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;\n\n    function setUp() public {\n        token = new MockERC1155();\n    }\n\n    function testMintToEOA() public {\n        token.mint(address(0xBEEF), 1337, 1, \"\");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);\n    }\n\n    function testMintToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        token.mint(address(to), 1337, 1, \"testing 123\");\n\n        assertEq(token.balanceOf(address(to), 1337), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.mintData(), \"testing 123\");\n    }\n\n    function testBatchMintToEOA() public {\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory amounts = new uint256[](5);\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n        amounts[4] = 500;\n\n        token.batchMint(address(0xBEEF), ids, amounts, \"\");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);\n    }\n\n    function testBatchMintToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory amounts = new uint256[](5);\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n        amounts[4] = 500;\n\n        token.batchMint(address(to), ids, amounts, \"testing 123\");\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), address(0));\n        assertUintArrayEq(to.batchIds(), ids);\n        assertUintArrayEq(to.batchAmounts(), amounts);\n        assertBytesEq(to.batchData(), \"testing 123\");\n\n        assertEq(token.balanceOf(address(to), 1337), 100);\n        assertEq(token.balanceOf(address(to), 1338), 200);\n        assertEq(token.balanceOf(address(to), 1339), 300);\n        assertEq(token.balanceOf(address(to), 1340), 400);\n        assertEq(token.balanceOf(address(to), 1341), 500);\n    }\n\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1337, 100, \"\");\n\n        token.burn(address(0xBEEF), 1337, 70);\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);\n    }\n\n    function testBatchBurn() public {\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory burnAmounts = new uint256[](5);\n        burnAmounts[0] = 50;\n        burnAmounts[1] = 100;\n        burnAmounts[2] = 150;\n        burnAmounts[3] = 200;\n        burnAmounts[4] = 250;\n\n        token.batchMint(address(0xBEEF), ids, mintAmounts, \"\");\n\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);\n    }\n\n    function testApproveAll() public {\n        token.setApprovalForAll(address(0xBEEF), true);\n\n        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));\n    }\n\n    function testSafeTransferFromToEOA() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337, 100, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, \"\");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);\n        assertEq(token.balanceOf(from, 1337), 30);\n    }\n\n    function testSafeTransferFromToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        address from = address(0xABCD);\n\n        token.mint(from, 1337, 100, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(to), 1337, 70, \"testing 123\");\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), from);\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.mintData(), \"testing 123\");\n\n        assertEq(token.balanceOf(address(to), 1337), 70);\n        assertEq(token.balanceOf(from, 1337), 30);\n    }\n\n    function testSafeTransferFromSelf() public {\n        token.mint(address(this), 1337, 100, \"\");\n\n        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, \"\");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);\n        assertEq(token.balanceOf(address(this), 1337), 30);\n    }\n\n    function testSafeBatchTransferFromToEOA() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256[](5);\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, \"\");\n\n        assertEq(token.balanceOf(from, 1337), 50);\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);\n\n        assertEq(token.balanceOf(from, 1338), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);\n\n        assertEq(token.balanceOf(from, 1339), 150);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);\n\n        assertEq(token.balanceOf(from, 1340), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);\n\n        assertEq(token.balanceOf(from, 1341), 250);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);\n    }\n\n    function testSafeBatchTransferFromToERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256[](5);\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, \"testing 123\");\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), from);\n        assertUintArrayEq(to.batchIds(), ids);\n        assertUintArrayEq(to.batchAmounts(), transferAmounts);\n        assertBytesEq(to.batchData(), \"testing 123\");\n\n        assertEq(token.balanceOf(from, 1337), 50);\n        assertEq(token.balanceOf(address(to), 1337), 50);\n\n        assertEq(token.balanceOf(from, 1338), 100);\n        assertEq(token.balanceOf(address(to), 1338), 100);\n\n        assertEq(token.balanceOf(from, 1339), 150);\n        assertEq(token.balanceOf(address(to), 1339), 150);\n\n        assertEq(token.balanceOf(from, 1340), 200);\n        assertEq(token.balanceOf(address(to), 1340), 200);\n\n        assertEq(token.balanceOf(from, 1341), 250);\n        assertEq(token.balanceOf(address(to), 1341), 250);\n    }\n\n    function testBatchBalanceOf() public {\n        address[] memory tos = new address[](5);\n        tos[0] = address(0xBEEF);\n        tos[1] = address(0xCAFE);\n        tos[2] = address(0xFACE);\n        tos[3] = address(0xDEAD);\n        tos[4] = address(0xFEED);\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        token.mint(address(0xBEEF), 1337, 100, \"\");\n        token.mint(address(0xCAFE), 1338, 200, \"\");\n        token.mint(address(0xFACE), 1339, 300, \"\");\n        token.mint(address(0xDEAD), 1340, 400, \"\");\n        token.mint(address(0xFEED), 1341, 500, \"\");\n\n        uint256[] memory balances = token.balanceOfBatch(tos, ids);\n\n        assertEq(balances[0], 100);\n        assertEq(balances[1], 200);\n        assertEq(balances[2], 300);\n        assertEq(balances[3], 400);\n        assertEq(balances[4], 500);\n    }\n\n    function testFailMintToZero() public {\n        token.mint(address(0), 1337, 1, \"\");\n    }\n\n    function testFailMintToNonERC155Recipient() public {\n        token.mint(address(new NonERC1155Recipient()), 1337, 1, \"\");\n    }\n\n    function testFailMintToRevertingERC155Recipient() public {\n        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, \"\");\n    }\n\n    function testFailMintToWrongReturnDataERC155Recipient() public {\n        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, \"\");\n    }\n\n    function testFailBurnInsufficientBalance() public {\n        token.mint(address(0xBEEF), 1337, 70, \"\");\n        token.burn(address(0xBEEF), 1337, 100);\n    }\n\n    function testFailSafeTransferFromInsufficientBalance() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337, 70, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, \"\");\n    }\n\n    function testFailSafeTransferFromSelfInsufficientBalance() public {\n        token.mint(address(this), 1337, 70, \"\");\n        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, \"\");\n    }\n\n    function testFailSafeTransferFromToZero() public {\n        token.mint(address(this), 1337, 100, \"\");\n        token.safeTransferFrom(address(this), address(0), 1337, 70, \"\");\n    }\n\n    function testFailSafeTransferFromToNonERC155Recipient() public {\n        token.mint(address(this), 1337, 100, \"\");\n        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, \"\");\n    }\n\n    function testFailSafeTransferFromToRevertingERC1155Recipient() public {\n        token.mint(address(this), 1337, 100, \"\");\n        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, \"\");\n    }\n\n    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {\n        token.mint(address(this), 1337, 100, \"\");\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, \"\");\n    }\n\n    function testFailSafeBatchTransferInsufficientBalance() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n\n        mintAmounts[0] = 50;\n        mintAmounts[1] = 100;\n        mintAmounts[2] = 150;\n        mintAmounts[3] = 200;\n        mintAmounts[4] = 250;\n\n        uint256[] memory transferAmounts = new uint256[](5);\n        transferAmounts[0] = 100;\n        transferAmounts[1] = 200;\n        transferAmounts[2] = 300;\n        transferAmounts[3] = 400;\n        transferAmounts[4] = 500;\n\n        token.batchMint(from, ids, mintAmounts, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, \"\");\n    }\n\n    function testFailSafeBatchTransferFromToZero() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256[](5);\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, \"\");\n    }\n\n    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256[](5);\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, \"\");\n    }\n\n    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256[](5);\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, \"\");\n    }\n\n    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256[](5);\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, \"\");\n    }\n\n    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256[](4);\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n\n        token.batchMint(from, ids, mintAmounts, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, \"\");\n    }\n\n    function testFailBatchMintToZero() public {\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(0), ids, mintAmounts, \"\");\n    }\n\n    function testFailBatchMintToNonERC1155Recipient() public {\n        NonERC1155Recipient to = new NonERC1155Recipient();\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(to), ids, mintAmounts, \"\");\n    }\n\n    function testFailBatchMintToRevertingERC1155Recipient() public {\n        RevertingERC1155Recipient to = new RevertingERC1155Recipient();\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(to), ids, mintAmounts, \"\");\n    }\n\n    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {\n        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(to), ids, mintAmounts, \"\");\n    }\n\n    function testFailBatchMintWithArrayMismatch() public {\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory amounts = new uint256[](4);\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n\n        token.batchMint(address(0xBEEF), ids, amounts, \"\");\n    }\n\n    function testFailBatchBurnInsufficientBalance() public {\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 50;\n        mintAmounts[1] = 100;\n        mintAmounts[2] = 150;\n        mintAmounts[3] = 200;\n        mintAmounts[4] = 250;\n\n        uint256[] memory burnAmounts = new uint256[](5);\n        burnAmounts[0] = 100;\n        burnAmounts[1] = 200;\n        burnAmounts[2] = 300;\n        burnAmounts[3] = 400;\n        burnAmounts[4] = 500;\n\n        token.batchMint(address(0xBEEF), ids, mintAmounts, \"\");\n\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n    }\n\n    function testFailBatchBurnWithArrayLengthMismatch() public {\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory burnAmounts = new uint256[](4);\n        burnAmounts[0] = 50;\n        burnAmounts[1] = 100;\n        burnAmounts[2] = 150;\n        burnAmounts[3] = 200;\n\n        token.batchMint(address(0xBEEF), ids, mintAmounts, \"\");\n\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n    }\n\n    function testFailBalanceOfBatchWithArrayMismatch() public view {\n        address[] memory tos = new address[](5);\n        tos[0] = address(0xBEEF);\n        tos[1] = address(0xCAFE);\n        tos[2] = address(0xFACE);\n        tos[3] = address(0xDEAD);\n        tos[4] = address(0xFEED);\n\n        uint256[] memory ids = new uint256[](4);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n\n        token.balanceOfBatch(tos, ids);\n    }\n\n    function testMintToEOA(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        token.mint(to, id, amount, mintData);\n\n        assertEq(token.balanceOf(to, id), amount);\n    }\n\n    function testMintToERC1155Recipient(\n        uint256 id,\n        uint256 amount,\n        bytes memory mintData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        token.mint(address(to), id, amount, mintData);\n\n        assertEq(token.balanceOf(address(to), id), amount);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), id);\n        assertBytesEq(to.mintData(), mintData);\n    }\n\n    function testBatchMintToEOA(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[to][id] += mintAmount;\n        }\n\n        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);\n\n        for (uint256 i = 0; i < normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);\n        }\n    }\n\n    function testBatchMintToERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), address(0));\n        assertUintArrayEq(to.batchIds(), normalizedIds);\n        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);\n        assertBytesEq(to.batchData(), mintData);\n\n        for (uint256 i = 0; i < normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);\n        }\n    }\n\n    function testBurn(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 burnAmount\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        burnAmount = bound(burnAmount, 0, mintAmount);\n\n        token.mint(to, id, mintAmount, mintData);\n\n        token.burn(to, id, burnAmount);\n\n        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);\n    }\n\n    function testBatchBurn(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);\n\n            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];\n            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];\n        }\n\n        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);\n\n        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);\n\n        for (uint256 i = 0; i < normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);\n        }\n    }\n\n    function testApproveAll(address to, bool approved) public {\n        token.setApprovalForAll(to, approved);\n\n        assertBoolEq(token.isApprovedForAll(address(this), to), approved);\n    }\n\n    function testSafeTransferFromToEOA(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        address to,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        address from = address(0xABCD);\n\n        token.mint(from, id, mintAmount, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, to, id, transferAmount, transferData);\n\n        if (to == from) {\n            assertEq(token.balanceOf(to, id), mintAmount);\n        } else {\n            assertEq(token.balanceOf(to, id), transferAmount);\n            assertEq(token.balanceOf(from, id), mintAmount - transferAmount);\n        }\n    }\n\n    function testSafeTransferFromToERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        bytes memory transferData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        address from = address(0xABCD);\n\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(from, id, mintAmount, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), from);\n        assertEq(to.id(), id);\n        assertBytesEq(to.mintData(), transferData);\n\n        assertEq(token.balanceOf(address(to), id), transferAmount);\n        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);\n    }\n\n    function testSafeTransferFromSelf(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        address to,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n\n        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);\n\n        assertEq(token.balanceOf(to, id), transferAmount);\n        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);\n    }\n\n    function testSafeBatchTransferFromToEOA(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n            userTransferOrBurnAmounts[from][id] += transferAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);\n\n        for (uint256 i = 0; i < normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);\n            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);\n        }\n    }\n\n    function testSafeBatchTransferFromToERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n            userTransferOrBurnAmounts[from][id] += transferAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), from);\n        assertUintArrayEq(to.batchIds(), normalizedIds);\n        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);\n        assertBytesEq(to.batchData(), transferData);\n\n        for (uint256 i = 0; i < normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n            uint256 transferAmount = userTransferOrBurnAmounts[from][id];\n\n            assertEq(token.balanceOf(address(to), id), transferAmount);\n            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);\n        }\n    }\n\n    function testBatchBalanceOf(\n        address[] memory tos,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min3(tos.length, ids.length, amounts.length);\n\n        address[] memory normalizedTos = new address[](minLength);\n        uint256[] memory normalizedIds = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n            address to = tos[i] == address(0) || tos[i].code.length > 0 ? address(0xBEEF) : tos[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            normalizedTos[i] = to;\n            normalizedIds[i] = id;\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            token.mint(to, id, mintAmount, mintData);\n\n            userMintAmounts[to][id] += mintAmount;\n        }\n\n        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);\n\n        for (uint256 i = 0; i < normalizedTos.length; i++) {\n            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));\n        }\n    }\n\n    function testFailMintToZero(\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public {\n        token.mint(address(0), id, amount, data);\n    }\n\n    function testFailMintToNonERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);\n    }\n\n    function testFailMintToRevertingERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);\n    }\n\n    function testFailMintToWrongReturnDataERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);\n    }\n\n    function testFailBurnInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 burnAmount,\n        bytes memory mintData\n    ) public {\n        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(to, id, mintAmount, mintData);\n        token.burn(to, id, burnAmount);\n    }\n\n    function testFailSafeTransferFromInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(from, id, mintAmount, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, to, id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromSelfInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromToZero(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromToNonERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromToRevertingERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(\n            address(this),\n            address(new RevertingERC1155Recipient()),\n            id,\n            transferAmount,\n            transferData\n        );\n    }\n\n    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(\n            address(this),\n            address(new WrongReturnDataERC1155Recipient()),\n            id,\n            transferAmount,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferInsufficientBalance(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        if (minLength == 0) revert();\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);\n    }\n\n    function testFailSafeBatchTransferFromToZero(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);\n    }\n\n    function testFailSafeBatchTransferFromToNonERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(\n            from,\n            address(new NonERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(\n            from,\n            address(new RevertingERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(\n            from,\n            address(new WrongReturnDataERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferFromWithArrayLengthMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        if (ids.length == transferAmounts.length) revert();\n\n        token.batchMint(from, ids, mintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);\n    }\n\n    function testFailBatchMintToZero(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(0)][id] += mintAmount;\n        }\n\n        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintToNonERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        NonERC1155Recipient to = new NonERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintToRevertingERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        RevertingERC1155Recipient to = new RevertingERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintToWrongReturnDataERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintWithArrayMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        if (ids.length == amounts.length) revert();\n\n        token.batchMint(address(to), ids, amounts, mintData);\n    }\n\n    function testFailBatchBurnInsufficientBalance(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);\n\n        if (minLength == 0) revert();\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);\n\n            userMintAmounts[to][id] += normalizedMintAmounts[i];\n        }\n\n        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);\n\n        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);\n    }\n\n    function testFailBatchBurnWithArrayLengthMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        if (ids.length == burnAmounts.length) revert();\n\n        token.batchMint(to, ids, mintAmounts, mintData);\n\n        token.batchBurn(to, ids, burnAmounts);\n    }\n\n    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {\n        if (tos.length == ids.length) revert();\n\n        token.balanceOfBatch(tos, ids);\n    }\n}\n"},"hedge/lib/solmate/src/test/ERC20.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {MockERC20} from \"./utils/mocks/MockERC20.sol\";\n\ncontract ERC20Test is DSTestPlus {\n    MockERC20 token;\n\n    bytes32 constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    function setUp() public {\n        token = new MockERC20(\"Token\", \"TKN\", 18);\n    }\n\n    function invariantMetadata() public {\n        assertEq(token.name(), \"Token\");\n        assertEq(token.symbol(), \"TKN\");\n        assertEq(token.decimals(), 18);\n    }\n\n    function testMint() public {\n        token.mint(address(0xBEEF), 1e18);\n\n        assertEq(token.totalSupply(), 1e18);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1e18);\n        token.burn(address(0xBEEF), 0.9e18);\n\n        assertEq(token.totalSupply(), 1e18 - 0.9e18);\n        assertEq(token.balanceOf(address(0xBEEF)), 0.1e18);\n    }\n\n    function testApprove() public {\n        assertTrue(token.approve(address(0xBEEF), 1e18));\n\n        assertEq(token.allowance(address(this), address(0xBEEF)), 1e18);\n    }\n\n    function testTransfer() public {\n        token.mint(address(this), 1e18);\n\n        assertTrue(token.transfer(address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testTransferFrom() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        hevm.prank(from);\n        token.approve(address(this), 1e18);\n\n        assertTrue(token.transferFrom(from, address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.allowance(from, address(this)), 0);\n\n        assertEq(token.balanceOf(from), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testInfiniteApproveTransferFrom() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        hevm.prank(from);\n        token.approve(address(this), type(uint256).max);\n\n        assertTrue(token.transferFrom(from, address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.allowance(from, address(this)), type(uint256).max);\n\n        assertEq(token.balanceOf(from), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testPermit() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n\n        assertEq(token.allowance(owner, address(0xCAFE)), 1e18);\n        assertEq(token.nonces(owner), 1);\n    }\n\n    function testFailTransferInsufficientBalance() public {\n        token.mint(address(this), 0.9e18);\n        token.transfer(address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferFromInsufficientAllowance() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        hevm.prank(from);\n        token.approve(address(this), 0.9e18);\n\n        token.transferFrom(from, address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferFromInsufficientBalance() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 0.9e18);\n\n        hevm.prank(from);\n        token.approve(address(this), 1e18);\n\n        token.transferFrom(from, address(0xBEEF), 1e18);\n    }\n\n    function testFailPermitBadNonce() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 1, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n    }\n\n    function testFailPermitBadDeadline() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp + 1, v, r, s);\n    }\n\n    function testFailPermitPastDeadline() public {\n        uint256 oldTimestamp = block.timestamp;\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, oldTimestamp))\n                )\n            )\n        );\n\n        hevm.warp(block.timestamp + 1);\n        token.permit(owner, address(0xCAFE), 1e18, oldTimestamp, v, r, s);\n    }\n\n    function testFailPermitReplay() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n    }\n\n    function testMetadata(\n        string calldata name,\n        string calldata symbol,\n        uint8 decimals\n    ) public {\n        MockERC20 tkn = new MockERC20(name, symbol, decimals);\n        assertEq(tkn.name(), name);\n        assertEq(tkn.symbol(), symbol);\n        assertEq(tkn.decimals(), decimals);\n    }\n\n    function testMint(address from, uint256 amount) public {\n        token.mint(from, amount);\n\n        assertEq(token.totalSupply(), amount);\n        assertEq(token.balanceOf(from), amount);\n    }\n\n    function testBurn(\n        address from,\n        uint256 mintAmount,\n        uint256 burnAmount\n    ) public {\n        burnAmount = bound(burnAmount, 0, mintAmount);\n\n        token.mint(from, mintAmount);\n        token.burn(from, burnAmount);\n\n        assertEq(token.totalSupply(), mintAmount - burnAmount);\n        assertEq(token.balanceOf(from), mintAmount - burnAmount);\n    }\n\n    function testApprove(address to, uint256 amount) public {\n        assertTrue(token.approve(to, amount));\n\n        assertEq(token.allowance(address(this), to), amount);\n    }\n\n    function testTransfer(address from, uint256 amount) public {\n        token.mint(address(this), amount);\n\n        assertTrue(token.transfer(from, amount));\n        assertEq(token.totalSupply(), amount);\n\n        if (address(this) == from) {\n            assertEq(token.balanceOf(address(this)), amount);\n        } else {\n            assertEq(token.balanceOf(address(this)), 0);\n            assertEq(token.balanceOf(from), amount);\n        }\n    }\n\n    function testTransferFrom(\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        amount = bound(amount, 0, approval);\n\n        address from = address(0xABCD);\n\n        token.mint(from, amount);\n\n        hevm.prank(from);\n        token.approve(address(this), approval);\n\n        assertTrue(token.transferFrom(from, to, amount));\n        assertEq(token.totalSupply(), amount);\n\n        uint256 app = from == address(this) || approval == type(uint256).max ? approval : approval - amount;\n        assertEq(token.allowance(from, address(this)), app);\n\n        if (from == to) {\n            assertEq(token.balanceOf(from), amount);\n        } else {\n            assertEq(token.balanceOf(from), 0);\n            assertEq(token.balanceOf(to), amount);\n        }\n    }\n\n    function testPermit(\n        uint248 privKey,\n        address to,\n        uint256 amount,\n        uint256 deadline\n    ) public {\n        uint256 privateKey = privKey;\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n\n        assertEq(token.allowance(owner, to), amount);\n        assertEq(token.nonces(owner), 1);\n    }\n\n    function testFailBurnInsufficientBalance(\n        address to,\n        uint256 mintAmount,\n        uint256 burnAmount\n    ) public {\n        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(to, mintAmount);\n        token.burn(to, burnAmount);\n    }\n\n    function testFailTransferInsufficientBalance(\n        address to,\n        uint256 mintAmount,\n        uint256 sendAmount\n    ) public {\n        sendAmount = bound(sendAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(address(this), mintAmount);\n        token.transfer(to, sendAmount);\n    }\n\n    function testFailTransferFromInsufficientAllowance(\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        amount = bound(amount, approval + 1, type(uint256).max);\n\n        address from = address(0xABCD);\n\n        token.mint(from, amount);\n\n        hevm.prank(from);\n        token.approve(address(this), approval);\n\n        token.transferFrom(from, to, amount);\n    }\n\n    function testFailTransferFromInsufficientBalance(\n        address to,\n        uint256 mintAmount,\n        uint256 sendAmount\n    ) public {\n        sendAmount = bound(sendAmount, mintAmount + 1, type(uint256).max);\n\n        address from = address(0xABCD);\n\n        token.mint(from, mintAmount);\n\n        hevm.prank(from);\n        token.approve(address(this), sendAmount);\n\n        token.transferFrom(from, to, sendAmount);\n    }\n\n    function testFailPermitBadNonce(\n        uint256 privateKey,\n        address to,\n        uint256 amount,\n        uint256 deadline,\n        uint256 nonce\n    ) public {\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n        if (nonce == 0) nonce = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, nonce, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n    }\n\n    function testFailPermitBadDeadline(\n        uint256 privateKey,\n        address to,\n        uint256 amount,\n        uint256 deadline\n    ) public {\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline + 1, v, r, s);\n    }\n\n    function testFailPermitPastDeadline(\n        uint256 privateKey,\n        address to,\n        uint256 amount,\n        uint256 deadline\n    ) public {\n        deadline = bound(deadline, 0, block.timestamp - 1);\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n    }\n\n    function testFailPermitReplay(\n        uint256 privateKey,\n        address to,\n        uint256 amount,\n        uint256 deadline\n    ) public {\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n        token.permit(owner, to, amount, deadline, v, r, s);\n    }\n}\n\ncontract ERC20Invariants is DSTestPlus, DSInvariantTest {\n    BalanceSum balanceSum;\n    MockERC20 token;\n\n    function setUp() public {\n        token = new MockERC20(\"Token\", \"TKN\", 18);\n        balanceSum = new BalanceSum(token);\n\n        addTargetContract(address(balanceSum));\n    }\n\n    function invariantBalanceSum() public {\n        assertEq(token.totalSupply(), balanceSum.sum());\n    }\n}\n\ncontract BalanceSum {\n    MockERC20 token;\n    uint256 public sum;\n\n    constructor(MockERC20 _token) {\n        token = _token;\n    }\n\n    function mint(address from, uint256 amount) public {\n        token.mint(from, amount);\n        sum += amount;\n    }\n\n    function burn(address from, uint256 amount) public {\n        token.burn(from, amount);\n        sum -= amount;\n    }\n\n    function approve(address to, uint256 amount) public {\n        token.approve(to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public {\n        token.transferFrom(from, to, amount);\n    }\n\n    function transfer(address to, uint256 amount) public {\n        token.transfer(to, amount);\n    }\n}\n"},"hedge/lib/solmate/src/test/ERC4626.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {MockERC20} from \"./utils/mocks/MockERC20.sol\";\nimport {MockERC4626} from \"./utils/mocks/MockERC4626.sol\";\n\ncontract ERC4626Test is DSTestPlus {\n    MockERC20 underlying;\n    MockERC4626 vault;\n\n    function setUp() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(underlying, \"Mock Token Vault\", \"vwTKN\");\n    }\n\n    function invariantMetadata() public {\n        assertEq(vault.name(), \"Mock Token Vault\");\n        assertEq(vault.symbol(), \"vwTKN\");\n        assertEq(vault.decimals(), 18);\n    }\n\n    function testMetadata(string calldata name, string calldata symbol) public {\n        MockERC4626 vlt = new MockERC4626(underlying, name, symbol);\n        assertEq(vlt.name(), name);\n        assertEq(vlt.symbol(), symbol);\n        assertEq(address(vlt.asset()), address(underlying));\n    }\n\n    function testSingleDepositWithdraw(uint128 amount) public {\n        if (amount == 0) amount = 1;\n\n        uint256 aliceUnderlyingAmount = amount;\n\n        address alice = address(0xABCD);\n\n        underlying.mint(alice, aliceUnderlyingAmount);\n\n        hevm.prank(alice);\n        underlying.approve(address(vault), aliceUnderlyingAmount);\n        assertEq(underlying.allowance(alice, address(vault)), aliceUnderlyingAmount);\n\n        uint256 alicePreDepositBal = underlying.balanceOf(alice);\n\n        hevm.prank(alice);\n        uint256 aliceShareAmount = vault.deposit(aliceUnderlyingAmount, alice);\n\n        assertEq(vault.afterDepositHookCalledCounter(), 1);\n\n        // Expect exchange rate to be 1:1 on initial deposit.\n        assertEq(aliceUnderlyingAmount, aliceShareAmount);\n        assertEq(vault.previewWithdraw(aliceShareAmount), aliceUnderlyingAmount);\n        assertEq(vault.previewDeposit(aliceUnderlyingAmount), aliceShareAmount);\n        assertEq(vault.totalSupply(), aliceShareAmount);\n        assertEq(vault.totalAssets(), aliceUnderlyingAmount);\n        assertEq(vault.balanceOf(alice), aliceShareAmount);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), aliceUnderlyingAmount);\n        assertEq(underlying.balanceOf(alice), alicePreDepositBal - aliceUnderlyingAmount);\n\n        hevm.prank(alice);\n        vault.withdraw(aliceUnderlyingAmount, alice, alice);\n\n        assertEq(vault.beforeWithdrawHookCalledCounter(), 1);\n\n        assertEq(vault.totalAssets(), 0);\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 0);\n        assertEq(underlying.balanceOf(alice), alicePreDepositBal);\n    }\n\n    function testSingleMintRedeem(uint128 amount) public {\n        if (amount == 0) amount = 1;\n\n        uint256 aliceShareAmount = amount;\n\n        address alice = address(0xABCD);\n\n        underlying.mint(alice, aliceShareAmount);\n\n        hevm.prank(alice);\n        underlying.approve(address(vault), aliceShareAmount);\n        assertEq(underlying.allowance(alice, address(vault)), aliceShareAmount);\n\n        uint256 alicePreDepositBal = underlying.balanceOf(alice);\n\n        hevm.prank(alice);\n        uint256 aliceUnderlyingAmount = vault.mint(aliceShareAmount, alice);\n\n        assertEq(vault.afterDepositHookCalledCounter(), 1);\n\n        // Expect exchange rate to be 1:1 on initial mint.\n        assertEq(aliceShareAmount, aliceUnderlyingAmount);\n        assertEq(vault.previewWithdraw(aliceShareAmount), aliceUnderlyingAmount);\n        assertEq(vault.previewDeposit(aliceUnderlyingAmount), aliceShareAmount);\n        assertEq(vault.totalSupply(), aliceShareAmount);\n        assertEq(vault.totalAssets(), aliceUnderlyingAmount);\n        assertEq(vault.balanceOf(alice), aliceUnderlyingAmount);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), aliceUnderlyingAmount);\n        assertEq(underlying.balanceOf(alice), alicePreDepositBal - aliceUnderlyingAmount);\n\n        hevm.prank(alice);\n        vault.redeem(aliceShareAmount, alice, alice);\n\n        assertEq(vault.beforeWithdrawHookCalledCounter(), 1);\n\n        assertEq(vault.totalAssets(), 0);\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 0);\n        assertEq(underlying.balanceOf(alice), alicePreDepositBal);\n    }\n\n    function testMultipleMintDepositRedeemWithdraw() public {\n        // Scenario:\n        // A = Alice, B = Bob\n        //  ________________________________________________________\n        // | Vault shares | A share | A assets | B share | B assets |\n        // |========================================================|\n        // | 1. Alice mints 2000 shares (costs 2000 tokens)         |\n        // |--------------|---------|----------|---------|----------|\n        // |         2000 |    2000 |     2000 |       0 |        0 |\n        // |--------------|---------|----------|---------|----------|\n        // | 2. Bob deposits 4000 tokens (mints 4000 shares)        |\n        // |--------------|---------|----------|---------|----------|\n        // |         6000 |    2000 |     2000 |    4000 |     4000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 3. Vault mutates by +3000 tokens...                    |\n        // |    (simulated yield returned from strategy)...         |\n        // |--------------|---------|----------|---------|----------|\n        // |         6000 |    2000 |     3000 |    4000 |     6000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 4. Alice deposits 2000 tokens (mints 1333 shares)      |\n        // |--------------|---------|----------|---------|----------|\n        // |         7333 |    3333 |     4999 |    4000 |     6000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 5. Bob mints 2000 shares (costs 3001 assets)           |\n        // |    NOTE: Bob's assets spent got rounded up             |\n        // |    NOTE: Alice's vault assets got rounded up           |\n        // |--------------|---------|----------|---------|----------|\n        // |         9333 |    3333 |     5000 |    6000 |     9000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 6. Vault mutates by +3000 tokens...                    |\n        // |    (simulated yield returned from strategy)            |\n        // |    NOTE: Vault holds 17001 tokens, but sum of          |\n        // |          assetsOf() is 17000.                          |\n        // |--------------|---------|----------|---------|----------|\n        // |         9333 |    3333 |     6071 |    6000 |    10929 |\n        // |--------------|---------|----------|---------|----------|\n        // | 7. Alice redeem 1333 shares (2428 assets)              |\n        // |--------------|---------|----------|---------|----------|\n        // |         8000 |    2000 |     3643 |    6000 |    10929 |\n        // |--------------|---------|----------|---------|----------|\n        // | 8. Bob withdraws 2928 assets (1608 shares)             |\n        // |--------------|---------|----------|---------|----------|\n        // |         6392 |    2000 |     3643 |    4392 |     8000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 9. Alice withdraws 3643 assets (2000 shares)           |\n        // |    NOTE: Bob's assets have been rounded back up        |\n        // |--------------|---------|----------|---------|----------|\n        // |         4392 |       0 |        0 |    4392 |     8001 |\n        // |--------------|---------|----------|---------|----------|\n        // | 10. Bob redeem 4392 shares (8001 tokens)               |\n        // |--------------|---------|----------|---------|----------|\n        // |            0 |       0 |        0 |       0 |        0 |\n        // |______________|_________|__________|_________|__________|\n\n        address alice = address(0xABCD);\n        address bob = address(0xDCBA);\n\n        uint256 mutationUnderlyingAmount = 3000;\n\n        underlying.mint(alice, 4000);\n\n        hevm.prank(alice);\n        underlying.approve(address(vault), 4000);\n\n        assertEq(underlying.allowance(alice, address(vault)), 4000);\n\n        underlying.mint(bob, 7001);\n\n        hevm.prank(bob);\n        underlying.approve(address(vault), 7001);\n\n        assertEq(underlying.allowance(bob, address(vault)), 7001);\n\n        // 1. Alice mints 2000 shares (costs 2000 tokens)\n        hevm.prank(alice);\n        uint256 aliceUnderlyingAmount = vault.mint(2000, alice);\n\n        uint256 aliceShareAmount = vault.previewDeposit(aliceUnderlyingAmount);\n        assertEq(vault.afterDepositHookCalledCounter(), 1);\n\n        // Expect to have received the requested mint amount.\n        assertEq(aliceShareAmount, 2000);\n        assertEq(vault.balanceOf(alice), aliceShareAmount);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), aliceUnderlyingAmount);\n        assertEq(vault.convertToShares(aliceUnderlyingAmount), vault.balanceOf(alice));\n\n        // Expect a 1:1 ratio before mutation.\n        assertEq(aliceUnderlyingAmount, 2000);\n\n        // Sanity check.\n        assertEq(vault.totalSupply(), aliceShareAmount);\n        assertEq(vault.totalAssets(), aliceUnderlyingAmount);\n\n        // 2. Bob deposits 4000 tokens (mints 4000 shares)\n        hevm.prank(bob);\n        uint256 bobShareAmount = vault.deposit(4000, bob);\n        uint256 bobUnderlyingAmount = vault.previewWithdraw(bobShareAmount);\n        assertEq(vault.afterDepositHookCalledCounter(), 2);\n\n        // Expect to have received the requested underlying amount.\n        assertEq(bobUnderlyingAmount, 4000);\n        assertEq(vault.balanceOf(bob), bobShareAmount);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), bobUnderlyingAmount);\n        assertEq(vault.convertToShares(bobUnderlyingAmount), vault.balanceOf(bob));\n\n        // Expect a 1:1 ratio before mutation.\n        assertEq(bobShareAmount, bobUnderlyingAmount);\n\n        // Sanity check.\n        uint256 preMutationShareBal = aliceShareAmount + bobShareAmount;\n        uint256 preMutationBal = aliceUnderlyingAmount + bobUnderlyingAmount;\n        assertEq(vault.totalSupply(), preMutationShareBal);\n        assertEq(vault.totalAssets(), preMutationBal);\n        assertEq(vault.totalSupply(), 6000);\n        assertEq(vault.totalAssets(), 6000);\n\n        // 3. Vault mutates by +3000 tokens...                    |\n        //    (simulated yield returned from strategy)...\n        // The Vault now contains more tokens than deposited which causes the exchange rate to change.\n        // Alice share is 33.33% of the Vault, Bob 66.66% of the Vault.\n        // Alice's share count stays the same but the underlying amount changes from 2000 to 3000.\n        // Bob's share count stays the same but the underlying amount changes from 4000 to 6000.\n        underlying.mint(address(vault), mutationUnderlyingAmount);\n        assertEq(vault.totalSupply(), preMutationShareBal);\n        assertEq(vault.totalAssets(), preMutationBal + mutationUnderlyingAmount);\n        assertEq(vault.balanceOf(alice), aliceShareAmount);\n        assertEq(\n            vault.convertToAssets(vault.balanceOf(alice)),\n            aliceUnderlyingAmount + (mutationUnderlyingAmount / 3) * 1\n        );\n        assertEq(vault.balanceOf(bob), bobShareAmount);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), bobUnderlyingAmount + (mutationUnderlyingAmount / 3) * 2);\n\n        // 4. Alice deposits 2000 tokens (mints 1333 shares)\n        hevm.prank(alice);\n        vault.deposit(2000, alice);\n\n        assertEq(vault.totalSupply(), 7333);\n        assertEq(vault.balanceOf(alice), 3333);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 4999);\n        assertEq(vault.balanceOf(bob), 4000);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), 6000);\n\n        // 5. Bob mints 2000 shares (costs 3001 assets)\n        // NOTE: Bob's assets spent got rounded up\n        // NOTE: Alices's vault assets got rounded up\n        hevm.prank(bob);\n        vault.mint(2000, bob);\n\n        assertEq(vault.totalSupply(), 9333);\n        assertEq(vault.balanceOf(alice), 3333);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 5000);\n        assertEq(vault.balanceOf(bob), 6000);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), 9000);\n\n        // Sanity checks:\n        // Alice and bob should have spent all their tokens now\n        assertEq(underlying.balanceOf(alice), 0);\n        assertEq(underlying.balanceOf(bob), 0);\n        // Assets in vault: 4k (alice) + 7k (bob) + 3k (yield) + 1 (round up)\n        assertEq(vault.totalAssets(), 14001);\n\n        // 6. Vault mutates by +3000 tokens\n        // NOTE: Vault holds 17001 tokens, but sum of assetsOf() is 17000.\n        underlying.mint(address(vault), mutationUnderlyingAmount);\n        assertEq(vault.totalAssets(), 17001);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 6071);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), 10929);\n\n        // 7. Alice redeem 1333 shares (2428 assets)\n        hevm.prank(alice);\n        vault.redeem(1333, alice, alice);\n\n        assertEq(underlying.balanceOf(alice), 2428);\n        assertEq(vault.totalSupply(), 8000);\n        assertEq(vault.totalAssets(), 14573);\n        assertEq(vault.balanceOf(alice), 2000);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 3643);\n        assertEq(vault.balanceOf(bob), 6000);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), 10929);\n\n        // 8. Bob withdraws 2929 assets (1608 shares)\n        hevm.prank(bob);\n        vault.withdraw(2929, bob, bob);\n\n        assertEq(underlying.balanceOf(bob), 2929);\n        assertEq(vault.totalSupply(), 6392);\n        assertEq(vault.totalAssets(), 11644);\n        assertEq(vault.balanceOf(alice), 2000);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 3643);\n        assertEq(vault.balanceOf(bob), 4392);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), 8000);\n\n        // 9. Alice withdraws 3643 assets (2000 shares)\n        // NOTE: Bob's assets have been rounded back up\n        hevm.prank(alice);\n        vault.withdraw(3643, alice, alice);\n\n        assertEq(underlying.balanceOf(alice), 6071);\n        assertEq(vault.totalSupply(), 4392);\n        assertEq(vault.totalAssets(), 8001);\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 0);\n        assertEq(vault.balanceOf(bob), 4392);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), 8001);\n\n        // 10. Bob redeem 4392 shares (8001 tokens)\n        hevm.prank(bob);\n        vault.redeem(4392, bob, bob);\n        assertEq(underlying.balanceOf(bob), 10930);\n        assertEq(vault.totalSupply(), 0);\n        assertEq(vault.totalAssets(), 0);\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 0);\n        assertEq(vault.balanceOf(bob), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), 0);\n\n        // Sanity check\n        assertEq(underlying.balanceOf(address(vault)), 0);\n    }\n\n    function testFailDepositWithNotEnoughApproval() public {\n        underlying.mint(address(this), 0.5e18);\n        underlying.approve(address(vault), 0.5e18);\n        assertEq(underlying.allowance(address(this), address(vault)), 0.5e18);\n\n        vault.deposit(1e18, address(this));\n    }\n\n    function testFailWithdrawWithNotEnoughUnderlyingAmount() public {\n        underlying.mint(address(this), 0.5e18);\n        underlying.approve(address(vault), 0.5e18);\n\n        vault.deposit(0.5e18, address(this));\n\n        vault.withdraw(1e18, address(this), address(this));\n    }\n\n    function testFailRedeemWithNotEnoughShareAmount() public {\n        underlying.mint(address(this), 0.5e18);\n        underlying.approve(address(vault), 0.5e18);\n\n        vault.deposit(0.5e18, address(this));\n\n        vault.redeem(1e18, address(this), address(this));\n    }\n\n    function testFailWithdrawWithNoUnderlyingAmount() public {\n        vault.withdraw(1e18, address(this), address(this));\n    }\n\n    function testFailRedeemWithNoShareAmount() public {\n        vault.redeem(1e18, address(this), address(this));\n    }\n\n    function testFailDepositWithNoApproval() public {\n        vault.deposit(1e18, address(this));\n    }\n\n    function testFailMintWithNoApproval() public {\n        vault.mint(1e18, address(this));\n    }\n\n    function testFailDepositZero() public {\n        vault.deposit(0, address(this));\n    }\n\n    function testMintZero() public {\n        vault.mint(0, address(this));\n\n        assertEq(vault.balanceOf(address(this)), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(address(this))), 0);\n        assertEq(vault.totalSupply(), 0);\n        assertEq(vault.totalAssets(), 0);\n    }\n\n    function testFailRedeemZero() public {\n        vault.redeem(0, address(this), address(this));\n    }\n\n    function testWithdrawZero() public {\n        vault.withdraw(0, address(this), address(this));\n\n        assertEq(vault.balanceOf(address(this)), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(address(this))), 0);\n        assertEq(vault.totalSupply(), 0);\n        assertEq(vault.totalAssets(), 0);\n    }\n\n    function testVaultInteractionsForSomeoneElse() public {\n        // init 2 users with a 1e18 balance\n        address alice = address(0xABCD);\n        address bob = address(0xDCBA);\n        underlying.mint(alice, 1e18);\n        underlying.mint(bob, 1e18);\n\n        hevm.prank(alice);\n        underlying.approve(address(vault), 1e18);\n\n        hevm.prank(bob);\n        underlying.approve(address(vault), 1e18);\n\n        // alice deposits 1e18 for bob\n        hevm.prank(alice);\n        vault.deposit(1e18, bob);\n\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.balanceOf(bob), 1e18);\n        assertEq(underlying.balanceOf(alice), 0);\n\n        // bob mint 1e18 for alice\n        hevm.prank(bob);\n        vault.mint(1e18, alice);\n        assertEq(vault.balanceOf(alice), 1e18);\n        assertEq(vault.balanceOf(bob), 1e18);\n        assertEq(underlying.balanceOf(bob), 0);\n\n        // alice redeem 1e18 for bob\n        hevm.prank(alice);\n        vault.redeem(1e18, bob, alice);\n\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.balanceOf(bob), 1e18);\n        assertEq(underlying.balanceOf(bob), 1e18);\n\n        // bob withdraw 1e18 for alice\n        hevm.prank(bob);\n        vault.withdraw(1e18, alice, bob);\n\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.balanceOf(bob), 0);\n        assertEq(underlying.balanceOf(alice), 1e18);\n    }\n}\n"},"hedge/lib/solmate/src/test/ERC721.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {MockERC721} from \"./utils/mocks/MockERC721.sol\";\n\nimport {ERC721TokenReceiver} from \"../tokens/ERC721.sol\";\n\ncontract ERC721Recipient is ERC721TokenReceiver {\n    address public operator;\n    address public from;\n    uint256 public id;\n    bytes public data;\n\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        bytes calldata _data\n    ) public virtual override returns (bytes4) {\n        operator = _operator;\n        from = _from;\n        id = _id;\n        data = _data;\n\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n\ncontract RevertingERC721Recipient is ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC721TokenReceiver.onERC721Received.selector)));\n    }\n}\n\ncontract WrongReturnDataERC721Recipient is ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n}\n\ncontract NonERC721Recipient {}\n\ncontract ERC721Test is DSTestPlus {\n    MockERC721 token;\n\n    function setUp() public {\n        token = new MockERC721(\"Token\", \"TKN\");\n    }\n\n    function invariantMetadata() public {\n        assertEq(token.name(), \"Token\");\n        assertEq(token.symbol(), \"TKN\");\n    }\n\n    function testMint() public {\n        token.mint(address(0xBEEF), 1337);\n\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n    }\n\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1337);\n        token.burn(1337);\n\n        assertEq(token.balanceOf(address(0xBEEF)), 0);\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        token.ownerOf(1337);\n    }\n\n    function testApprove() public {\n        token.mint(address(this), 1337);\n\n        token.approve(address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0xBEEF));\n    }\n\n    function testApproveBurn() public {\n        token.mint(address(this), 1337);\n\n        token.approve(address(0xBEEF), 1337);\n\n        token.burn(1337);\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(token.getApproved(1337), address(0));\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        token.ownerOf(1337);\n    }\n\n    function testApproveAll() public {\n        token.setApprovalForAll(address(0xBEEF), true);\n\n        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));\n    }\n\n    function testTransferFrom() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.approve(address(this), 1337);\n\n        token.transferFrom(from, address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testTransferFromSelf() public {\n        token.mint(address(this), 1337);\n\n        token.transferFrom(address(this), address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.balanceOf(address(this)), 0);\n    }\n\n    function testTransferFromApproveAll() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.transferFrom(from, address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToEOA() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToERC721Recipient() public {\n        address from = address(0xABCD);\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(recipient), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), 1337);\n        assertBytesEq(recipient.data(), \"\");\n    }\n\n    function testSafeTransferFromToERC721RecipientWithData() public {\n        address from = address(0xABCD);\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(recipient), 1337, \"testing 123\");\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), 1337);\n        assertBytesEq(recipient.data(), \"testing 123\");\n    }\n\n    function testSafeMintToEOA() public {\n        token.safeMint(address(0xBEEF), 1337);\n\n        assertEq(token.ownerOf(1337), address(address(0xBEEF)));\n        assertEq(token.balanceOf(address(address(0xBEEF))), 1);\n    }\n\n    function testSafeMintToERC721Recipient() public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), 1337);\n\n        assertEq(token.ownerOf(1337), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.data(), \"\");\n    }\n\n    function testSafeMintToERC721RecipientWithData() public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), 1337, \"testing 123\");\n\n        assertEq(token.ownerOf(1337), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.data(), \"testing 123\");\n    }\n\n    function testFailMintToZero() public {\n        token.mint(address(0), 1337);\n    }\n\n    function testFailDoubleMint() public {\n        token.mint(address(0xBEEF), 1337);\n        token.mint(address(0xBEEF), 1337);\n    }\n\n    function testFailBurnUnMinted() public {\n        token.burn(1337);\n    }\n\n    function testFailDoubleBurn() public {\n        token.mint(address(0xBEEF), 1337);\n\n        token.burn(1337);\n        token.burn(1337);\n    }\n\n    function testFailApproveUnMinted() public {\n        token.approve(address(0xBEEF), 1337);\n    }\n\n    function testFailApproveUnAuthorized() public {\n        token.mint(address(0xCAFE), 1337);\n\n        token.approve(address(0xBEEF), 1337);\n    }\n\n    function testFailTransferFromUnOwned() public {\n        token.transferFrom(address(0xFEED), address(0xBEEF), 1337);\n    }\n\n    function testFailTransferFromWrongFrom() public {\n        token.mint(address(0xCAFE), 1337);\n\n        token.transferFrom(address(0xFEED), address(0xBEEF), 1337);\n    }\n\n    function testFailTransferFromToZero() public {\n        token.mint(address(this), 1337);\n\n        token.transferFrom(address(this), address(0), 1337);\n    }\n\n    function testFailTransferFromNotOwner() public {\n        token.mint(address(0xFEED), 1337);\n\n        token.transferFrom(address(0xFEED), address(0xBEEF), 1337);\n    }\n\n    function testFailSafeTransferFromToNonERC721Recipient() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new NonERC721Recipient()), 1337);\n    }\n\n    function testFailSafeTransferFromToNonERC721RecipientWithData() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new NonERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeTransferFromToRevertingERC721Recipient() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new RevertingERC721Recipient()), 1337);\n    }\n\n    function testFailSafeTransferFromToRevertingERC721RecipientWithData() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new RevertingERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeTransferFromToERC721RecipientWithWrongReturnData() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC721Recipient()), 1337);\n    }\n\n    function testFailSafeTransferFromToERC721RecipientWithWrongReturnDataWithData() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeMintToNonERC721Recipient() public {\n        token.safeMint(address(new NonERC721Recipient()), 1337);\n    }\n\n    function testFailSafeMintToNonERC721RecipientWithData() public {\n        token.safeMint(address(new NonERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeMintToRevertingERC721Recipient() public {\n        token.safeMint(address(new RevertingERC721Recipient()), 1337);\n    }\n\n    function testFailSafeMintToRevertingERC721RecipientWithData() public {\n        token.safeMint(address(new RevertingERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeMintToERC721RecipientWithWrongReturnData() public {\n        token.safeMint(address(new WrongReturnDataERC721Recipient()), 1337);\n    }\n\n    function testFailSafeMintToERC721RecipientWithWrongReturnDataWithData() public {\n        token.safeMint(address(new WrongReturnDataERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailBalanceOfZeroAddress() public view {\n        token.balanceOf(address(0));\n    }\n\n    function testFailOwnerOfUnminted() public view {\n        token.ownerOf(1337);\n    }\n\n    function testMetadata(string memory name, string memory symbol) public {\n        MockERC721 tkn = new MockERC721(name, symbol);\n\n        assertEq(tkn.name(), name);\n        assertEq(tkn.symbol(), symbol);\n    }\n\n    function testMint(address to, uint256 id) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(to, id);\n\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.ownerOf(id), to);\n    }\n\n    function testBurn(address to, uint256 id) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(to, id);\n        token.burn(id);\n\n        assertEq(token.balanceOf(to), 0);\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        token.ownerOf(id);\n    }\n\n    function testApprove(address to, uint256 id) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(address(this), id);\n\n        token.approve(to, id);\n\n        assertEq(token.getApproved(id), to);\n    }\n\n    function testApproveBurn(address to, uint256 id) public {\n        token.mint(address(this), id);\n\n        token.approve(address(to), id);\n\n        token.burn(id);\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(token.getApproved(id), address(0));\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        token.ownerOf(id);\n    }\n\n    function testApproveAll(address to, bool approved) public {\n        token.setApprovalForAll(to, approved);\n\n        assertBoolEq(token.isApprovedForAll(address(this), to), approved);\n    }\n\n    function testTransferFrom(uint256 id, address to) public {\n        address from = address(0xABCD);\n\n        if (to == address(0) || to == from) to = address(0xBEEF);\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.approve(address(this), id);\n\n        token.transferFrom(from, to, id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testTransferFromSelf(uint256 id, address to) public {\n        if (to == address(0) || to == address(this)) to = address(0xBEEF);\n\n        token.mint(address(this), id);\n\n        token.transferFrom(address(this), to, id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(address(this)), 0);\n    }\n\n    function testTransferFromApproveAll(uint256 id, address to) public {\n        address from = address(0xABCD);\n\n        if (to == address(0) || to == from) to = address(0xBEEF);\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.transferFrom(from, to, id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToEOA(uint256 id, address to) public {\n        address from = address(0xABCD);\n\n        if (to == address(0) || to == from) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, to, id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToERC721Recipient(uint256 id) public {\n        address from = address(0xABCD);\n\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(recipient), id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), id);\n        assertBytesEq(recipient.data(), \"\");\n    }\n\n    function testSafeTransferFromToERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        address from = address(0xABCD);\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(recipient), id, data);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), id);\n        assertBytesEq(recipient.data(), data);\n    }\n\n    function testSafeMintToEOA(uint256 id, address to) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        token.safeMint(to, id);\n\n        assertEq(token.ownerOf(id), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n    }\n\n    function testSafeMintToERC721Recipient(uint256 id) public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), id);\n\n        assertEq(token.ownerOf(id), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), id);\n        assertBytesEq(to.data(), \"\");\n    }\n\n    function testSafeMintToERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), id, data);\n\n        assertEq(token.ownerOf(id), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), id);\n        assertBytesEq(to.data(), data);\n    }\n\n    function testFailMintToZero(uint256 id) public {\n        token.mint(address(0), id);\n    }\n\n    function testFailDoubleMint(uint256 id, address to) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(to, id);\n        token.mint(to, id);\n    }\n\n    function testFailBurnUnMinted(uint256 id) public {\n        token.burn(id);\n    }\n\n    function testFailDoubleBurn(uint256 id, address to) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(to, id);\n\n        token.burn(id);\n        token.burn(id);\n    }\n\n    function testFailApproveUnMinted(uint256 id, address to) public {\n        token.approve(to, id);\n    }\n\n    function testFailApproveUnAuthorized(\n        address owner,\n        uint256 id,\n        address to\n    ) public {\n        if (owner == address(0) || owner == address(this)) owner = address(0xBEEF);\n\n        token.mint(owner, id);\n\n        token.approve(to, id);\n    }\n\n    function testFailTransferFromUnOwned(\n        address from,\n        address to,\n        uint256 id\n    ) public {\n        token.transferFrom(from, to, id);\n    }\n\n    function testFailTransferFromWrongFrom(\n        address owner,\n        address from,\n        address to,\n        uint256 id\n    ) public {\n        if (owner == address(0)) to = address(0xBEEF);\n        if (from == owner) revert();\n\n        token.mint(owner, id);\n\n        token.transferFrom(from, to, id);\n    }\n\n    function testFailTransferFromToZero(uint256 id) public {\n        token.mint(address(this), id);\n\n        token.transferFrom(address(this), address(0), id);\n    }\n\n    function testFailTransferFromNotOwner(\n        address from,\n        address to,\n        uint256 id\n    ) public {\n        if (from == address(this)) from = address(0xBEEF);\n\n        token.mint(from, id);\n\n        token.transferFrom(from, to, id);\n    }\n\n    function testFailSafeTransferFromToNonERC721Recipient(uint256 id) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new NonERC721Recipient()), id);\n    }\n\n    function testFailSafeTransferFromToNonERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new NonERC721Recipient()), id, data);\n    }\n\n    function testFailSafeTransferFromToRevertingERC721Recipient(uint256 id) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new RevertingERC721Recipient()), id);\n    }\n\n    function testFailSafeTransferFromToRevertingERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new RevertingERC721Recipient()), id, data);\n    }\n\n    function testFailSafeTransferFromToERC721RecipientWithWrongReturnData(uint256 id) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC721Recipient()), id);\n    }\n\n    function testFailSafeTransferFromToERC721RecipientWithWrongReturnDataWithData(uint256 id, bytes calldata data)\n        public\n    {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC721Recipient()), id, data);\n    }\n\n    function testFailSafeMintToNonERC721Recipient(uint256 id) public {\n        token.safeMint(address(new NonERC721Recipient()), id);\n    }\n\n    function testFailSafeMintToNonERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        token.safeMint(address(new NonERC721Recipient()), id, data);\n    }\n\n    function testFailSafeMintToRevertingERC721Recipient(uint256 id) public {\n        token.safeMint(address(new RevertingERC721Recipient()), id);\n    }\n\n    function testFailSafeMintToRevertingERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        token.safeMint(address(new RevertingERC721Recipient()), id, data);\n    }\n\n    function testFailSafeMintToERC721RecipientWithWrongReturnData(uint256 id) public {\n        token.safeMint(address(new WrongReturnDataERC721Recipient()), id);\n    }\n\n    function testFailSafeMintToERC721RecipientWithWrongReturnDataWithData(uint256 id, bytes calldata data) public {\n        token.safeMint(address(new WrongReturnDataERC721Recipient()), id, data);\n    }\n\n    function testFailOwnerOfUnminted(uint256 id) public view {\n        token.ownerOf(id);\n    }\n}\n"},"hedge/lib/solmate/src/test/FixedPointMathLib.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\ncontract FixedPointMathLibTest is DSTestPlus {\n    function testMulWadDown() public {\n        assertEq(FixedPointMathLib.mulWadDown(2.5e18, 0.5e18), 1.25e18);\n        assertEq(FixedPointMathLib.mulWadDown(3e18, 1e18), 3e18);\n        assertEq(FixedPointMathLib.mulWadDown(369, 271), 0);\n    }\n\n    function testMulWadDownEdgeCases() public {\n        assertEq(FixedPointMathLib.mulWadDown(0, 1e18), 0);\n        assertEq(FixedPointMathLib.mulWadDown(1e18, 0), 0);\n        assertEq(FixedPointMathLib.mulWadDown(0, 0), 0);\n    }\n\n    function testMulWadUp() public {\n        assertEq(FixedPointMathLib.mulWadUp(2.5e18, 0.5e18), 1.25e18);\n        assertEq(FixedPointMathLib.mulWadUp(3e18, 1e18), 3e18);\n        assertEq(FixedPointMathLib.mulWadUp(369, 271), 1);\n    }\n\n    function testMulWadUpEdgeCases() public {\n        assertEq(FixedPointMathLib.mulWadUp(0, 1e18), 0);\n        assertEq(FixedPointMathLib.mulWadUp(1e18, 0), 0);\n        assertEq(FixedPointMathLib.mulWadUp(0, 0), 0);\n    }\n\n    function testDivWadDown() public {\n        assertEq(FixedPointMathLib.divWadDown(1.25e18, 0.5e18), 2.5e18);\n        assertEq(FixedPointMathLib.divWadDown(3e18, 1e18), 3e18);\n        assertEq(FixedPointMathLib.divWadDown(2, 100000000000000e18), 0);\n    }\n\n    function testDivWadDownEdgeCases() public {\n        assertEq(FixedPointMathLib.divWadDown(0, 1e18), 0);\n    }\n\n    function testFailDivWadDownZeroDenominator() public pure {\n        FixedPointMathLib.divWadDown(1e18, 0);\n    }\n\n    function testDivWadUp() public {\n        assertEq(FixedPointMathLib.divWadUp(1.25e18, 0.5e18), 2.5e18);\n        assertEq(FixedPointMathLib.divWadUp(3e18, 1e18), 3e18);\n        assertEq(FixedPointMathLib.divWadUp(2, 100000000000000e18), 1);\n    }\n\n    function testDivWadUpEdgeCases() public {\n        assertEq(FixedPointMathLib.divWadUp(0, 1e18), 0);\n    }\n\n    function testFailDivWadUpZeroDenominator() public pure {\n        FixedPointMathLib.divWadUp(1e18, 0);\n    }\n\n    function testMulDivDown() public {\n        assertEq(FixedPointMathLib.mulDivDown(2.5e27, 0.5e27, 1e27), 1.25e27);\n        assertEq(FixedPointMathLib.mulDivDown(2.5e18, 0.5e18, 1e18), 1.25e18);\n        assertEq(FixedPointMathLib.mulDivDown(2.5e8, 0.5e8, 1e8), 1.25e8);\n        assertEq(FixedPointMathLib.mulDivDown(369, 271, 1e2), 999);\n\n        assertEq(FixedPointMathLib.mulDivDown(1e27, 1e27, 2e27), 0.5e27);\n        assertEq(FixedPointMathLib.mulDivDown(1e18, 1e18, 2e18), 0.5e18);\n        assertEq(FixedPointMathLib.mulDivDown(1e8, 1e8, 2e8), 0.5e8);\n\n        assertEq(FixedPointMathLib.mulDivDown(2e27, 3e27, 2e27), 3e27);\n        assertEq(FixedPointMathLib.mulDivDown(3e18, 2e18, 3e18), 2e18);\n        assertEq(FixedPointMathLib.mulDivDown(2e8, 3e8, 2e8), 3e8);\n    }\n\n    function testMulDivDownEdgeCases() public {\n        assertEq(FixedPointMathLib.mulDivDown(0, 1e18, 1e18), 0);\n        assertEq(FixedPointMathLib.mulDivDown(1e18, 0, 1e18), 0);\n        assertEq(FixedPointMathLib.mulDivDown(0, 0, 1e18), 0);\n    }\n\n    function testFailMulDivDownZeroDenominator() public pure {\n        FixedPointMathLib.mulDivDown(1e18, 1e18, 0);\n    }\n\n    function testMulDivUp() public {\n        assertEq(FixedPointMathLib.mulDivUp(2.5e27, 0.5e27, 1e27), 1.25e27);\n        assertEq(FixedPointMathLib.mulDivUp(2.5e18, 0.5e18, 1e18), 1.25e18);\n        assertEq(FixedPointMathLib.mulDivUp(2.5e8, 0.5e8, 1e8), 1.25e8);\n        assertEq(FixedPointMathLib.mulDivUp(369, 271, 1e2), 1000);\n\n        assertEq(FixedPointMathLib.mulDivUp(1e27, 1e27, 2e27), 0.5e27);\n        assertEq(FixedPointMathLib.mulDivUp(1e18, 1e18, 2e18), 0.5e18);\n        assertEq(FixedPointMathLib.mulDivUp(1e8, 1e8, 2e8), 0.5e8);\n\n        assertEq(FixedPointMathLib.mulDivUp(2e27, 3e27, 2e27), 3e27);\n        assertEq(FixedPointMathLib.mulDivUp(3e18, 2e18, 3e18), 2e18);\n        assertEq(FixedPointMathLib.mulDivUp(2e8, 3e8, 2e8), 3e8);\n    }\n\n    function testMulDivUpEdgeCases() public {\n        assertEq(FixedPointMathLib.mulDivUp(0, 1e18, 1e18), 0);\n        assertEq(FixedPointMathLib.mulDivUp(1e18, 0, 1e18), 0);\n        assertEq(FixedPointMathLib.mulDivUp(0, 0, 1e18), 0);\n    }\n\n    function testFailMulDivUpZeroDenominator() public pure {\n        FixedPointMathLib.mulDivUp(1e18, 1e18, 0);\n    }\n\n    function testRPow() public {\n        assertEq(FixedPointMathLib.rpow(2e27, 2, 1e27), 4e27);\n        assertEq(FixedPointMathLib.rpow(2e18, 2, 1e18), 4e18);\n        assertEq(FixedPointMathLib.rpow(2e8, 2, 1e8), 4e8);\n        assertEq(FixedPointMathLib.rpow(8, 3, 1), 512);\n    }\n\n    function testSqrt() public {\n        assertEq(FixedPointMathLib.sqrt(0), 0);\n        assertEq(FixedPointMathLib.sqrt(1), 1);\n        assertEq(FixedPointMathLib.sqrt(2704), 52);\n        assertEq(FixedPointMathLib.sqrt(110889), 333);\n        assertEq(FixedPointMathLib.sqrt(32239684), 5678);\n        assertEq(FixedPointMathLib.sqrt(type(uint256).max), 340282366920938463463374607431768211455);\n    }\n\n    function testSqrtBackHashedSingle() public {\n        testSqrtBackHashed(123);\n    }\n\n    function testMulWadDown(uint256 x, uint256 y) public {\n        // Ignore cases where x * y overflows.\n        unchecked {\n            if (x != 0 && (x * y) / x != y) return;\n        }\n\n        assertEq(FixedPointMathLib.mulWadDown(x, y), (x * y) / 1e18);\n    }\n\n    function testFailMulWadDownOverflow(uint256 x, uint256 y) public pure {\n        // Ignore cases where x * y does not overflow.\n        unchecked {\n            if ((x * y) / x == y) revert();\n        }\n\n        FixedPointMathLib.mulWadDown(x, y);\n    }\n\n    function testMulWadUp(uint256 x, uint256 y) public {\n        // Ignore cases where x * y overflows.\n        unchecked {\n            if (x != 0 && (x * y) / x != y) return;\n        }\n\n        assertEq(FixedPointMathLib.mulWadUp(x, y), x * y == 0 ? 0 : (x * y - 1) / 1e18 + 1);\n    }\n\n    function testFailMulWadUpOverflow(uint256 x, uint256 y) public pure {\n        // Ignore cases where x * y does not overflow.\n        unchecked {\n            if ((x * y) / x == y) revert();\n        }\n\n        FixedPointMathLib.mulWadUp(x, y);\n    }\n\n    function testDivWadDown(uint256 x, uint256 y) public {\n        // Ignore cases where x * WAD overflows or y is 0.\n        unchecked {\n            if (y == 0 || (x != 0 && (x * 1e18) / 1e18 != x)) return;\n        }\n\n        assertEq(FixedPointMathLib.divWadDown(x, y), (x * 1e18) / y);\n    }\n\n    function testFailDivWadDownOverflow(uint256 x, uint256 y) public pure {\n        // Ignore cases where x * WAD does not overflow or y is 0.\n        unchecked {\n            if (y == 0 || (x * 1e18) / 1e18 == x) revert();\n        }\n\n        FixedPointMathLib.divWadDown(x, y);\n    }\n\n    function testFailDivWadDownZeroDenominator(uint256 x) public pure {\n        FixedPointMathLib.divWadDown(x, 0);\n    }\n\n    function testDivWadUp(uint256 x, uint256 y) public {\n        // Ignore cases where x * WAD overflows or y is 0.\n        unchecked {\n            if (y == 0 || (x != 0 && (x * 1e18) / 1e18 != x)) return;\n        }\n\n        assertEq(FixedPointMathLib.divWadUp(x, y), x == 0 ? 0 : (x * 1e18 - 1) / y + 1);\n    }\n\n    function testFailDivWadUpOverflow(uint256 x, uint256 y) public pure {\n        // Ignore cases where x * WAD does not overflow or y is 0.\n        unchecked {\n            if (y == 0 || (x * 1e18) / 1e18 == x) revert();\n        }\n\n        FixedPointMathLib.divWadUp(x, y);\n    }\n\n    function testFailDivWadUpZeroDenominator(uint256 x) public pure {\n        FixedPointMathLib.divWadUp(x, 0);\n    }\n\n    function testMulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) public {\n        // Ignore cases where x * y overflows or denominator is 0.\n        unchecked {\n            if (denominator == 0 || (x != 0 && (x * y) / x != y)) return;\n        }\n\n        assertEq(FixedPointMathLib.mulDivDown(x, y, denominator), (x * y) / denominator);\n    }\n\n    function testFailMulDivDownOverflow(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) public pure {\n        // Ignore cases where x * y does not overflow or denominator is 0.\n        unchecked {\n            if (denominator == 0 || (x * y) / x == y) revert();\n        }\n\n        FixedPointMathLib.mulDivDown(x, y, denominator);\n    }\n\n    function testFailMulDivDownZeroDenominator(uint256 x, uint256 y) public pure {\n        FixedPointMathLib.mulDivDown(x, y, 0);\n    }\n\n    function testMulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) public {\n        // Ignore cases where x * y overflows or denominator is 0.\n        unchecked {\n            if (denominator == 0 || (x != 0 && (x * y) / x != y)) return;\n        }\n\n        assertEq(FixedPointMathLib.mulDivUp(x, y, denominator), x * y == 0 ? 0 : (x * y - 1) / denominator + 1);\n    }\n\n    function testFailMulDivUpOverflow(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) public pure {\n        // Ignore cases where x * y does not overflow or denominator is 0.\n        unchecked {\n            if (denominator == 0 || (x * y) / x == y) revert();\n        }\n\n        FixedPointMathLib.mulDivUp(x, y, denominator);\n    }\n\n    function testFailMulDivUpZeroDenominator(uint256 x, uint256 y) public pure {\n        FixedPointMathLib.mulDivUp(x, y, 0);\n    }\n\n    function testDifferentiallyFuzzSqrt(uint256 x) public {\n        assertEq(FixedPointMathLib.sqrt(x), uniswapSqrt(x));\n        assertEq(FixedPointMathLib.sqrt(x), abdkSqrt(x));\n    }\n\n    function testSqrt(uint256 x) public {\n        uint256 root = FixedPointMathLib.sqrt(x);\n        uint256 next = root + 1;\n\n        // Ignore cases where next * next overflows.\n        unchecked {\n            if (next * next < next) return;\n        }\n\n        assertTrue(root * root <= x && next * next > x);\n    }\n\n    function testSqrtBack(uint256 x) public {\n        unchecked {\n            x >>= 128;\n            while (x != 0) {\n                assertEq(FixedPointMathLib.sqrt(x * x), x);\n                x >>= 1;\n            }\n        }\n    }\n\n    function testSqrtBackHashed(uint256 x) public {\n        testSqrtBack(uint256(keccak256(abi.encode(x))));\n    }\n\n    function uniswapSqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function abdkSqrt(uint256 x) private pure returns (uint256) {\n        unchecked {\n            if (x == 0) return 0;\n            else {\n                uint256 xx = x;\n                uint256 r = 1;\n                if (xx >= 0x100000000000000000000000000000000) {\n                    xx >>= 128;\n                    r <<= 64;\n                }\n                if (xx >= 0x10000000000000000) {\n                    xx >>= 64;\n                    r <<= 32;\n                }\n                if (xx >= 0x100000000) {\n                    xx >>= 32;\n                    r <<= 16;\n                }\n                if (xx >= 0x10000) {\n                    xx >>= 16;\n                    r <<= 8;\n                }\n                if (xx >= 0x100) {\n                    xx >>= 8;\n                    r <<= 4;\n                }\n                if (xx >= 0x10) {\n                    xx >>= 4;\n                    r <<= 2;\n                }\n                if (xx >= 0x8) {\n                    r <<= 1;\n                }\n                r = (r + x / r) >> 1;\n                r = (r + x / r) >> 1;\n                r = (r + x / r) >> 1;\n                r = (r + x / r) >> 1;\n                r = (r + x / r) >> 1;\n                r = (r + x / r) >> 1;\n                r = (r + x / r) >> 1; // Seven iterations should be enough\n                uint256 r1 = x / r;\n                return r < r1 ? r : r1;\n            }\n        }\n    }\n}\n"},"hedge/lib/solmate/src/test/LibString.t.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {LibString} from \"../utils/LibString.sol\";\n\ncontract LibStringTest is DSTestPlus {\n    function testToString() public {\n        assertEq(LibString.toString(uint256(0)), \"0\");\n        assertEq(LibString.toString(uint256(1)), \"1\");\n        assertEq(LibString.toString(uint256(17)), \"17\");\n        assertEq(LibString.toString(uint256(99999999)), \"99999999\");\n        assertEq(LibString.toString(uint256(99999999999)), \"99999999999\");\n        assertEq(LibString.toString(uint256(2342343923423)), \"2342343923423\");\n        assertEq(LibString.toString(uint256(98765685434567)), \"98765685434567\");\n    }\n\n    function testToStringIntPositive() public {\n        assertEq(LibString.toString(int256(0)), \"0\");\n        assertEq(LibString.toString(int256(1)), \"1\");\n        assertEq(LibString.toString(int256(17)), \"17\");\n        assertEq(LibString.toString(int256(99999999)), \"99999999\");\n        assertEq(LibString.toString(int256(99999999999)), \"99999999999\");\n        assertEq(LibString.toString(int256(2342343923423)), \"2342343923423\");\n        assertEq(LibString.toString(int256(98765685434567)), \"98765685434567\");\n    }\n\n    function testToStringIntNegative() public {\n        assertEq(LibString.toString(int256(-0)), \"0\");\n        assertEq(LibString.toString(int256(-17)), \"-17\");\n        assertEq(LibString.toString(int256(-99999999)), \"-99999999\");\n        assertEq(LibString.toString(int256(-99999999999)), \"-99999999999\");\n        assertEq(LibString.toString(int256(-2342343923423)), \"-2342343923423\");\n        assertEq(LibString.toString(int256(-98765685434567)), \"-98765685434567\");\n    }\n\n    function testDifferentiallyFuzzToString(uint256 value, bytes calldata brutalizeWith)\n        public\n        brutalizeMemory(brutalizeWith)\n    {\n        string memory libString = LibString.toString(value);\n        string memory oz = toStringOZ(value);\n\n        assertEq(bytes(libString).length, bytes(oz).length);\n        assertEq(libString, oz);\n    }\n\n    function testDifferentiallyFuzzToStringInt(int256 value, bytes calldata brutalizeWith)\n        public\n        brutalizeMemory(brutalizeWith)\n    {\n        string memory libString = LibString.toString(value);\n        string memory oz = toStringOZ(value);\n\n        assertEq(bytes(libString).length, bytes(oz).length);\n        assertEq(libString, oz);\n    }\n\n    function testToStringOverwrite() public {\n        string memory str = LibString.toString(uint256(1));\n\n        bytes32 data;\n        bytes32 expected;\n\n        assembly {\n            // Imagine a high level allocation writing something to the current free memory.\n            // Should have sufficient higher order bits for this to be visible\n            mstore(mload(0x40), not(0))\n            // Correctly allocate 32 more bytes, to avoid more interference\n            mstore(0x40, add(mload(0x40), 32))\n            data := mload(add(str, 32))\n\n            // the expected value should be the uft-8 encoding of 1 (49),\n            // followed by clean bits. We achieve this by taking the value and\n            // shifting left to the end of the 32 byte word\n            expected := shl(248, 49)\n        }\n\n        assertEq(data, expected);\n    }\n\n    function testToStringDirty() public {\n        uint256 freememptr;\n        // Make the next 4 bytes of the free memory dirty\n        assembly {\n            let dirty := not(0)\n            freememptr := mload(0x40)\n            mstore(freememptr, dirty)\n            mstore(add(freememptr, 32), dirty)\n            mstore(add(freememptr, 64), dirty)\n            mstore(add(freememptr, 96), dirty)\n            mstore(add(freememptr, 128), dirty)\n        }\n        string memory str = LibString.toString(uint256(1));\n        uint256 len;\n        bytes32 data;\n        bytes32 expected;\n        assembly {\n            freememptr := str\n            len := mload(str)\n            data := mload(add(str, 32))\n            // the expected value should be the uft-8 encoding of 1 (49),\n            // followed by clean bits. We achieve this by taking the value and\n            // shifting left to the end of the 32 byte word\n            expected := shl(248, 49)\n        }\n        emit log_named_uint(\"str: \", freememptr);\n        emit log_named_uint(\"len: \", len);\n        emit log_named_bytes32(\"data: \", data);\n        assembly {\n            freememptr := mload(0x40)\n        }\n        emit log_named_uint(\"memptr: \", freememptr);\n\n        assertEq(data, expected);\n    }\n}\n\nfunction toStringOZ(int256 value) pure returns (string memory) {\n    return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toStringOZ(absOZ(value))));\n}\n\nfunction toStringOZ(uint256 value) pure returns (string memory) {\n    if (value == 0) {\n        return \"0\";\n    }\n    uint256 temp = value;\n    uint256 digits;\n    while (temp != 0) {\n        digits++;\n        temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n        digits -= 1;\n        buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n        value /= 10;\n    }\n    return string(buffer);\n}\n\nfunction absOZ(int256 n) pure returns (uint256) {\n    unchecked {\n        // must be unchecked in order to support `n = type(int256).min`\n        return uint256(n >= 0 ? n : -n);\n    }\n}\n"},"hedge/lib/solmate/src/test/MerkleProofLib.t.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {MerkleProofLib} from \"../utils/MerkleProofLib.sol\";\n\ncontract MerkleProofLibTest is DSTestPlus {\n    function testVerifyEmptyMerkleProofSuppliedLeafAndRootSame() public {\n        bytes32[] memory proof;\n        assertBoolEq(this.verify(proof, 0x00, 0x00), true);\n    }\n\n    function testVerifyEmptyMerkleProofSuppliedLeafAndRootDifferent() public {\n        bytes32[] memory proof;\n        bytes32 leaf = \"a\";\n        assertBoolEq(this.verify(proof, 0x00, leaf), false);\n    }\n\n    function testValidProofSupplied() public {\n        // Merkle tree created from leaves ['a', 'b', 'c'].\n        // Leaf is 'a'.\n        bytes32[] memory proof = new bytes32[](2);\n        proof[0] = 0xb5553de315e0edf504d9150af82dafa5c4667fa618ed0a6f19c69b41166c5510;\n        proof[1] = 0x0b42b6393c1f53060fe3ddbfcd7aadcca894465a5a438f69c87d790b2299b9b2;\n        bytes32 root = 0x5842148bc6ebeb52af882a317c765fccd3ae80589b21a9b8cbf21abb630e46a7;\n        bytes32 leaf = 0x3ac225168df54212a25c1c01fd35bebfea408fdac2e31ddd6f80a4bbf9a5f1cb;\n        assertBoolEq(this.verify(proof, root, leaf), true);\n    }\n\n    function testVerifyInvalidProofSupplied() public {\n        // Merkle tree created from leaves ['a', 'b', 'c'].\n        // Leaf is 'a'.\n        // Proof is same as testValidProofSupplied but last byte of first element is modified.\n        bytes32[] memory proof = new bytes32[](2);\n        proof[0] = 0xb5553de315e0edf504d9150af82dafa5c4667fa618ed0a6f19c69b41166c5511;\n        proof[1] = 0x0b42b6393c1f53060fe3ddbfcd7aadcca894465a5a438f69c87d790b2299b9b2;\n        bytes32 root = 0x5842148bc6ebeb52af882a317c765fccd3ae80589b21a9b8cbf21abb630e46a7;\n        bytes32 leaf = 0x3ac225168df54212a25c1c01fd35bebfea408fdac2e31ddd6f80a4bbf9a5f1cb;\n        assertBoolEq(this.verify(proof, root, leaf), false);\n    }\n\n    function verify(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) external pure returns (bool) {\n        return MerkleProofLib.verify(proof, root, leaf);\n    }\n}\n"},"hedge/lib/solmate/src/test/MultiRolesAuthority.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {MockAuthority} from \"./utils/mocks/MockAuthority.sol\";\n\nimport {Authority} from \"../auth/Auth.sol\";\n\nimport {MultiRolesAuthority} from \"../auth/authorities/MultiRolesAuthority.sol\";\n\ncontract MultiRolesAuthorityTest is DSTestPlus {\n    MultiRolesAuthority multiRolesAuthority;\n\n    function setUp() public {\n        multiRolesAuthority = new MultiRolesAuthority(address(this), Authority(address(0)));\n    }\n\n    function testSetRoles() public {\n        assertFalse(multiRolesAuthority.doesUserHaveRole(address(0xBEEF), 0));\n\n        multiRolesAuthority.setUserRole(address(0xBEEF), 0, true);\n        assertTrue(multiRolesAuthority.doesUserHaveRole(address(0xBEEF), 0));\n\n        multiRolesAuthority.setUserRole(address(0xBEEF), 0, false);\n        assertFalse(multiRolesAuthority.doesUserHaveRole(address(0xBEEF), 0));\n    }\n\n    function testSetRoleCapabilities() public {\n        assertFalse(multiRolesAuthority.doesRoleHaveCapability(0, 0xBEEFCAFE));\n\n        multiRolesAuthority.setRoleCapability(0, 0xBEEFCAFE, true);\n        assertTrue(multiRolesAuthority.doesRoleHaveCapability(0, 0xBEEFCAFE));\n\n        multiRolesAuthority.setRoleCapability(0, 0xBEEFCAFE, false);\n        assertFalse(multiRolesAuthority.doesRoleHaveCapability(0, 0xBEEFCAFE));\n    }\n\n    function testSetPublicCapabilities() public {\n        assertFalse(multiRolesAuthority.isCapabilityPublic(0xBEEFCAFE));\n\n        multiRolesAuthority.setPublicCapability(0xBEEFCAFE, true);\n        assertTrue(multiRolesAuthority.isCapabilityPublic(0xBEEFCAFE));\n\n        multiRolesAuthority.setPublicCapability(0xBEEFCAFE, false);\n        assertFalse(multiRolesAuthority.isCapabilityPublic(0xBEEFCAFE));\n    }\n\n    function testSetTargetCustomAuthority() public {\n        assertEq(address(multiRolesAuthority.getTargetCustomAuthority(address(0xBEEF))), address(0));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xBEEF), Authority(address(0xCAFE)));\n        assertEq(address(multiRolesAuthority.getTargetCustomAuthority(address(0xBEEF))), address(0xCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xBEEF), Authority(address(0)));\n        assertEq(address(multiRolesAuthority.getTargetCustomAuthority(address(0xBEEF))), address(0));\n    }\n\n    function testCanCallWithAuthorizedRole() public {\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setUserRole(address(0xBEEF), 0, true);\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setRoleCapability(0, 0xBEEFCAFE, true);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setRoleCapability(0, 0xBEEFCAFE, false);\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setRoleCapability(0, 0xBEEFCAFE, true);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setUserRole(address(0xBEEF), 0, false);\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testCanCallPublicCapability() public {\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setPublicCapability(0xBEEFCAFE, true);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setPublicCapability(0xBEEFCAFE, false);\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testCanCallWithCustomAuthority() public {\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), new MockAuthority(false));\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), new MockAuthority(true));\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), new MockAuthority(false));\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), Authority(address(0)));\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), new MockAuthority(true));\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testCanCallWithCustomAuthorityOverridesPublicCapability() public {\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setPublicCapability(0xBEEFCAFE, true);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), new MockAuthority(false));\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), new MockAuthority(true));\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setPublicCapability(0xBEEFCAFE, false);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), Authority(address(0)));\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setPublicCapability(0xBEEFCAFE, true);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testCanCallWithCustomAuthorityOverridesUserWithRole() public {\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setUserRole(address(0xBEEF), 0, true);\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setRoleCapability(0, 0xBEEFCAFE, true);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), new MockAuthority(false));\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), new MockAuthority(true));\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setUserRole(address(0xBEEF), 0, false);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), Authority(address(0)));\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setUserRole(address(0xBEEF), 0, true);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setRoleCapability(0, 0xBEEFCAFE, false);\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setUserRole(address(0xBEEF), 0, false);\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testSetRoles(address user, uint8 role) public {\n        assertFalse(multiRolesAuthority.doesUserHaveRole(user, role));\n\n        multiRolesAuthority.setUserRole(user, role, true);\n        assertTrue(multiRolesAuthority.doesUserHaveRole(user, role));\n\n        multiRolesAuthority.setUserRole(user, role, false);\n        assertFalse(multiRolesAuthority.doesUserHaveRole(user, role));\n    }\n\n    function testSetRoleCapabilities(uint8 role, bytes4 functionSig) public {\n        assertFalse(multiRolesAuthority.doesRoleHaveCapability(role, functionSig));\n\n        multiRolesAuthority.setRoleCapability(role, functionSig, true);\n        assertTrue(multiRolesAuthority.doesRoleHaveCapability(role, functionSig));\n\n        multiRolesAuthority.setRoleCapability(role, functionSig, false);\n        assertFalse(multiRolesAuthority.doesRoleHaveCapability(role, functionSig));\n    }\n\n    function testSetPublicCapabilities(bytes4 functionSig) public {\n        assertFalse(multiRolesAuthority.isCapabilityPublic(functionSig));\n\n        multiRolesAuthority.setPublicCapability(functionSig, true);\n        assertTrue(multiRolesAuthority.isCapabilityPublic(functionSig));\n\n        multiRolesAuthority.setPublicCapability(functionSig, false);\n        assertFalse(multiRolesAuthority.isCapabilityPublic(functionSig));\n    }\n\n    function testSetTargetCustomAuthority(address user, Authority customAuthority) public {\n        assertEq(address(multiRolesAuthority.getTargetCustomAuthority(user)), address(0));\n\n        multiRolesAuthority.setTargetCustomAuthority(user, customAuthority);\n        assertEq(address(multiRolesAuthority.getTargetCustomAuthority(user)), address(customAuthority));\n\n        multiRolesAuthority.setTargetCustomAuthority(user, Authority(address(0)));\n        assertEq(address(multiRolesAuthority.getTargetCustomAuthority(user)), address(0));\n    }\n\n    function testCanCallWithAuthorizedRole(\n        address user,\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setUserRole(user, role, true);\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setRoleCapability(role, functionSig, true);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setRoleCapability(role, functionSig, false);\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setRoleCapability(role, functionSig, true);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setUserRole(user, role, false);\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n    }\n\n    function testCanCallPublicCapability(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setPublicCapability(functionSig, true);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setPublicCapability(functionSig, false);\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n    }\n\n    function testCanCallWithCustomAuthority(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, new MockAuthority(false));\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, new MockAuthority(true));\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, new MockAuthority(false));\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, Authority(address(0)));\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, new MockAuthority(true));\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n    }\n\n    function testCanCallWithCustomAuthorityOverridesPublicCapability(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setPublicCapability(functionSig, true);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, new MockAuthority(false));\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, new MockAuthority(true));\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setPublicCapability(functionSig, false);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, Authority(address(0)));\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setPublicCapability(functionSig, true);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n    }\n\n    function testCanCallWithCustomAuthorityOverridesUserWithRole(\n        address user,\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setUserRole(user, role, true);\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setRoleCapability(role, functionSig, true);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, new MockAuthority(false));\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, new MockAuthority(true));\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setUserRole(user, role, false);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, Authority(address(0)));\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setUserRole(user, role, true);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setRoleCapability(role, functionSig, false);\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setUserRole(user, role, false);\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n    }\n}\n"},"hedge/lib/solmate/src/test/Owned.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {MockOwned} from \"./utils/mocks/MockOwned.sol\";\n\ncontract OwnedTest is DSTestPlus {\n    MockOwned mockOwned;\n\n    function setUp() public {\n        mockOwned = new MockOwned();\n    }\n\n    function testTransferOwnership() public {\n        testTransferOwnership(address(0xBEEF));\n    }\n\n    function testCallFunctionAsNonOwner() public {\n        testCallFunctionAsNonOwner(address(0));\n    }\n\n    function testCallFunctionAsOwner() public {\n        mockOwned.updateFlag();\n    }\n\n    function testTransferOwnership(address newOwner) public {\n        mockOwned.transferOwnership(newOwner);\n\n        assertEq(mockOwned.owner(), newOwner);\n    }\n\n    function testCallFunctionAsNonOwner(address owner) public {\n        hevm.assume(owner != address(this));\n\n        mockOwned.transferOwnership(owner);\n\n        hevm.expectRevert(\"UNAUTHORIZED\");\n        mockOwned.updateFlag();\n    }\n}\n"},"hedge/lib/solmate/src/test/ReentrancyGuard.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {ReentrancyGuard} from \"../utils/ReentrancyGuard.sol\";\n\ncontract RiskyContract is ReentrancyGuard {\n    uint256 public enterTimes;\n\n    function unprotectedCall() public {\n        enterTimes++;\n\n        if (enterTimes > 1) return;\n\n        this.protectedCall();\n    }\n\n    function protectedCall() public nonReentrant {\n        enterTimes++;\n\n        if (enterTimes > 1) return;\n\n        this.protectedCall();\n    }\n\n    function overprotectedCall() public nonReentrant {}\n}\n\ncontract ReentrancyGuardTest is DSTestPlus {\n    RiskyContract riskyContract;\n\n    function setUp() public {\n        riskyContract = new RiskyContract();\n    }\n\n    function invariantReentrancyStatusAlways1() public {\n        assertEq(uint256(hevm.load(address(riskyContract), 0)), 1);\n    }\n\n    function testFailUnprotectedCall() public {\n        riskyContract.unprotectedCall();\n\n        assertEq(riskyContract.enterTimes(), 1);\n    }\n\n    function testProtectedCall() public {\n        try riskyContract.protectedCall() {\n            fail(\"Reentrancy Guard Failed To Stop Attacker\");\n        } catch {}\n    }\n\n    function testNoReentrancy() public {\n        riskyContract.overprotectedCall();\n    }\n}\n"},"hedge/lib/solmate/src/test/RolesAuthority.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {MockAuthority} from \"./utils/mocks/MockAuthority.sol\";\n\nimport {Authority} from \"../auth/Auth.sol\";\n\nimport {RolesAuthority} from \"../auth/authorities/RolesAuthority.sol\";\n\ncontract RolesAuthorityTest is DSTestPlus {\n    RolesAuthority rolesAuthority;\n\n    function setUp() public {\n        rolesAuthority = new RolesAuthority(address(this), Authority(address(0)));\n    }\n\n    function testSetRoles() public {\n        assertFalse(rolesAuthority.doesUserHaveRole(address(0xBEEF), 0));\n\n        rolesAuthority.setUserRole(address(0xBEEF), 0, true);\n        assertTrue(rolesAuthority.doesUserHaveRole(address(0xBEEF), 0));\n\n        rolesAuthority.setUserRole(address(0xBEEF), 0, false);\n        assertFalse(rolesAuthority.doesUserHaveRole(address(0xBEEF), 0));\n    }\n\n    function testSetRoleCapabilities() public {\n        assertFalse(rolesAuthority.doesRoleHaveCapability(0, address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setRoleCapability(0, address(0xCAFE), 0xBEEFCAFE, true);\n        assertTrue(rolesAuthority.doesRoleHaveCapability(0, address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setRoleCapability(0, address(0xCAFE), 0xBEEFCAFE, false);\n        assertFalse(rolesAuthority.doesRoleHaveCapability(0, address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testSetPublicCapabilities() public {\n        assertFalse(rolesAuthority.isCapabilityPublic(address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setPublicCapability(address(0xCAFE), 0xBEEFCAFE, true);\n        assertTrue(rolesAuthority.isCapabilityPublic(address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setPublicCapability(address(0xCAFE), 0xBEEFCAFE, false);\n        assertFalse(rolesAuthority.isCapabilityPublic(address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testCanCallWithAuthorizedRole() public {\n        assertFalse(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setUserRole(address(0xBEEF), 0, true);\n        assertFalse(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setRoleCapability(0, address(0xCAFE), 0xBEEFCAFE, true);\n        assertTrue(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setRoleCapability(0, address(0xCAFE), 0xBEEFCAFE, false);\n        assertFalse(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setRoleCapability(0, address(0xCAFE), 0xBEEFCAFE, true);\n        assertTrue(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setUserRole(address(0xBEEF), 0, false);\n        assertFalse(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testCanCallPublicCapability() public {\n        assertFalse(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setPublicCapability(address(0xCAFE), 0xBEEFCAFE, true);\n        assertTrue(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setPublicCapability(address(0xCAFE), 0xBEEFCAFE, false);\n        assertFalse(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testSetRoles(address user, uint8 role) public {\n        assertFalse(rolesAuthority.doesUserHaveRole(user, role));\n\n        rolesAuthority.setUserRole(user, role, true);\n        assertTrue(rolesAuthority.doesUserHaveRole(user, role));\n\n        rolesAuthority.setUserRole(user, role, false);\n        assertFalse(rolesAuthority.doesUserHaveRole(user, role));\n    }\n\n    function testSetRoleCapabilities(\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(rolesAuthority.doesRoleHaveCapability(role, target, functionSig));\n\n        rolesAuthority.setRoleCapability(role, target, functionSig, true);\n        assertTrue(rolesAuthority.doesRoleHaveCapability(role, target, functionSig));\n\n        rolesAuthority.setRoleCapability(role, target, functionSig, false);\n        assertFalse(rolesAuthority.doesRoleHaveCapability(role, target, functionSig));\n    }\n\n    function testSetPublicCapabilities(address target, bytes4 functionSig) public {\n        assertFalse(rolesAuthority.isCapabilityPublic(target, functionSig));\n\n        rolesAuthority.setPublicCapability(target, functionSig, true);\n        assertTrue(rolesAuthority.isCapabilityPublic(target, functionSig));\n\n        rolesAuthority.setPublicCapability(target, functionSig, false);\n        assertFalse(rolesAuthority.isCapabilityPublic(target, functionSig));\n    }\n\n    function testCanCallWithAuthorizedRole(\n        address user,\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setUserRole(user, role, true);\n        assertFalse(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setRoleCapability(role, target, functionSig, true);\n        assertTrue(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setRoleCapability(role, target, functionSig, false);\n        assertFalse(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setRoleCapability(role, target, functionSig, true);\n        assertTrue(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setUserRole(user, role, false);\n        assertFalse(rolesAuthority.canCall(user, target, functionSig));\n    }\n\n    function testCanCallPublicCapability(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setPublicCapability(target, functionSig, true);\n        assertTrue(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setPublicCapability(target, functionSig, false);\n        assertFalse(rolesAuthority.canCall(user, target, functionSig));\n    }\n}\n"},"hedge/lib/solmate/src/test/SSTORE2.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {SSTORE2} from \"../utils/SSTORE2.sol\";\n\ncontract SSTORE2Test is DSTestPlus {\n    function testWriteRead() public {\n        bytes memory testBytes = abi.encode(\"this is a test\");\n\n        address pointer = SSTORE2.write(testBytes);\n\n        assertBytesEq(SSTORE2.read(pointer), testBytes);\n    }\n\n    function testWriteReadFullStartBound() public {\n        assertBytesEq(SSTORE2.read(SSTORE2.write(hex\"11223344\"), 0), hex\"11223344\");\n    }\n\n    function testWriteReadCustomStartBound() public {\n        assertBytesEq(SSTORE2.read(SSTORE2.write(hex\"11223344\"), 1), hex\"223344\");\n    }\n\n    function testWriteReadFullBoundedRead() public {\n        bytes memory testBytes = abi.encode(\"this is a test\");\n\n        assertBytesEq(SSTORE2.read(SSTORE2.write(testBytes), 0, testBytes.length), testBytes);\n    }\n\n    function testWriteReadCustomBounds() public {\n        assertBytesEq(SSTORE2.read(SSTORE2.write(hex\"11223344\"), 1, 3), hex\"2233\");\n    }\n\n    function testWriteReadEmptyBound() public {\n        SSTORE2.read(SSTORE2.write(hex\"11223344\"), 3, 3);\n    }\n\n    function testFailReadInvalidPointer() public view {\n        SSTORE2.read(DEAD_ADDRESS);\n    }\n\n    function testFailReadInvalidPointerCustomStartBound() public view {\n        SSTORE2.read(DEAD_ADDRESS, 1);\n    }\n\n    function testFailReadInvalidPointerCustomBounds() public view {\n        SSTORE2.read(DEAD_ADDRESS, 2, 4);\n    }\n\n    function testFailWriteReadOutOfStartBound() public {\n        SSTORE2.read(SSTORE2.write(hex\"11223344\"), 41000);\n    }\n\n    function testFailWriteReadEmptyOutOfBounds() public {\n        SSTORE2.read(SSTORE2.write(hex\"11223344\"), 42000, 42000);\n    }\n\n    function testFailWriteReadOutOfBounds() public {\n        SSTORE2.read(SSTORE2.write(hex\"11223344\"), 41000, 42000);\n    }\n\n    function testWriteRead(bytes calldata testBytes, bytes calldata brutalizeWith)\n        public\n        brutalizeMemory(brutalizeWith)\n    {\n        assertBytesEq(SSTORE2.read(SSTORE2.write(testBytes)), testBytes);\n    }\n\n    function testWriteReadCustomStartBound(\n        bytes calldata testBytes,\n        uint256 startIndex,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (testBytes.length == 0) return;\n\n        startIndex = bound(startIndex, 0, testBytes.length);\n\n        assertBytesEq(SSTORE2.read(SSTORE2.write(testBytes), startIndex), bytes(testBytes[startIndex:]));\n    }\n\n    function testWriteReadCustomBounds(\n        bytes calldata testBytes,\n        uint256 startIndex,\n        uint256 endIndex,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (testBytes.length == 0) return;\n\n        endIndex = bound(endIndex, 0, testBytes.length);\n        startIndex = bound(startIndex, 0, testBytes.length);\n\n        if (startIndex > endIndex) return;\n\n        assertBytesEq(\n            SSTORE2.read(SSTORE2.write(testBytes), startIndex, endIndex),\n            bytes(testBytes[startIndex:endIndex])\n        );\n    }\n\n    function testFailReadInvalidPointer(address pointer, bytes calldata brutalizeWith)\n        public\n        view\n        brutalizeMemory(brutalizeWith)\n    {\n        if (pointer.code.length > 0) revert();\n\n        SSTORE2.read(pointer);\n    }\n\n    function testFailReadInvalidPointerCustomStartBound(\n        address pointer,\n        uint256 startIndex,\n        bytes calldata brutalizeWith\n    ) public view brutalizeMemory(brutalizeWith) {\n        if (pointer.code.length > 0) revert();\n\n        SSTORE2.read(pointer, startIndex);\n    }\n\n    function testFailReadInvalidPointerCustomBounds(\n        address pointer,\n        uint256 startIndex,\n        uint256 endIndex,\n        bytes calldata brutalizeWith\n    ) public view brutalizeMemory(brutalizeWith) {\n        if (pointer.code.length > 0) revert();\n\n        SSTORE2.read(pointer, startIndex, endIndex);\n    }\n\n    function testFailWriteReadCustomStartBoundOutOfRange(\n        bytes calldata testBytes,\n        uint256 startIndex,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        startIndex = bound(startIndex, testBytes.length + 1, type(uint256).max);\n\n        SSTORE2.read(SSTORE2.write(testBytes), startIndex);\n    }\n\n    function testFailWriteReadCustomBoundsOutOfRange(\n        bytes calldata testBytes,\n        uint256 startIndex,\n        uint256 endIndex,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        endIndex = bound(endIndex, testBytes.length + 1, type(uint256).max);\n\n        SSTORE2.read(SSTORE2.write(testBytes), startIndex, endIndex);\n    }\n}\n"},"hedge/lib/solmate/src/test/SafeCastLib.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {SafeCastLib} from \"../utils/SafeCastLib.sol\";\n\ncontract SafeCastLibTest is DSTestPlus {\n    function testSafeCastTo248() public {\n        assertEq(SafeCastLib.safeCastTo248(2.5e45), 2.5e45);\n        assertEq(SafeCastLib.safeCastTo248(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo240() public {\n        assertEq(SafeCastLib.safeCastTo240(2.5e45), 2.5e45);\n        assertEq(SafeCastLib.safeCastTo240(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo232() public {\n        assertEq(SafeCastLib.safeCastTo232(2.5e45), 2.5e45);\n        assertEq(SafeCastLib.safeCastTo232(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo224() public {\n        assertEq(SafeCastLib.safeCastTo224(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo224(2.5e27), 2.5e27);\n    }\n    \n    function testSafeCastTo216() public {\n        assertEq(SafeCastLib.safeCastTo216(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo216(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo208() public {\n        assertEq(SafeCastLib.safeCastTo208(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo208(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo200() public {\n        assertEq(SafeCastLib.safeCastTo200(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo200(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo192() public {\n        assertEq(SafeCastLib.safeCastTo192(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo192(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo184() public {\n        assertEq(SafeCastLib.safeCastTo184(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo184(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo176() public {\n        assertEq(SafeCastLib.safeCastTo176(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo176(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo168() public {\n        assertEq(SafeCastLib.safeCastTo168(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo168(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo160() public {\n        assertEq(SafeCastLib.safeCastTo160(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo160(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo152() public {\n        assertEq(SafeCastLib.safeCastTo152(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo152(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo144() public {\n        assertEq(SafeCastLib.safeCastTo144(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo144(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo136() public {\n        assertEq(SafeCastLib.safeCastTo136(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo136(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo128() public {\n        assertEq(SafeCastLib.safeCastTo128(2.5e27), 2.5e27);\n        assertEq(SafeCastLib.safeCastTo128(2.5e18), 2.5e18);\n    }\n\n    function testSafeCastTo120() public {\n        assertEq(SafeCastLib.safeCastTo120(2.5e27), 2.5e27);\n        assertEq(SafeCastLib.safeCastTo120(2.5e18), 2.5e18);\n    }\n\n    function testSafeCastTo112() public {\n        assertEq(SafeCastLib.safeCastTo112(2.5e27), 2.5e27);\n        assertEq(SafeCastLib.safeCastTo112(2.5e18), 2.5e18);\n    }\n\n    function testSafeCastTo104() public {\n        assertEq(SafeCastLib.safeCastTo104(2.5e27), 2.5e27);\n        assertEq(SafeCastLib.safeCastTo104(2.5e18), 2.5e18);\n    }\n\n    function testSafeCastTo96() public {\n        assertEq(SafeCastLib.safeCastTo96(2.5e18), 2.5e18);\n        assertEq(SafeCastLib.safeCastTo96(2.5e17), 2.5e17);\n    }\n\n    function testSafeCastTo64() public {\n        assertEq(SafeCastLib.safeCastTo64(2.5e18), 2.5e18);\n        assertEq(SafeCastLib.safeCastTo64(2.5e17), 2.5e17);\n    }\n\n    function testSafeCastTo56() public {\n        assertEq(SafeCastLib.safeCastTo56(2.5e16), 2.5e16);\n        assertEq(SafeCastLib.safeCastTo56(2.5e15), 2.5e15);\n    }\n\n    function testSafeCastTo48() public {\n        assertEq(SafeCastLib.safeCastTo48(2.5e12), 2.5e12);\n        assertEq(SafeCastLib.safeCastTo48(2.5e11), 2.5e11);\n    }\n\n    function testSafeCastTo40() public {\n        assertEq(SafeCastLib.safeCastTo40(2.5e10), 2.5e10);\n        assertEq(SafeCastLib.safeCastTo40(2.5e9), 2.5e9);\n    }\n\n    function testSafeCastTo32() public {\n        assertEq(SafeCastLib.safeCastTo32(2.5e8), 2.5e8);\n        assertEq(SafeCastLib.safeCastTo32(2.5e7), 2.5e7);\n    }\n\n    function testSafeCastTo24() public {\n        assertEq(SafeCastLib.safeCastTo24(2.5e4), 2.5e4);\n        assertEq(SafeCastLib.safeCastTo24(2.5e3), 2.5e3);\n    }\n\n    function testSafeCastTo16() public {\n        assertEq(SafeCastLib.safeCastTo16(2.5e3), 2.5e3);\n        assertEq(SafeCastLib.safeCastTo16(2.5e2), 2.5e2);\n    }\n\n    function testSafeCastTo8() public {\n        assertEq(SafeCastLib.safeCastTo8(100), 100);\n        assertEq(SafeCastLib.safeCastTo8(250), 250);\n    }\n\n    function testFailSafeCastTo248() public pure {\n        SafeCastLib.safeCastTo248(type(uint248).max + 1);\n    }\n\n    function testFailSafeCastTo240() public pure {\n        SafeCastLib.safeCastTo240(type(uint240).max + 1);\n    }\n\n    function testFailSafeCastTo232() public pure {\n        SafeCastLib.safeCastTo232(type(uint232).max + 1);\n    }\n\n    function testFailSafeCastTo224() public pure {\n        SafeCastLib.safeCastTo224(type(uint224).max + 1);\n    }\n\n    function testFailSafeCastTo216() public pure {\n        SafeCastLib.safeCastTo216(type(uint216).max + 1);\n    }\n\n    function testFailSafeCastTo208() public pure {\n        SafeCastLib.safeCastTo208(type(uint208).max + 1);\n    }\n\n    function testFailSafeCastTo200() public pure {\n        SafeCastLib.safeCastTo200(type(uint200).max + 1);\n    }\n\n    function testFailSafeCastTo192() public pure {\n        SafeCastLib.safeCastTo192(type(uint192).max + 1);\n    }\n\n    function testFailSafeCastTo184() public pure {\n        SafeCastLib.safeCastTo184(type(uint184).max + 1);\n    }\n\n    function testFailSafeCastTo176() public pure {\n        SafeCastLib.safeCastTo176(type(uint176).max + 1);\n    }\n\n    function testFailSafeCastTo168() public pure {\n        SafeCastLib.safeCastTo168(type(uint168).max + 1);\n    }\n\n    function testFailSafeCastTo160() public pure {\n        SafeCastLib.safeCastTo160(type(uint160).max + 1);\n    }\n\n    function testFailSafeCastTo152() public pure {\n        SafeCastLib.safeCastTo152(type(uint152).max + 1);\n    }\n\n    function testFailSafeCastTo144() public pure {\n        SafeCastLib.safeCastTo144(type(uint144).max + 1);\n    }\n\n    function testFailSafeCastTo136() public pure {\n        SafeCastLib.safeCastTo136(type(uint136).max + 1);\n    }\n\n    function testFailSafeCastTo128() public pure {\n        SafeCastLib.safeCastTo128(type(uint128).max + 1);\n    }\n\n    function testFailSafeCastTo120() public pure {\n        SafeCastLib.safeCastTo120(type(uint120).max + 1);\n    }\n\n    function testFailSafeCastTo112() public pure {\n        SafeCastLib.safeCastTo112(type(uint112).max + 1);\n    }\n\n    function testFailSafeCastTo104() public pure {\n        SafeCastLib.safeCastTo104(type(uint104).max + 1);\n    }\n\n    function testFailSafeCastTo96() public pure {\n        SafeCastLib.safeCastTo96(type(uint96).max + 1);\n    }\n\n    function testFailSafeCastTo88() public pure {\n        SafeCastLib.safeCastTo88(type(uint88).max + 1);\n    }\n\n    function testFailSafeCastTo80() public pure {\n        SafeCastLib.safeCastTo80(type(uint80).max + 1);\n    }\n\n    function testFailSafeCastTo72() public pure {\n        SafeCastLib.safeCastTo72(type(uint72).max + 1);\n    }\n\n    function testFailSafeCastTo64() public pure {\n        SafeCastLib.safeCastTo64(type(uint64).max + 1);\n    }\n\n    function testFailSafeCastTo56() public pure {\n        SafeCastLib.safeCastTo56(type(uint56).max + 1);\n    }\n\n    function testFailSafeCastTo48() public pure {\n        SafeCastLib.safeCastTo48(type(uint48).max + 1);\n    }\n\n    function testFailSafeCastTo40() public pure {\n        SafeCastLib.safeCastTo40(type(uint40).max + 1);\n    }\n\n    function testFailSafeCastTo32() public pure {\n        SafeCastLib.safeCastTo32(type(uint32).max + 1);\n    }\n\n    function testFailSafeCastTo24() public pure {\n        SafeCastLib.safeCastTo24(type(uint24).max + 1);\n    }\n\n    function testFailSafeCastTo16() public pure {\n        SafeCastLib.safeCastTo16(type(uint16).max + 1);\n    }\n\n    function testFailSafeCastTo8() public pure {\n        SafeCastLib.safeCastTo8(type(uint8).max + 1);\n    }\n\n    function testSafeCastTo248(uint256 x) public {\n        x = bound(x, 0, type(uint248).max);\n\n        assertEq(SafeCastLib.safeCastTo248(x), x);\n    }\n\n    function testSafeCastTo240(uint256 x) public {\n        x = bound(x, 0, type(uint240).max);\n\n        assertEq(SafeCastLib.safeCastTo240(x), x);\n    }\n\n    function testSafeCastTo232(uint256 x) public {\n        x = bound(x, 0, type(uint232).max);\n\n        assertEq(SafeCastLib.safeCastTo232(x), x);\n    }\n\n    function testSafeCastTo224(uint256 x) public {\n        x = bound(x, 0, type(uint224).max);\n\n        assertEq(SafeCastLib.safeCastTo224(x), x);\n    }\n\n    function testSafeCastTo216(uint256 x) public {\n        x = bound(x, 0, type(uint216).max);\n\n        assertEq(SafeCastLib.safeCastTo216(x), x);\n    }\n\n    function testSafeCastTo208(uint256 x) public {\n        x = bound(x, 0, type(uint208).max);\n\n        assertEq(SafeCastLib.safeCastTo208(x), x);\n    }\n\n    function testSafeCastTo200(uint256 x) public {\n        x = bound(x, 0, type(uint200).max);\n\n        assertEq(SafeCastLib.safeCastTo200(x), x);\n    }\n\n    function testSafeCastTo192(uint256 x) public {\n        x = bound(x, 0, type(uint192).max);\n\n        assertEq(SafeCastLib.safeCastTo192(x), x);\n    }\n\n    function testSafeCastTo184(uint256 x) public {\n        x = bound(x, 0, type(uint184).max);\n\n        assertEq(SafeCastLib.safeCastTo184(x), x);\n    }\n\n    function testSafeCastTo176(uint256 x) public {\n        x = bound(x, 0, type(uint176).max);\n\n        assertEq(SafeCastLib.safeCastTo176(x), x);\n    }\n\n    function testSafeCastTo168(uint256 x) public {\n        x = bound(x, 0, type(uint168).max);\n\n        assertEq(SafeCastLib.safeCastTo168(x), x);\n    }\n\n    function testSafeCastTo160(uint256 x) public {\n        x = bound(x, 0, type(uint160).max);\n\n        assertEq(SafeCastLib.safeCastTo160(x), x);\n    }\n\n    function testSafeCastTo152(uint256 x) public {\n        x = bound(x, 0, type(uint152).max);\n\n        assertEq(SafeCastLib.safeCastTo152(x), x);\n    }\n\n    function testSafeCastTo144(uint256 x) public {\n        x = bound(x, 0, type(uint144).max);\n\n        assertEq(SafeCastLib.safeCastTo144(x), x);\n    }\n\n    function testSafeCastTo136(uint256 x) public {\n        x = bound(x, 0, type(uint136).max);\n\n        assertEq(SafeCastLib.safeCastTo136(x), x);\n    }\n\n    function testSafeCastTo128(uint256 x) public {\n        x = bound(x, 0, type(uint128).max);\n\n        assertEq(SafeCastLib.safeCastTo128(x), x);\n    }\n\n    function testSafeCastTo120(uint256 x) public {\n        x = bound(x, 0, type(uint120).max);\n\n        assertEq(SafeCastLib.safeCastTo120(x), x);\n    }\n\n    function testSafeCastTo112(uint256 x) public {\n        x = bound(x, 0, type(uint112).max);\n\n        assertEq(SafeCastLib.safeCastTo112(x), x);\n    }\n\n    function testSafeCastTo104(uint256 x) public {\n        x = bound(x, 0, type(uint104).max);\n\n        assertEq(SafeCastLib.safeCastTo104(x), x);\n    }\n\n    function testSafeCastTo96(uint256 x) public {\n        x = bound(x, 0, type(uint96).max);\n\n        assertEq(SafeCastLib.safeCastTo96(x), x);\n    }\n\n    function testSafeCastTo88(uint256 x) public {\n        x = bound(x, 0, type(uint88).max);\n\n        assertEq(SafeCastLib.safeCastTo88(x), x);\n    }\n\n\n    function testSafeCastTo80(uint256 x) public {\n        x = bound(x, 0, type(uint80).max);\n\n        assertEq(SafeCastLib.safeCastTo80(x), x);\n    }\n\n    function testSafeCastTo72(uint256 x) public {\n        x = bound(x, 0, type(uint72).max);\n\n        assertEq(SafeCastLib.safeCastTo72(x), x);\n    }\n\n    function testSafeCastTo64(uint256 x) public {\n        x = bound(x, 0, type(uint64).max);\n\n        assertEq(SafeCastLib.safeCastTo64(x), x);\n    }\n\n    function testSafeCastTo56(uint256 x) public {\n        x = bound(x, 0, type(uint56).max);\n\n        assertEq(SafeCastLib.safeCastTo56(x), x);\n    }\n\n    function testSafeCastTo48(uint256 x) public {\n        x = bound(x, 0, type(uint48).max);\n\n        assertEq(SafeCastLib.safeCastTo48(x), x);\n    }\n\n    function testSafeCastTo40(uint256 x) public {\n        x = bound(x, 0, type(uint40).max);\n\n        assertEq(SafeCastLib.safeCastTo40(x), x);\n    }\n\n    function testSafeCastTo32(uint256 x) public {\n        x = bound(x, 0, type(uint32).max);\n\n        assertEq(SafeCastLib.safeCastTo32(x), x);\n    }\n\n    function testSafeCastTo24(uint256 x) public {\n        x = bound(x, 0, type(uint24).max);\n\n        assertEq(SafeCastLib.safeCastTo24(x), x);\n    }\n\n    function testSafeCastTo16(uint256 x) public {\n        x = bound(x, 0, type(uint16).max);\n\n        assertEq(SafeCastLib.safeCastTo16(x), x);\n    }\n\n    function testSafeCastTo8(uint256 x) public {\n        x = bound(x, 0, type(uint8).max);\n\n        assertEq(SafeCastLib.safeCastTo8(x), x);\n    }\n\n    function testFailSafeCastTo248(uint256 x) public {\n        x = bound(x, type(uint248).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo248(x);\n    }\n\n    function testFailSafeCastTo240(uint256 x) public {\n        x = bound(x, type(uint240).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo240(x);\n    }\n\n    function testFailSafeCastTo232(uint256 x) public {\n        x = bound(x, type(uint232).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo232(x);\n    }\n\n    function testFailSafeCastTo224(uint256 x) public {\n        x = bound(x, type(uint224).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo224(x);\n    }\n\n    function testFailSafeCastTo216(uint256 x) public {\n        x = bound(x, type(uint216).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo216(x);\n    }\n\n    function testFailSafeCastTo208(uint256 x) public {\n        x = bound(x, type(uint208).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo208(x);\n    }\n\n    function testFailSafeCastTo200(uint256 x) public {\n        x = bound(x, type(uint200).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo200(x);\n    }\n\n    function testFailSafeCastTo192(uint256 x) public {\n        x = bound(x, type(uint192).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo192(x);\n    }\n\n    function testFailSafeCastTo184(uint256 x) public {\n        x = bound(x, type(uint184).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo184(x);\n    }\n\n    function testFailSafeCastTo176(uint256 x) public {\n        x = bound(x, type(uint176).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo176(x);\n    }\n\n    function testFailSafeCastTo168(uint256 x) public {\n        x = bound(x, type(uint168).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo168(x);\n    }\n\n    function testFailSafeCastTo160(uint256 x) public {\n        x = bound(x, type(uint160).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo160(x);\n    }\n\n    function testFailSafeCastTo152(uint256 x) public {\n        x = bound(x, type(uint152).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo152(x);\n    }\n\n    function testFailSafeCastTo144(uint256 x) public {\n        x = bound(x, type(uint144).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo144(x);\n    }\n\n    function testFailSafeCastTo136(uint256 x) public {\n        x = bound(x, type(uint136).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo136(x);\n    }\n\n    function testFailSafeCastTo128(uint256 x) public {\n        x = bound(x, type(uint128).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo128(x);\n    }\n\n    function testFailSafeCastTo120(uint256 x) public {\n        x = bound(x, type(uint120).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo120(x);\n    }\n\n    function testFailSafeCastTo112(uint256 x) public {\n        x = bound(x, type(uint112).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo112(x);\n    }\n\n    function testFailSafeCastTo104(uint256 x) public {\n        x = bound(x, type(uint104).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo104(x);\n    }\n\n    function testFailSafeCastTo96(uint256 x) public {\n        x = bound(x, type(uint96).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo96(x);\n    }\n\n    function testFailSafeCastTo88(uint256 x) public {\n        x = bound(x, type(uint88).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo88(x);\n    }\n\n    function testFailSafeCastTo80(uint256 x) public {\n        x = bound(x, type(uint80).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo80(x);\n    }\n\n    function testFailSafeCastTo72(uint256 x) public {\n        x = bound(x, type(uint72).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo72(x);\n    }\n\n    function testFailSafeCastTo64(uint256 x) public {\n        x = bound(x, type(uint64).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo64(x);\n    }\n\n    function testFailSafeCastTo56(uint256 x) public {\n        x = bound(x, type(uint56).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo56(x);\n    }\n\n    function testFailSafeCastTo48(uint256 x) public {\n        x = bound(x, type(uint48).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo48(x);\n    }\n\n    function testFailSafeCastTo40(uint256 x) public {\n        x = bound(x, type(uint40).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo40(x);\n    }\n\n    function testFailSafeCastTo32(uint256 x) public {\n        x = bound(x, type(uint32).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo32(x);\n    }\n\n    function testFailSafeCastTo24(uint256 x) public {\n        x = bound(x, type(uint24).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo24(x);\n    }\n\n    function testFailSafeCastTo16(uint256 x) public {\n        x = bound(x, type(uint16).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo16(x);\n    }\n\n    function testFailSafeCastTo8(uint256 x) public {\n        x = bound(x, type(uint8).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo8(x);\n    }\n}\n"},"hedge/lib/solmate/src/test/SafeTransferLib.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {MockERC20} from \"./utils/mocks/MockERC20.sol\";\nimport {RevertingToken} from \"./utils/weird-tokens/RevertingToken.sol\";\nimport {ReturnsTwoToken} from \"./utils/weird-tokens/ReturnsTwoToken.sol\";\nimport {ReturnsFalseToken} from \"./utils/weird-tokens/ReturnsFalseToken.sol\";\nimport {MissingReturnToken} from \"./utils/weird-tokens/MissingReturnToken.sol\";\nimport {ReturnsTooMuchToken} from \"./utils/weird-tokens/ReturnsTooMuchToken.sol\";\nimport {ReturnsGarbageToken} from \"./utils/weird-tokens/ReturnsGarbageToken.sol\";\nimport {ReturnsTooLittleToken} from \"./utils/weird-tokens/ReturnsTooLittleToken.sol\";\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\ncontract SafeTransferLibTest is DSTestPlus {\n    RevertingToken reverting;\n    ReturnsTwoToken returnsTwo;\n    ReturnsFalseToken returnsFalse;\n    MissingReturnToken missingReturn;\n    ReturnsTooMuchToken returnsTooMuch;\n    ReturnsGarbageToken returnsGarbage;\n    ReturnsTooLittleToken returnsTooLittle;\n\n    MockERC20 erc20;\n\n    function setUp() public {\n        reverting = new RevertingToken();\n        returnsTwo = new ReturnsTwoToken();\n        returnsFalse = new ReturnsFalseToken();\n        missingReturn = new MissingReturnToken();\n        returnsTooMuch = new ReturnsTooMuchToken();\n        returnsGarbage = new ReturnsGarbageToken();\n        returnsTooLittle = new ReturnsTooLittleToken();\n\n        erc20 = new MockERC20(\"StandardToken\", \"ST\", 18);\n        erc20.mint(address(this), type(uint256).max);\n    }\n\n    function testTransferWithMissingReturn() public {\n        verifySafeTransfer(address(missingReturn), address(0xBEEF), 1e18);\n    }\n\n    function testTransferWithStandardERC20() public {\n        verifySafeTransfer(address(erc20), address(0xBEEF), 1e18);\n    }\n\n    function testTransferWithReturnsTooMuch() public {\n        verifySafeTransfer(address(returnsTooMuch), address(0xBEEF), 1e18);\n    }\n\n    function testTransferWithNonContract() public {\n        SafeTransferLib.safeTransfer(ERC20(address(0xBADBEEF)), address(0xBEEF), 1e18);\n    }\n\n    function testTransferFromWithMissingReturn() public {\n        verifySafeTransferFrom(address(missingReturn), address(0xFEED), address(0xBEEF), 1e18);\n    }\n\n    function testTransferFromWithStandardERC20() public {\n        verifySafeTransferFrom(address(erc20), address(0xFEED), address(0xBEEF), 1e18);\n    }\n\n    function testTransferFromWithReturnsTooMuch() public {\n        verifySafeTransferFrom(address(returnsTooMuch), address(0xFEED), address(0xBEEF), 1e18);\n    }\n\n    function testTransferFromWithNonContract() public {\n        SafeTransferLib.safeTransferFrom(ERC20(address(0xBADBEEF)), address(0xFEED), address(0xBEEF), 1e18);\n    }\n\n    function testApproveWithMissingReturn() public {\n        verifySafeApprove(address(missingReturn), address(0xBEEF), 1e18);\n    }\n\n    function testApproveWithStandardERC20() public {\n        verifySafeApprove(address(erc20), address(0xBEEF), 1e18);\n    }\n\n    function testApproveWithReturnsTooMuch() public {\n        verifySafeApprove(address(returnsTooMuch), address(0xBEEF), 1e18);\n    }\n\n    function testApproveWithNonContract() public {\n        SafeTransferLib.safeApprove(ERC20(address(0xBADBEEF)), address(0xBEEF), 1e18);\n    }\n\n    function testTransferETH() public {\n        SafeTransferLib.safeTransferETH(address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferWithReturnsFalse() public {\n        verifySafeTransfer(address(returnsFalse), address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferWithReverting() public {\n        verifySafeTransfer(address(reverting), address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferWithReturnsTooLittle() public {\n        verifySafeTransfer(address(returnsTooLittle), address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferFromWithReturnsFalse() public {\n        verifySafeTransferFrom(address(returnsFalse), address(0xFEED), address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferFromWithReverting() public {\n        verifySafeTransferFrom(address(reverting), address(0xFEED), address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferFromWithReturnsTooLittle() public {\n        verifySafeTransferFrom(address(returnsTooLittle), address(0xFEED), address(0xBEEF), 1e18);\n    }\n\n    function testFailApproveWithReturnsFalse() public {\n        verifySafeApprove(address(returnsFalse), address(0xBEEF), 1e18);\n    }\n\n    function testFailApproveWithReverting() public {\n        verifySafeApprove(address(reverting), address(0xBEEF), 1e18);\n    }\n\n    function testFailApproveWithReturnsTooLittle() public {\n        verifySafeApprove(address(returnsTooLittle), address(0xBEEF), 1e18);\n    }\n\n    function testTransferWithMissingReturn(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransfer(address(missingReturn), to, amount);\n    }\n\n    function testTransferWithStandardERC20(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransfer(address(erc20), to, amount);\n    }\n\n    function testTransferWithReturnsTooMuch(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransfer(address(returnsTooMuch), to, amount);\n    }\n\n    function testTransferWithGarbage(\n        address to,\n        uint256 amount,\n        bytes memory garbage,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (\n            (garbage.length < 32 ||\n                (garbage[0] != 0 ||\n                    garbage[1] != 0 ||\n                    garbage[2] != 0 ||\n                    garbage[3] != 0 ||\n                    garbage[4] != 0 ||\n                    garbage[5] != 0 ||\n                    garbage[6] != 0 ||\n                    garbage[7] != 0 ||\n                    garbage[8] != 0 ||\n                    garbage[9] != 0 ||\n                    garbage[10] != 0 ||\n                    garbage[11] != 0 ||\n                    garbage[12] != 0 ||\n                    garbage[13] != 0 ||\n                    garbage[14] != 0 ||\n                    garbage[15] != 0 ||\n                    garbage[16] != 0 ||\n                    garbage[17] != 0 ||\n                    garbage[18] != 0 ||\n                    garbage[19] != 0 ||\n                    garbage[20] != 0 ||\n                    garbage[21] != 0 ||\n                    garbage[22] != 0 ||\n                    garbage[23] != 0 ||\n                    garbage[24] != 0 ||\n                    garbage[25] != 0 ||\n                    garbage[26] != 0 ||\n                    garbage[27] != 0 ||\n                    garbage[28] != 0 ||\n                    garbage[29] != 0 ||\n                    garbage[30] != 0 ||\n                    garbage[31] != bytes1(0x01))) && garbage.length != 0\n        ) return;\n\n        returnsGarbage.setGarbage(garbage);\n\n        verifySafeTransfer(address(returnsGarbage), to, amount);\n    }\n\n    function testTransferWithNonContract(\n        address nonContract,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (uint256(uint160(nonContract)) <= 18 || nonContract.code.length > 0) return;\n\n        SafeTransferLib.safeTransfer(ERC20(nonContract), to, amount);\n    }\n\n    function testFailTransferETHToContractWithoutFallback() public {\n        SafeTransferLib.safeTransferETH(address(this), 1e18);\n    }\n\n    function testTransferFromWithMissingReturn(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransferFrom(address(missingReturn), from, to, amount);\n    }\n\n    function testTransferFromWithStandardERC20(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransferFrom(address(erc20), from, to, amount);\n    }\n\n    function testTransferFromWithReturnsTooMuch(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransferFrom(address(returnsTooMuch), from, to, amount);\n    }\n\n    function testTransferFromWithGarbage(\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory garbage,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (\n            (garbage.length < 32 ||\n                (garbage[0] != 0 ||\n                    garbage[1] != 0 ||\n                    garbage[2] != 0 ||\n                    garbage[3] != 0 ||\n                    garbage[4] != 0 ||\n                    garbage[5] != 0 ||\n                    garbage[6] != 0 ||\n                    garbage[7] != 0 ||\n                    garbage[8] != 0 ||\n                    garbage[9] != 0 ||\n                    garbage[10] != 0 ||\n                    garbage[11] != 0 ||\n                    garbage[12] != 0 ||\n                    garbage[13] != 0 ||\n                    garbage[14] != 0 ||\n                    garbage[15] != 0 ||\n                    garbage[16] != 0 ||\n                    garbage[17] != 0 ||\n                    garbage[18] != 0 ||\n                    garbage[19] != 0 ||\n                    garbage[20] != 0 ||\n                    garbage[21] != 0 ||\n                    garbage[22] != 0 ||\n                    garbage[23] != 0 ||\n                    garbage[24] != 0 ||\n                    garbage[25] != 0 ||\n                    garbage[26] != 0 ||\n                    garbage[27] != 0 ||\n                    garbage[28] != 0 ||\n                    garbage[29] != 0 ||\n                    garbage[30] != 0 ||\n                    garbage[31] != bytes1(0x01))) && garbage.length != 0\n        ) return;\n\n        returnsGarbage.setGarbage(garbage);\n\n        verifySafeTransferFrom(address(returnsGarbage), from, to, amount);\n    }\n\n    function testTransferFromWithNonContract(\n        address nonContract,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (uint256(uint160(nonContract)) <= 18 || nonContract.code.length > 0) return;\n\n        SafeTransferLib.safeTransferFrom(ERC20(nonContract), from, to, amount);\n    }\n\n    function testApproveWithMissingReturn(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeApprove(address(missingReturn), to, amount);\n    }\n\n    function testApproveWithStandardERC20(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeApprove(address(erc20), to, amount);\n    }\n\n    function testApproveWithReturnsTooMuch(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeApprove(address(returnsTooMuch), to, amount);\n    }\n\n    function testApproveWithGarbage(\n        address to,\n        uint256 amount,\n        bytes memory garbage,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (\n            (garbage.length < 32 ||\n                (garbage[0] != 0 ||\n                    garbage[1] != 0 ||\n                    garbage[2] != 0 ||\n                    garbage[3] != 0 ||\n                    garbage[4] != 0 ||\n                    garbage[5] != 0 ||\n                    garbage[6] != 0 ||\n                    garbage[7] != 0 ||\n                    garbage[8] != 0 ||\n                    garbage[9] != 0 ||\n                    garbage[10] != 0 ||\n                    garbage[11] != 0 ||\n                    garbage[12] != 0 ||\n                    garbage[13] != 0 ||\n                    garbage[14] != 0 ||\n                    garbage[15] != 0 ||\n                    garbage[16] != 0 ||\n                    garbage[17] != 0 ||\n                    garbage[18] != 0 ||\n                    garbage[19] != 0 ||\n                    garbage[20] != 0 ||\n                    garbage[21] != 0 ||\n                    garbage[22] != 0 ||\n                    garbage[23] != 0 ||\n                    garbage[24] != 0 ||\n                    garbage[25] != 0 ||\n                    garbage[26] != 0 ||\n                    garbage[27] != 0 ||\n                    garbage[28] != 0 ||\n                    garbage[29] != 0 ||\n                    garbage[30] != 0 ||\n                    garbage[31] != bytes1(0x01))) && garbage.length != 0\n        ) return;\n\n        returnsGarbage.setGarbage(garbage);\n\n        verifySafeApprove(address(returnsGarbage), to, amount);\n    }\n\n    function testApproveWithNonContract(\n        address nonContract,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (uint256(uint160(nonContract)) <= 18 || nonContract.code.length > 0) return;\n\n        SafeTransferLib.safeApprove(ERC20(nonContract), to, amount);\n    }\n\n    function testTransferETH(\n        address recipient,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        // Transferring to msg.sender can fail because it's possible to overflow their ETH balance as it begins non-zero.\n        if (recipient.code.length > 0 || uint256(uint160(recipient)) <= 18 || recipient == msg.sender) return;\n\n        amount = bound(amount, 0, address(this).balance);\n\n        SafeTransferLib.safeTransferETH(recipient, amount);\n    }\n\n    function testFailTransferWithReturnsFalse(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransfer(address(returnsFalse), to, amount);\n    }\n\n    function testFailTransferWithReverting(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransfer(address(reverting), to, amount);\n    }\n\n    function testFailTransferWithReturnsTooLittle(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransfer(address(returnsTooLittle), to, amount);\n    }\n\n    function testFailTransferWithReturnsTwo(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransfer(address(returnsTwo), to, amount);\n    }\n\n    function testFailTransferWithGarbage(\n        address to,\n        uint256 amount,\n        bytes memory garbage,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        require(garbage.length != 0 && (garbage.length < 32 || garbage[31] != bytes1(0x01)));\n\n        returnsGarbage.setGarbage(garbage);\n\n        verifySafeTransfer(address(returnsGarbage), to, amount);\n    }\n\n    function testFailTransferFromWithReturnsFalse(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransferFrom(address(returnsFalse), from, to, amount);\n    }\n\n    function testFailTransferFromWithReverting(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransferFrom(address(reverting), from, to, amount);\n    }\n\n    function testFailTransferFromWithReturnsTooLittle(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransferFrom(address(returnsTooLittle), from, to, amount);\n    }\n\n    function testFailTransferFromWithReturnsTwo(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransferFrom(address(returnsTwo), from, to, amount);\n    }\n\n    function testFailTransferFromWithGarbage(\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory garbage,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        require(garbage.length != 0 && (garbage.length < 32 || garbage[31] != bytes1(0x01)));\n\n        returnsGarbage.setGarbage(garbage);\n\n        verifySafeTransferFrom(address(returnsGarbage), from, to, amount);\n    }\n\n    function testFailApproveWithReturnsFalse(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeApprove(address(returnsFalse), to, amount);\n    }\n\n    function testFailApproveWithReverting(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeApprove(address(reverting), to, amount);\n    }\n\n    function testFailApproveWithReturnsTooLittle(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeApprove(address(returnsTooLittle), to, amount);\n    }\n\n    function testFailApproveWithReturnsTwo(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeApprove(address(returnsTwo), to, amount);\n    }\n\n    function testFailApproveWithGarbage(\n        address to,\n        uint256 amount,\n        bytes memory garbage,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        require(garbage.length != 0 && (garbage.length < 32 || garbage[31] != bytes1(0x01)));\n\n        returnsGarbage.setGarbage(garbage);\n\n        verifySafeApprove(address(returnsGarbage), to, amount);\n    }\n\n    function testFailTransferETHToContractWithoutFallback(uint256 amount, bytes calldata brutalizeWith)\n        public\n        brutalizeMemory(brutalizeWith)\n    {\n        SafeTransferLib.safeTransferETH(address(this), amount);\n    }\n\n    function verifySafeTransfer(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        uint256 preBal = ERC20(token).balanceOf(to);\n        SafeTransferLib.safeTransfer(ERC20(address(token)), to, amount);\n        uint256 postBal = ERC20(token).balanceOf(to);\n\n        if (to == address(this)) {\n            assertEq(preBal, postBal);\n        } else {\n            assertEq(postBal - preBal, amount);\n        }\n    }\n\n    function verifySafeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        forceApprove(token, from, address(this), amount);\n\n        // We cast to MissingReturnToken here because it won't check\n        // that there was return data, which accommodates all tokens.\n        MissingReturnToken(token).transfer(from, amount);\n\n        uint256 preBal = ERC20(token).balanceOf(to);\n        SafeTransferLib.safeTransferFrom(ERC20(token), from, to, amount);\n        uint256 postBal = ERC20(token).balanceOf(to);\n\n        if (from == to) {\n            assertEq(preBal, postBal);\n        } else {\n            assertEq(postBal - preBal, amount);\n        }\n    }\n\n    function verifySafeApprove(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        SafeTransferLib.safeApprove(ERC20(address(token)), to, amount);\n\n        assertEq(ERC20(token).allowance(address(this), to), amount);\n    }\n\n    function forceApprove(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        uint256 slot = token == address(erc20) ? 4 : 2; // Standard ERC20 name and symbol aren't constant.\n\n        hevm.store(\n            token,\n            keccak256(abi.encode(to, keccak256(abi.encode(from, uint256(slot))))),\n            bytes32(uint256(amount))\n        );\n\n        assertEq(ERC20(token).allowance(from, to), amount, \"wrong allowance\");\n    }\n}\n"},"hedge/lib/solmate/src/test/SignedWadMath.t.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {wadMul, wadDiv} from \"../utils/SignedWadMath.sol\";\n\ncontract SignedWadMathTest is DSTestPlus {\n    function testWadMul(\n        uint256 x,\n        uint256 y,\n        bool negX,\n        bool negY\n    ) public {\n        x = bound(x, 0, 99999999999999e18);\n        y = bound(x, 0, 99999999999999e18);\n\n        int256 xPrime = negX ? -int256(x) : int256(x);\n        int256 yPrime = negY ? -int256(y) : int256(y);\n\n        assertEq(wadMul(xPrime, yPrime), (xPrime * yPrime) / 1e18);\n    }\n\n    function testFailWadMulOverflow(int256 x, int256 y) public pure {\n        // Ignore cases where x * y does not overflow.\n        unchecked {\n            if ((x * y) / x == y) revert();\n        }\n\n        wadMul(x, y);\n    }\n\n    function testWadDiv(\n        uint256 x,\n        uint256 y,\n        bool negX,\n        bool negY\n    ) public {\n        x = bound(x, 0, 99999999e18);\n        y = bound(x, 1, 99999999e18);\n\n        int256 xPrime = negX ? -int256(x) : int256(x);\n        int256 yPrime = negY ? -int256(y) : int256(y);\n\n        assertEq(wadDiv(xPrime, yPrime), (xPrime * 1e18) / yPrime);\n    }\n\n    function testFailWadDivOverflow(int256 x, int256 y) public pure {\n        // Ignore cases where x * WAD does not overflow or y is 0.\n        unchecked {\n            if (y == 0 || (x * 1e18) / 1e18 == x) revert();\n        }\n\n        wadDiv(x, y);\n    }\n\n    function testFailWadDivZeroDenominator(int256 x) public pure {\n        wadDiv(x, 0);\n    }\n}\n"},"hedge/lib/solmate/src/test/WETH.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\nimport {WETH} from \"../tokens/WETH.sol\";\n\ncontract WETHTest is DSTestPlus {\n    WETH weth;\n\n    function setUp() public {\n        weth = new WETH();\n    }\n\n    function testFallbackDeposit() public {\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        SafeTransferLib.safeTransferETH(address(weth), 1 ether);\n\n        assertEq(weth.balanceOf(address(this)), 1 ether);\n        assertEq(weth.totalSupply(), 1 ether);\n    }\n\n    function testDeposit() public {\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        weth.deposit{value: 1 ether}();\n\n        assertEq(weth.balanceOf(address(this)), 1 ether);\n        assertEq(weth.totalSupply(), 1 ether);\n    }\n\n    function testWithdraw() public {\n        uint256 startingBalance = address(this).balance;\n\n        weth.deposit{value: 1 ether}();\n\n        weth.withdraw(1 ether);\n\n        uint256 balanceAfterWithdraw = address(this).balance;\n\n        assertEq(balanceAfterWithdraw, startingBalance);\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n    }\n\n    function testPartialWithdraw() public {\n        weth.deposit{value: 1 ether}();\n\n        uint256 balanceBeforeWithdraw = address(this).balance;\n\n        weth.withdraw(0.5 ether);\n\n        uint256 balanceAfterWithdraw = address(this).balance;\n\n        assertEq(balanceAfterWithdraw, balanceBeforeWithdraw + 0.5 ether);\n        assertEq(weth.balanceOf(address(this)), 0.5 ether);\n        assertEq(weth.totalSupply(), 0.5 ether);\n    }\n\n    function testFallbackDeposit(uint256 amount) public {\n        amount = bound(amount, 0, address(this).balance);\n\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        SafeTransferLib.safeTransferETH(address(weth), amount);\n\n        assertEq(weth.balanceOf(address(this)), amount);\n        assertEq(weth.totalSupply(), amount);\n    }\n\n    function testDeposit(uint256 amount) public {\n        amount = bound(amount, 0, address(this).balance);\n\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        weth.deposit{value: amount}();\n\n        assertEq(weth.balanceOf(address(this)), amount);\n        assertEq(weth.totalSupply(), amount);\n    }\n\n    function testWithdraw(uint256 depositAmount, uint256 withdrawAmount) public {\n        depositAmount = bound(depositAmount, 0, address(this).balance);\n        withdrawAmount = bound(withdrawAmount, 0, depositAmount);\n\n        weth.deposit{value: depositAmount}();\n\n        uint256 balanceBeforeWithdraw = address(this).balance;\n\n        weth.withdraw(withdrawAmount);\n\n        uint256 balanceAfterWithdraw = address(this).balance;\n\n        assertEq(balanceAfterWithdraw, balanceBeforeWithdraw + withdrawAmount);\n        assertEq(weth.balanceOf(address(this)), depositAmount - withdrawAmount);\n        assertEq(weth.totalSupply(), depositAmount - withdrawAmount);\n    }\n\n    receive() external payable {}\n}\n\ncontract WETHInvariants is DSTestPlus, DSInvariantTest {\n    WETHTester wethTester;\n    WETH weth;\n\n    function setUp() public {\n        weth = new WETH();\n        wethTester = new WETHTester{value: address(this).balance}(weth);\n\n        addTargetContract(address(wethTester));\n    }\n\n    function invariantTotalSupplyEqualsBalance() public {\n        assertEq(address(weth).balance, weth.totalSupply());\n    }\n}\n\ncontract WETHTester {\n    WETH weth;\n\n    constructor(WETH _weth) payable {\n        weth = _weth;\n    }\n\n    function deposit(uint256 amount) public {\n        weth.deposit{value: amount}();\n    }\n\n    function fallbackDeposit(uint256 amount) public {\n        SafeTransferLib.safeTransferETH(address(weth), amount);\n    }\n\n    function withdraw(uint256 amount) public {\n        weth.withdraw(amount);\n    }\n\n    receive() external payable {}\n}\n"},"hedge/lib/solmate/src/test/utils/DSInvariantTest.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract DSInvariantTest {\n    address[] private targets;\n\n    function targetContracts() public view virtual returns (address[] memory) {\n        require(targets.length > 0, \"NO_TARGET_CONTRACTS\");\n\n        return targets;\n    }\n\n    function addTargetContract(address newTargetContract) internal virtual {\n        targets.push(newTargetContract);\n    }\n}\n"},"hedge/lib/solmate/src/test/utils/DSTestPlus.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {DSTest} from \"ds-test/test.sol\";\n\nimport {Hevm} from \"./Hevm.sol\";\n\n/// @notice Extended testing framework for DappTools projects.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/test/utils/DSTestPlus.sol)\ncontract DSTestPlus is DSTest {\n    Hevm internal constant hevm = Hevm(HEVM_ADDRESS);\n\n    address internal constant DEAD_ADDRESS = 0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF;\n\n    string private checkpointLabel;\n    uint256 private checkpointGasLeft = 1; // Start the slot warm.\n\n    modifier brutalizeMemory(bytes memory brutalizeWith) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Fill the 64 bytes of scratch space with the data.\n            pop(\n                staticcall(\n                    gas(), // Pass along all the gas in the call.\n                    0x04, // Call the identity precompile address.\n                    brutalizeWith, // Offset is the bytes' pointer.\n                    64, // Copy enough to only fill the scratch space.\n                    0, // Store the return value in the scratch space.\n                    64 // Scratch space is only 64 bytes in size, we don't want to write further.\n                )\n            )\n\n            let size := add(mload(brutalizeWith), 32) // Add 32 to include the 32 byte length slot.\n\n            // Fill the free memory pointer's destination with the data.\n            pop(\n                staticcall(\n                    gas(), // Pass along all the gas in the call.\n                    0x04, // Call the identity precompile address.\n                    brutalizeWith, // Offset is the bytes' pointer.\n                    size, // We want to pass the length of the bytes.\n                    mload(0x40), // Store the return value at the free memory pointer.\n                    size // Since the precompile just returns its input, we reuse size.\n                )\n            )\n        }\n\n        _;\n    }\n\n    function startMeasuringGas(string memory label) internal virtual {\n        checkpointLabel = label;\n\n        checkpointGasLeft = gasleft();\n    }\n\n    function stopMeasuringGas() internal virtual {\n        uint256 checkpointGasLeft2 = gasleft();\n\n        // Subtract 100 to account for the warm SLOAD in startMeasuringGas.\n        uint256 gasDelta = checkpointGasLeft - checkpointGasLeft2 - 100;\n\n        emit log_named_uint(string(abi.encodePacked(checkpointLabel, \" Gas\")), gasDelta);\n    }\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertUint128Eq(uint128 a, uint128 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertUint64Eq(uint64 a, uint64 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertUint96Eq(uint96 a, uint96 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertUint32Eq(uint32 a, uint32 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertBoolEq(bool a, bool b) internal virtual {\n        b ? assertTrue(a) : assertFalse(a);\n    }\n\n    function assertApproxEq(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = a > b ? a - b : b - a;\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            emit log_named_uint(\" Max Delta\", maxDelta);\n            emit log_named_uint(\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertRelApproxEq(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = ((a > b ? a - b : b - a) * 1e18) / b;\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"    Expected\", b);\n            emit log_named_uint(\"      Actual\", a);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertBytesEq(bytes memory a, bytes memory b) internal virtual {\n        if (keccak256(a) != keccak256(b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", b);\n            emit log_named_bytes(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertUintArrayEq(uint256[] memory a, uint256[] memory b) internal virtual {\n        require(a.length == b.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < a.length; i++) {\n            assertEq(a[i], b[i]);\n        }\n    }\n\n    function bound(\n        uint256 x,\n        uint256 min,\n        uint256 max\n    ) internal virtual returns (uint256 result) {\n        require(max >= min, \"MAX_LESS_THAN_MIN\");\n\n        uint256 size = max - min;\n\n        if (size == 0) result = min;\n        else if (size == type(uint256).max) result = x;\n        else {\n            ++size; // Make max inclusive.\n            uint256 mod = x % size;\n            result = min + mod;\n        }\n\n        emit log_named_uint(\"Bound Result\", result);\n    }\n\n    function min3(\n        uint256 a,\n        uint256 b,\n        uint256 c\n    ) internal pure returns (uint256) {\n        return a > b ? (b > c ? c : b) : (a > c ? c : a);\n    }\n\n    function min2(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? b : a;\n    }\n}\n"},"hedge/lib/solmate/src/test/utils/Hevm.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ninterface Hevm {\n    /// @notice Sets the block timestamp.\n    function warp(uint256) external;\n\n    /// @notice Sets the block height.\n    function roll(uint256) external;\n\n    /// @notice Sets the block base fee.\n    function fee(uint256) external;\n\n    /// @notice Loads a storage slot from an address.\n    function load(address, bytes32) external returns (bytes32);\n\n    /// @notice Stores a value to an address' storage slot.\n    function store(\n        address,\n        bytes32,\n        bytes32\n    ) external;\n\n    /// @notice Signs a digest with a private key, returns v r s.\n    function sign(uint256, bytes32)\n        external\n        returns (\n            uint8,\n            bytes32,\n            bytes32\n        );\n\n    /// @notice Gets address for a given private key.\n    function addr(uint256) external returns (address);\n\n    /// @notice Performs a foreign function call via a terminal call.\n    function ffi(string[] calldata) external returns (bytes memory);\n\n    /// @notice Sets the next call's msg.sender to be the input address.\n    function prank(address) external;\n\n    /// @notice Sets all subsequent calls' msg.sender to be the input address until stopPrank is called.\n    function startPrank(address) external;\n\n    /// @notice Sets the next call's msg.sender to be the input address and the tx.origin to be the second input.\n    function prank(address, address) external;\n\n    /// @notice Sets all subsequent calls' msg.sender to be the input address and\n    /// sets tx.origin to be the second address inputted until stopPrank is called.\n    function startPrank(address, address) external;\n\n    /// @notice Resets msg.sender to its original value before a prank.\n    function stopPrank() external;\n\n    /// @notice Sets an address' balance.\n    function deal(address, uint256) external;\n\n    /// @notice Sets an address' code.\n    function etch(address, bytes calldata) external;\n\n    /// @notice Expects an error from the next call.\n    function expectRevert(bytes calldata) external;\n\n    /// @notice Expects a revert from the next call.\n    function expectRevert(bytes4) external;\n\n    /// @notice Record all storage reads and writes.\n    function record() external;\n\n    /// @notice Gets all accessed reads and write slots from a recording session, for a given address.\n    function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n\n    /// @notice Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    /// @notice Call this function, then emit an event, then call a function. Internally after the call, we check\n    /// if logs were emitted in the expected order with the expected topics and data as specified by the booleans.\n    function expectEmit(\n        bool,\n        bool,\n        bool,\n        bool\n    ) external;\n\n    /// @notice Mocks the behavior of a contract call, setting the input and output for a function.\n    /// @notice Calldata can either be strict or a partial match, e.g. if only passed\n    /// a selector to the expected calldata, then the entire function will be mocked.\n    function mockCall(\n        address,\n        bytes calldata,\n        bytes calldata\n    ) external;\n\n    /// @notice Clears all mocked calls.\n    function clearMockedCalls() external;\n\n    /// @notice Expect a call to an address with the specified calldata.\n    /// @notice Calldata can either be strict or a partial match.\n    function expectCall(address, bytes calldata) external;\n\n    /// @notice Fetches the contract bytecode from its artifact file.\n    function getCode(string calldata) external returns (bytes memory);\n\n    /// @notice Label an address in test traces.\n    function label(address addr, string calldata label) external;\n\n    /// @notice When fuzzing, generate new inputs if the input conditional is not met.\n    function assume(bool) external;\n}\n"},"hedge/lib/solmate/src/test/utils/mocks/MockAuthChild.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Auth, Authority} from \"../../../auth/Auth.sol\";\n\ncontract MockAuthChild is Auth(msg.sender, Authority(address(0))) {\n    bool public flag;\n\n    function updateFlag() public virtual requiresAuth {\n        flag = true;\n    }\n}\n"},"hedge/lib/solmate/src/test/utils/mocks/MockAuthority.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Authority} from \"../../../auth/Auth.sol\";\n\ncontract MockAuthority is Authority {\n    bool immutable allowCalls;\n\n    constructor(bool _allowCalls) {\n        allowCalls = _allowCalls;\n    }\n\n    function canCall(\n        address,\n        address,\n        bytes4\n    ) public view override returns (bool) {\n        return allowCalls;\n    }\n}\n"},"hedge/lib/solmate/src/test/utils/mocks/MockERC1155.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC1155} from \"../../../tokens/ERC1155.sol\";\n\ncontract MockERC1155 is ERC1155 {\n    function uri(uint256) public pure virtual override returns (string memory) {}\n\n    function mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        _mint(to, id, amount, data);\n    }\n\n    function batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual {\n        _batchMint(to, ids, amounts, data);\n    }\n\n    function burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) public virtual {\n        _burn(from, id, amount);\n    }\n\n    function batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) public virtual {\n        _batchBurn(from, ids, amounts);\n    }\n}\n"},"hedge/lib/solmate/src/test/utils/mocks/MockERC20.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../../../tokens/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol, _decimals) {}\n\n    function mint(address to, uint256 value) public virtual {\n        _mint(to, value);\n    }\n\n    function burn(address from, uint256 value) public virtual {\n        _burn(from, value);\n    }\n}\n"},"hedge/lib/solmate/src/test/utils/mocks/MockERC4626.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../../../tokens/ERC20.sol\";\nimport {ERC4626} from \"../../../mixins/ERC4626.sol\";\n\ncontract MockERC4626 is ERC4626 {\n    uint256 public beforeWithdrawHookCalledCounter = 0;\n    uint256 public afterDepositHookCalledCounter = 0;\n\n    constructor(\n        ERC20 _underlying,\n        string memory _name,\n        string memory _symbol\n    ) ERC4626(_underlying, _name, _symbol) {}\n\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    function beforeWithdraw(uint256, uint256) internal override {\n        beforeWithdrawHookCalledCounter++;\n    }\n\n    function afterDeposit(uint256, uint256) internal override {\n        afterDepositHookCalledCounter++;\n    }\n}\n"},"hedge/lib/solmate/src/test/utils/mocks/MockERC721.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721} from \"../../../tokens/ERC721.sol\";\n\ncontract MockERC721 is ERC721 {\n    constructor(string memory _name, string memory _symbol) ERC721(_name, _symbol) {}\n\n    function tokenURI(uint256) public pure virtual override returns (string memory) {}\n\n    function mint(address to, uint256 tokenId) public virtual {\n        _mint(to, tokenId);\n    }\n\n    function burn(uint256 tokenId) public virtual {\n        _burn(tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public virtual {\n        _safeMint(to, tokenId);\n    }\n\n    function safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual {\n        _safeMint(to, tokenId, data);\n    }\n}\n"},"hedge/lib/solmate/src/test/utils/mocks/MockOwned.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Owned} from \"../../../auth/Owned.sol\";\n\ncontract MockOwned is Owned(msg.sender) {\n    bool public flag;\n\n    function updateFlag() public virtual onlyOwner {\n        flag = true;\n    }\n}\n"},"hedge/lib/solmate/src/test/utils/weird-tokens/MissingReturnToken.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract MissingReturnToken {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public constant name = \"MissingReturnToken\";\n\n    string public constant symbol = \"MRT\";\n\n    uint8 public constant decimals = 18;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        totalSupply = type(uint256).max;\n        balanceOf[msg.sender] = type(uint256).max;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n    }\n\n    function transfer(address to, uint256 amount) public virtual {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n    }\n}\n"},"hedge/lib/solmate/src/test/utils/weird-tokens/ReturnsFalseToken.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract ReturnsFalseToken {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public constant name = \"ReturnsFalseToken\";\n\n    string public constant symbol = \"RFT\";\n\n    uint8 public constant decimals = 18;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        totalSupply = type(uint256).max;\n        balanceOf[msg.sender] = type(uint256).max;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address, uint256) public virtual returns (bool) {\n        return false;\n    }\n\n    function transfer(address, uint256) public virtual returns (bool) {\n        return false;\n    }\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public virtual returns (bool) {\n        return false;\n    }\n}\n"},"hedge/lib/solmate/src/test/utils/weird-tokens/ReturnsGarbageToken.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract ReturnsGarbageToken {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public constant name = \"ReturnsGarbageToken\";\n\n    string public constant symbol = \"RGT\";\n\n    uint8 public constant decimals = 18;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                              MOCK STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes garbage;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        totalSupply = type(uint256).max;\n        balanceOf[msg.sender] = type(uint256).max;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        bytes memory _garbage = garbage;\n\n        assembly {\n            return(add(_garbage, 32), mload(_garbage))\n        }\n    }\n\n    function transfer(address to, uint256 amount) public virtual {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        bytes memory _garbage = garbage;\n\n        assembly {\n            return(add(_garbage, 32), mload(_garbage))\n        }\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        bytes memory _garbage = garbage;\n\n        assembly {\n            return(add(_garbage, 32), mload(_garbage))\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              MOCK LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setGarbage(bytes memory _garbage) public virtual {\n        garbage = _garbage;\n    }\n}\n"},"hedge/lib/solmate/src/test/utils/weird-tokens/ReturnsTooLittleToken.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract ReturnsTooLittleToken {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public constant name = \"ReturnsTooLittleToken\";\n\n    string public constant symbol = \"RTLT\";\n\n    uint8 public constant decimals = 18;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        totalSupply = type(uint256).max;\n        balanceOf[msg.sender] = type(uint256).max;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address, uint256) public virtual {\n        assembly {\n            mstore(0, 0x0100000000000000000000000000000000000000000000000000000000000000)\n            return(0, 8)\n        }\n    }\n\n    function transfer(address, uint256) public virtual {\n        assembly {\n            mstore(0, 0x0100000000000000000000000000000000000000000000000000000000000000)\n            return(0, 8)\n        }\n    }\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public virtual {\n        assembly {\n            mstore(0, 0x0100000000000000000000000000000000000000000000000000000000000000)\n            return(0, 8)\n        }\n    }\n}\n"},"hedge/lib/solmate/src/test/utils/weird-tokens/ReturnsTooMuchToken.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract ReturnsTooMuchToken {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public constant name = \"ReturnsTooMuchToken\";\n\n    string public constant symbol = \"RTMT\";\n\n    uint8 public constant decimals = 18;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        totalSupply = type(uint256).max;\n        balanceOf[msg.sender] = type(uint256).max;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        assembly {\n            mstore(0, 1)\n            return(0, 4096)\n        }\n    }\n\n    function transfer(address to, uint256 amount) public virtual {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        assembly {\n            mstore(0, 1)\n            return(0, 4096)\n        }\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        assembly {\n            mstore(0, 1)\n            return(0, 4096)\n        }\n    }\n}\n"},"hedge/lib/solmate/src/test/utils/weird-tokens/ReturnsTwoToken.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract ReturnsTwoToken {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public constant name = \"ReturnsFalseToken\";\n\n    string public constant symbol = \"RTT\";\n\n    uint8 public constant decimals = 18;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        totalSupply = type(uint256).max;\n        balanceOf[msg.sender] = type(uint256).max;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address, uint256) public virtual returns (uint256) {\n        return 2;\n    }\n\n    function transfer(address, uint256) public virtual returns (uint256) {\n        return 2;\n    }\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public virtual returns (uint256) {\n        return 2;\n    }\n}\n"},"hedge/lib/solmate/src/test/utils/weird-tokens/RevertingToken.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract RevertingToken {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public constant name = \"RevertingToken\";\n\n    string public constant symbol = \"RT\";\n\n    uint8 public constant decimals = 18;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        totalSupply = type(uint256).max;\n        balanceOf[msg.sender] = type(uint256).max;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address, uint256) public virtual {\n        revert();\n    }\n\n    function transfer(address, uint256) public virtual {\n        revert();\n    }\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public virtual {\n        revert();\n    }\n}\n"},"hedge/lib/solmate/src/tokens/ERC1155.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n"},"hedge/lib/solmate/src/tokens/ERC20.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"},"hedge/lib/solmate/src/tokens/ERC721.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"},"hedge/lib/solmate/src/tokens/WETH.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"./ERC20.sol\";\n\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\n/// @notice Minimalist and modern Wrapped Ether implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/WETH.sol)\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\ncontract WETH is ERC20(\"Wrapped Ether\", \"WETH\", 18) {\n    using SafeTransferLib for address;\n\n    event Deposit(address indexed from, uint256 amount);\n\n    event Withdrawal(address indexed to, uint256 amount);\n\n    function deposit() public payable virtual {\n        _mint(msg.sender, msg.value);\n\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n\n        emit Withdrawal(msg.sender, amount);\n\n        msg.sender.safeTransferETH(amount);\n    }\n\n    receive() external payable virtual {\n        deposit();\n    }\n}\n"},"hedge/lib/solmate/src/utils/Bytes32AddressLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Library for converting between addresses and bytes32 values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\nlibrary Bytes32AddressLib {\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue));\n    }\n}\n"},"hedge/lib/solmate/src/utils/CREATE3.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Bytes32AddressLib} from \"./Bytes32AddressLib.sol\";\n\n/// @notice Deploy to deterministic addresses without an initcode factor.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol)\nlibrary CREATE3 {\n    using Bytes32AddressLib for bytes32;\n\n    //--------------------------------------------------------------------------------//\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\n    //--------------------------------------------------------------------------------//\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 0 size               //\n    // 0x37       |  0x37                 | CALLDATACOPY     |                        //\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\n    // 0x34       |  0x34                 | CALLVALUE        | value 0 size           //\n    // 0xf0       |  0xf0                 | CREATE           | newContract            //\n    //--------------------------------------------------------------------------------//\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\n    //--------------------------------------------------------------------------------//\n    // 0x67       |  0x67XXXXXXXXXXXXXXXX | PUSH8 bytecode   | bytecode               //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 bytecode             //\n    // 0x52       |  0x52                 | MSTORE           |                        //\n    // 0x60       |  0x6008               | PUSH1 08         | 8                      //\n    // 0x60       |  0x6018               | PUSH1 18         | 24 8                   //\n    // 0xf3       |  0xf3                 | RETURN           |                        //\n    //--------------------------------------------------------------------------------//\n    bytes internal constant PROXY_BYTECODE = hex\"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3\";\n\n    bytes32 internal constant PROXY_BYTECODE_HASH = keccak256(PROXY_BYTECODE);\n\n    function deploy(\n        bytes32 salt,\n        bytes memory creationCode,\n        uint256 value\n    ) internal returns (address deployed) {\n        bytes memory proxyChildBytecode = PROXY_BYTECODE;\n\n        address proxy;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Deploy a new contract with our pre-made bytecode via CREATE2.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            proxy := create2(0, add(proxyChildBytecode, 32), mload(proxyChildBytecode), salt)\n        }\n        require(proxy != address(0), \"DEPLOYMENT_FAILED\");\n\n        deployed = getDeployed(salt);\n        (bool success, ) = proxy.call{value: value}(creationCode);\n        require(success && deployed.code.length != 0, \"INITIALIZATION_FAILED\");\n    }\n\n    function getDeployed(bytes32 salt) internal view returns (address) {\n        address proxy = keccak256(\n            abi.encodePacked(\n                // Prefix:\n                bytes1(0xFF),\n                // Creator:\n                address(this),\n                // Salt:\n                salt,\n                // Bytecode hash:\n                PROXY_BYTECODE_HASH\n            )\n        ).fromLast20Bytes();\n\n        return\n            keccak256(\n                abi.encodePacked(\n                    // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01)\n                    // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n                    hex\"d6_94\",\n                    proxy,\n                    hex\"01\" // Nonce of the proxy contract (1)\n                )\n            ).fromLast20Bytes();\n    }\n}\n"},"hedge/lib/solmate/src/utils/FixedPointMathLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // Divide x * y by the denominator.\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // If x * y modulo the denominator is strictly greater than 0,\n            // 1 is added to round up the division of x * y by the denominator.\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}\n"},"hedge/lib/solmate/src/utils/LibString.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Efficient library for creating string representations of integers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)\nlibrary LibString {\n    function toString(int256 value) internal pure returns (string memory str) {\n        if (value >= 0) return toString(uint256(value));\n\n        unchecked {\n            str = toString(uint256(-value));\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Note: This is only safe because we over-allocate memory\n                // and write the string from right to left in toString(uint256),\n                // and thus can be sure that sub(str, 1) is an unused memory location.\n\n                let length := mload(str) // Load the string length.\n                // Put the - character at the start of the string contents.\n                mstore(str, 45) // 45 is the ASCII code for the - character.\n                str := sub(str, 1) // Move back the string pointer by a byte.\n                mstore(str, add(length, 1)) // Update the string length.\n            }\n        }\n    }\n\n    function toString(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes\n            // to keep the free memory pointer word aligned. We'll need 1 word for the length, 1 word for the\n            // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.\n            let newFreeMemoryPointer := add(mload(0x40), 160)\n\n            // Update the free memory pointer to avoid overriding our string.\n            mstore(0x40, newFreeMemoryPointer)\n\n            // Assign str to the end of the zone of newly allocated memory.\n            str := sub(newFreeMemoryPointer, 32)\n\n            // Clean the last word of memory it may not be overwritten.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                // Move the pointer 1 byte to the left.\n                str := sub(str, 1)\n\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n\n                // Keep dividing temp until zero.\n                temp := div(temp, 10)\n\n                 // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            // Compute and cache the final total length of the string.\n            let length := sub(end, str)\n\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 32)\n\n            // Store the string's length at the start of memory allocated for our string.\n            mstore(str, length)\n        }\n    }\n}\n"},"hedge/lib/solmate/src/utils/MerkleProofLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized merkle proof verification library.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/MerkleProofLib.sol)\n/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/MerkleProofLib.sol)\nlibrary MerkleProofLib {\n    function verify(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if proof.length {\n                // Left shifting by 5 is like multiplying by 32.\n                let end := add(proof.offset, shl(5, proof.length))\n\n                // Initialize offset to the offset of the proof in calldata.\n                let offset := proof.offset\n\n                // Iterate over proof elements to compute root hash.\n                // prettier-ignore\n                for {} 1 {} {\n                    // Slot where the leaf should be put in scratch space. If\n                    // leaf > calldataload(offset): slot 32, otherwise: slot 0.\n                    let leafSlot := shl(5, gt(leaf, calldataload(offset)))\n\n                    // Store elements to hash contiguously in scratch space.\n                    // The xor puts calldataload(offset) in whichever slot leaf\n                    // is not occupying, so 0 if leafSlot is 32, and 32 otherwise.\n                    mstore(leafSlot, leaf)\n                    mstore(xor(leafSlot, 32), calldataload(offset))\n\n                    // Reuse leaf to store the hash to reduce stack operations.\n                    leaf := keccak256(0, 64) // Hash both slots of scratch space.\n\n                    offset := add(offset, 32) // Shift 1 word per cycle.\n\n                    // prettier-ignore\n                    if iszero(lt(offset, end)) { break }\n                }\n            }\n\n            isValid := eq(leaf, root) // The proof is valid if the roots match.\n        }\n    }\n}\n"},"hedge/lib/solmate/src/utils/ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private locked = 1;\n\n    modifier nonReentrant() virtual {\n        require(locked == 1, \"REENTRANCY\");\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n}\n"},"hedge/lib/solmate/src/utils/SSTORE2.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\n\n    /*//////////////////////////////////////////////////////////////\n                               WRITE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function write(bytes memory data) internal returns (address pointer) {\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n        bytes memory runtimeCode = abi.encodePacked(hex\"00\", data);\n\n        bytes memory creationCode = abi.encodePacked(\n            //---------------------------------------------------------------------------------------------------------------//\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\n            //---------------------------------------------------------------------------------------------------------------//\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\n            //---------------------------------------------------------------------------------------------------------------//\n            hex\"60_0B_59_81_38_03_80_92_59_39_F3\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\n        );\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Deploy a new contract with the generated creation code.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\n        }\n\n        require(pointer != address(0), \"DEPLOYMENT_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               READ LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function read(address pointer) internal view returns (bytes memory) {\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\n    }\n\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n\n        return readBytecode(pointer, start, pointer.code.length - start);\n    }\n\n    function read(\n        address pointer,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n        end += DATA_OFFSET;\n\n        require(pointer.code.length >= end, \"OUT_OF_BOUNDS\");\n\n        return readBytecode(pointer, start, end - start);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function readBytecode(\n        address pointer,\n        uint256 start,\n        uint256 size\n    ) private view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            data := mload(0x40)\n\n            // Update the free memory pointer to prevent overriding our data.\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\n            // Adding 31 to size and running the result through the logic above ensures\n            // the memory pointer remains word-aligned, following the Solidity convention.\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\n\n            // Store the size of the data in the first 32 byte chunk of free memory.\n            mstore(data, size)\n\n            // Copy the code into memory right after the 32 bytes we used to store the size.\n            extcodecopy(pointer, add(data, 32), start, size)\n        }\n    }\n}\n"},"hedge/lib/solmate/src/utils/SafeCastLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Safe unsigned integer casting library that reverts on overflow.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\nlibrary SafeCastLib {\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\n        require(x < 1 << 248);\n\n        y = uint248(x);\n    }\n\n    function safeCastTo240(uint256 x) internal pure returns (uint240 y) {\n        require(x < 1 << 240);\n\n        y = uint240(x);\n    }\n\n    function safeCastTo232(uint256 x) internal pure returns (uint232 y) {\n        require(x < 1 << 232);\n\n        y = uint232(x);\n    }\n\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\n        require(x < 1 << 224);\n\n        y = uint224(x);\n    }\n\n    function safeCastTo216(uint256 x) internal pure returns (uint216 y) {\n        require(x < 1 << 216);\n\n        y = uint216(x);\n    }\n\n    function safeCastTo208(uint256 x) internal pure returns (uint208 y) {\n        require(x < 1 << 208);\n\n        y = uint208(x);\n    }\n\n    function safeCastTo200(uint256 x) internal pure returns (uint200 y) {\n        require(x < 1 << 200);\n\n        y = uint200(x);\n    }\n\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\n        require(x < 1 << 192);\n\n        y = uint192(x);\n    }\n    \n    function safeCastTo184(uint256 x) internal pure returns (uint184 y) {\n        require(x < 1 << 184);\n\n        y = uint184(x);\n    }\n\n    function safeCastTo176(uint256 x) internal pure returns (uint176 y) {\n        require(x < 1 << 176);\n\n        y = uint176(x);\n    }\n\n    function safeCastTo168(uint256 x) internal pure returns (uint168 y) {\n        require(x < 1 << 168);\n\n        y = uint168(x);\n    }\n\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\n        require(x < 1 << 160);\n\n        y = uint160(x);\n    }\n\n    function safeCastTo152(uint256 x) internal pure returns (uint152 y) {\n        require(x < 1 << 152);\n\n        y = uint152(x);\n    }\n\n    function safeCastTo144(uint256 x) internal pure returns (uint144 y) {\n        require(x < 1 << 144);\n\n        y = uint144(x);\n    }\n\n    function safeCastTo136(uint256 x) internal pure returns (uint136 y) {\n        require(x < 1 << 136);\n\n        y = uint136(x);\n    }\n\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\n        require(x < 1 << 128);\n\n        y = uint128(x);\n    }\n\n    function safeCastTo120(uint256 x) internal pure returns (uint120 y) {\n        require(x < 1 << 120);\n\n        y = uint120(x);\n    }\n\n    function safeCastTo112(uint256 x) internal pure returns (uint112 y) {\n        require(x < 1 << 112);\n\n        y = uint112(x);\n    }\n\n    function safeCastTo104(uint256 x) internal pure returns (uint104 y) {\n        require(x < 1 << 104);\n\n        y = uint104(x);\n    }\n\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\n        require(x < 1 << 96);\n\n        y = uint96(x);\n    }\n\n    function safeCastTo88(uint256 x) internal pure returns (uint88 y) {\n        require(x < 1 << 88);\n\n        y = uint88(x);\n    }\n\n    function safeCastTo80(uint256 x) internal pure returns (uint80 y) {\n        require(x < 1 << 80);\n\n        y = uint80(x);\n    }\n\n    function safeCastTo72(uint256 x) internal pure returns (uint72 y) {\n        require(x < 1 << 72);\n\n        y = uint72(x);\n    }\n\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\n        require(x < 1 << 64);\n\n        y = uint64(x);\n    }\n\n    function safeCastTo56(uint256 x) internal pure returns (uint56 y) {\n        require(x < 1 << 56);\n\n        y = uint56(x);\n    }\n\n    function safeCastTo48(uint256 x) internal pure returns (uint48 y) {\n        require(x < 1 << 48);\n\n        y = uint48(x);\n    }\n\n    function safeCastTo40(uint256 x) internal pure returns (uint40 y) {\n        require(x < 1 << 40);\n\n        y = uint40(x);\n    }\n\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\n        require(x < 1 << 32);\n\n        y = uint32(x);\n    }\n\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\n        require(x < 1 << 24);\n\n        y = uint24(x);\n    }\n\n    function safeCastTo16(uint256 x) internal pure returns (uint16 y) {\n        require(x < 1 << 16);\n\n        y = uint16(x);\n    }\n\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\n        require(x < 1 << 8);\n\n        y = uint8(x);\n    }\n}\n"},"hedge/lib/solmate/src/utils/SafeTransferLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"},"hedge/lib/solmate/src/utils/SignedWadMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Signed 18 decimal fixed point (wad) arithmetic library.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SignedWadMath.sol)\n/// @author Modified from Remco Bloemen (https://xn--2-umb.com/22/exp-ln/index.html)\n\n/// @dev Will not revert on overflow, only use where overflow is not possible.\nfunction toWadUnsafe(uint256 x) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by 1e18.\n        r := mul(x, 1000000000000000000)\n    }\n}\n\n/// @dev Takes an integer amount of seconds and converts it to a wad amount of days.\n/// @dev Will not revert on overflow, only use where overflow is not possible.\n/// @dev Not meant for negative second amounts, it assumes x is positive.\nfunction toDaysWadUnsafe(uint256 x) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by 1e18 and then divide it by 86400.\n        r := div(mul(x, 1000000000000000000), 86400)\n    }\n}\n\n/// @dev Takes a wad amount of days and converts it to an integer amount of seconds.\n/// @dev Will not revert on overflow, only use where overflow is not possible.\n/// @dev Not meant for negative day amounts, it assumes x is positive.\nfunction fromDaysWadUnsafe(int256 x) pure returns (uint256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by 86400 and then divide it by 1e18.\n        r := div(mul(x, 86400), 1000000000000000000)\n    }\n}\n\n/// @dev Will not revert on overflow, only use where overflow is not possible.\nfunction unsafeWadMul(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by y and divide by 1e18.\n        r := sdiv(mul(x, y), 1000000000000000000)\n    }\n}\n\n/// @dev Will return 0 instead of reverting if y is zero and will\n/// not revert on overflow, only use where overflow is not possible.\nfunction unsafeWadDiv(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by 1e18 and divide it by y.\n        r := sdiv(mul(x, 1000000000000000000), y)\n    }\n}\n\nfunction wadMul(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Store x * y in r for now.\n        r := mul(x, y)\n\n        // Equivalent to require(x == 0 || (x * y) / x == y)\n        if iszero(or(iszero(x), eq(sdiv(r, x), y))) {\n            revert(0, 0)\n        }\n\n        // Scale the result down by 1e18.\n        r := sdiv(r, 1000000000000000000)\n    }\n}\n\nfunction wadDiv(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Store x * 1e18 in r for now.\n        r := mul(x, 1000000000000000000)\n\n        // Equivalent to require(y != 0 && ((x * 1e18) / 1e18 == x))\n        if iszero(and(iszero(iszero(y)), eq(sdiv(r, 1000000000000000000), x))) {\n            revert(0, 0)\n        }\n\n        // Divide r by y.\n        r := sdiv(r, y)\n    }\n}\n\n/// @dev Will not work with negative bases, only use when x is positive.\nfunction wadPow(int256 x, int256 y) pure returns (int256) {\n    // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)\n    return wadExp((wadLn(x) * y) / 1e18); // Using ln(x) means x must be greater than 0.\n}\n\nfunction wadExp(int256 x) pure returns (int256 r) {\n    unchecked {\n        // When the result is < 0.5 we return zero. This happens when\n        // x <= floor(log(0.5e18) * 1e18) ~ -42e18\n        if (x <= -42139678854452767551) return 0;\n\n        // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\n        // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\n        if (x >= 135305999368893231589) revert(\"EXP_OVERFLOW\");\n\n        // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\n        // for more intermediate precision and a binary basis. This base conversion\n        // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n        x = (x << 78) / 5**18;\n\n        // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers\n        // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n        // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n        int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\n        x = x - k * 54916777467707473351141471128;\n\n        // k is in the range [-61, 195].\n\n        // Evaluate using a (6, 7)-term rational approximation.\n        // p is made monic, we'll multiply by a scale factor later.\n        int256 y = x + 1346386616545796478920950773328;\n        y = ((y * x) >> 96) + 57155421227552351082224309758442;\n        int256 p = y + x - 94201549194550492254356042504812;\n        p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n        p = p * x + (4385272521454847904659076985693276 << 96);\n\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n        int256 q = x - 2855989394907223263936484059900;\n        q = ((q * x) >> 96) + 50020603652535783019961831881945;\n        q = ((q * x) >> 96) - 533845033583426703283633433725380;\n        q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n        q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n        q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Div in assembly because solidity adds a zero check despite the unchecked.\n            // The q polynomial won't have zeros in the domain as all its roots are complex.\n            // No scaling is necessary because p is already 2**96 too large.\n            r := sdiv(p, q)\n        }\n\n        // r should be in the range (0.09, 0.25) * 2**96.\n\n        // We now need to multiply r by:\n        // * the scale factor s = ~6.031367120.\n        // * the 2**k factor from the range reduction.\n        // * the 1e18 / 2**96 factor for base conversion.\n        // We do this all at once, with an intermediate result in 2**213\n        // basis, so the final right shift is always by a positive amount.\n        r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\n    }\n}\n\nfunction wadLn(int256 x) pure returns (int256 r) {\n    unchecked {\n        require(x > 0, \"UNDEFINED\");\n\n        // We want to convert x from 10**18 fixed point to 2**96 fixed point.\n        // We do this by multiplying by 2**96 / 10**18. But since\n        // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\n        // and add ln(2**96 / 10**18) at the end.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\n            r := or(r, lt(0x1, shr(r, x)))\n        }\n\n        // Reduce range of x to (1, 2) * 2**96\n        // ln(2^k * x) = k * ln(2) + ln(x)\n        int256 k = r - 96;\n        x <<= uint256(159 - k);\n        x = int256(uint256(x) >> 159);\n\n        // Evaluate using a (8, 8)-term rational approximation.\n        // p is made monic, we will multiply by a scale factor later.\n        int256 p = x + 3273285459638523848632254066296;\n        p = ((p * x) >> 96) + 24828157081833163892658089445524;\n        p = ((p * x) >> 96) + 43456485725739037958740375743393;\n        p = ((p * x) >> 96) - 11111509109440967052023855526967;\n        p = ((p * x) >> 96) - 45023709667254063763336534515857;\n        p = ((p * x) >> 96) - 14706773417378608786704636184526;\n        p = p * x - (795164235651350426258249787498 << 96);\n\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n        // q is monic by convention.\n        int256 q = x + 5573035233440673466300451813936;\n        q = ((q * x) >> 96) + 71694874799317883764090561454958;\n        q = ((q * x) >> 96) + 283447036172924575727196451306956;\n        q = ((q * x) >> 96) + 401686690394027663651624208769553;\n        q = ((q * x) >> 96) + 204048457590392012362485061816622;\n        q = ((q * x) >> 96) + 31853899698501571402653359427138;\n        q = ((q * x) >> 96) + 909429971244387300277376558375;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Div in assembly because solidity adds a zero check despite the unchecked.\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already 2**96 too large.\n            r := sdiv(p, q)\n        }\n\n        // r is in the range (0, 0.125) * 2**96\n\n        // Finalization, we need to:\n        // * multiply by the scale factor s = 5.549…\n        // * add ln(2**96 / 10**18)\n        // * add k * ln(2)\n        // * multiply by 10**18 / 2**96 = 5**18 >> 78\n\n        // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\n        r *= 1677202110996718588342820967067443963516166;\n        // add ln(2) * k * 5e18 * 2**192\n        r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\n        // add ln(2**96 / 10**18) * 5e18 * 2**192\n        r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n        // base conversion: mul 2**18 / 2**192\n        r >>= 174;\n    }\n}\n\n/// @dev Will return 0 instead of reverting if y is zero.\nfunction unsafeDiv(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Divide x by y.\n        r := sdiv(x, y)\n    }\n}\n"},"hedge/script/Counter.s.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Script.sol\";\n\ncontract CounterScript is Script {\n    function setUp() public {}\n\n    function run() public {\n        vm.broadcast();\n    }\n}\n"},"hedge/src/Counter.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ncontract Counter {\n    uint256 public number;\n\n    function setNumber(uint256 newNumber) public {\n        number = newNumber;\n    }\n\n    function increment() public {\n        number++;\n    }\n}\n"},"hedge/test/Counter.t.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/Counter.sol\";\n\ncontract CounterTest is Test {\n    Counter public counter;\n\n    function setUp() public {\n        counter = new Counter();\n        counter.setNumber(0);\n    }\n\n    function testIncrement() public {\n        counter.increment();\n        assertEq(counter.number(), 1);\n    }\n\n    function testSetNumber(uint256 x) public {\n        counter.setNumber(x);\n        assertEq(counter.number(), x);\n    }\n}\n"}},"settings":{"remappings":["ds-test/=hedge/lib/forge-std/lib/ds-test/src/","solmate/=hedge/lib/solmate/src/","forge-std/=hedge/lib/forge-std/src/","test/=hedge/test/","src/=hedge/src/","script/=hedge/script/"],"optimizer":{"enabled":false,"runs":200},"outputSelection":{"*":{"":["ast"],"*":["*"]}},"evmVersion":"shanghai","libraries":{}}}